{"ast":null,"code":"import { delimiter } from '../modules/core/regex.js';\nimport { globals } from '../utils/window.js';\nimport { register } from '../utils/adopter.js';\nimport { registerMethods } from '../utils/methods.js';\nimport Matrix from './Matrix.js';\nimport Point from './Point.js';\nimport parser from '../modules/core/parser.js';\nexport function isNulledBox(box) {\n  return !box.width && !box.height && !box.x && !box.y;\n}\nexport function domContains(node) {\n  return node === globals.document || (globals.document.documentElement.contains || function (node) {\n    // This is IE - it does not support contains() for top-level SVGs\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    return node === globals.document;\n  }).call(globals.document.documentElement, node);\n}\nexport default class Box {\n  constructor(...args) {\n    this.init(...args);\n  }\n  addOffset() {\n    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n    this.x += globals.window.pageXOffset;\n    this.y += globals.window.pageYOffset;\n    return new Box(this);\n  }\n  init(source) {\n    const base = [0, 0, 0, 0];\n    source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : typeof source === 'object' ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;\n    this.x = source[0] || 0;\n    this.y = source[1] || 0;\n    this.width = this.w = source[2] || 0;\n    this.height = this.h = source[3] || 0;\n\n    // Add more bounding box properties\n    this.x2 = this.x + this.w;\n    this.y2 = this.y + this.h;\n    this.cx = this.x + this.w / 2;\n    this.cy = this.y + this.h / 2;\n    return this;\n  }\n  isNulled() {\n    return isNulledBox(this);\n  }\n\n  // Merge rect box with another, return a new instance\n  merge(box) {\n    const x = Math.min(this.x, box.x);\n    const y = Math.min(this.y, box.y);\n    const width = Math.max(this.x + this.width, box.x + box.width) - x;\n    const height = Math.max(this.y + this.height, box.y + box.height) - y;\n    return new Box(x, y, width, height);\n  }\n  toArray() {\n    return [this.x, this.y, this.width, this.height];\n  }\n  toString() {\n    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;\n  }\n  transform(m) {\n    if (!(m instanceof Matrix)) {\n      m = new Matrix(m);\n    }\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n    const pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];\n    pts.forEach(function (p) {\n      p = p.transform(m);\n      xMin = Math.min(xMin, p.x);\n      xMax = Math.max(xMax, p.x);\n      yMin = Math.min(yMin, p.y);\n      yMax = Math.max(yMax, p.y);\n    });\n    return new Box(xMin, yMin, xMax - xMin, yMax - yMin);\n  }\n}\nfunction getBox(el, getBBoxFn, retry) {\n  let box;\n  try {\n    // Try to get the box with the provided function\n    box = getBBoxFn(el.node);\n\n    // If the box is worthless and not even in the dom, retry\n    // by throwing an error here...\n    if (isNulledBox(box) && !domContains(el.node)) {\n      throw new Error('Element not in the dom');\n    }\n  } catch (e) {\n    // ... and calling the retry handler here\n    box = retry(el);\n  }\n  return box;\n}\nexport function bbox() {\n  // Function to get bbox is getBBox()\n  const getBBox = node => node.getBBox();\n\n  // Take all measures so that a stupid browser renders the element\n  // so we can get the bbox from it when we try again\n  const retry = el => {\n    try {\n      const clone = el.clone().addTo(parser().svg).show();\n      const box = clone.node.getBBox();\n      clone.remove();\n      return box;\n    } catch (e) {\n      // We give up...\n      throw new Error(`Getting bbox of element \"${el.node.nodeName}\" is not possible: ${e.toString()}`);\n    }\n  };\n  const box = getBox(this, getBBox, retry);\n  const bbox = new Box(box);\n  return bbox;\n}\nexport function rbox(el) {\n  const getRBox = node => node.getBoundingClientRect();\n  const retry = el => {\n    // There is no point in trying tricks here because if we insert the element into the dom ourselves\n    // it obviously will be at the wrong position\n    throw new Error(`Getting rbox of element \"${el.node.nodeName}\" is not possible`);\n  };\n  const box = getBox(this, getRBox, retry);\n  const rbox = new Box(box);\n\n  // If an element was passed, we want the bbox in the coordinate system of that element\n  if (el) {\n    return rbox.transform(el.screenCTM().inverseO());\n  }\n\n  // Else we want it in absolute screen coordinates\n  // Therefore we need to add the scrollOffset\n  return rbox.addOffset();\n}\n\n// Checks whether the given point is inside the bounding box\nexport function inside(x, y) {\n  const box = this.bbox();\n  return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;\n}\nregisterMethods({\n  viewbox: {\n    viewbox(x, y, width, height) {\n      // act as getter\n      if (x == null) return new Box(this.attr('viewBox'));\n\n      // act as setter\n      return this.attr('viewBox', new Box(x, y, width, height));\n    },\n    zoom(level, point) {\n      // Its best to rely on the attributes here and here is why:\n      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)\n      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely\n      //                        that means, their clientRect is always as big as the content.\n      //                        Furthermore this size is incorrect if the element is further transformed by its parents\n      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!\n      // getBBox: returns the bounding box of its content - that doesn't help!\n      let {\n        width,\n        height\n      } = this.attr(['width', 'height']);\n\n      // Width and height is a string when a number with a unit is present which we can't use\n      // So we try clientXYZ\n      if (!width && !height || typeof width === 'string' || typeof height === 'string') {\n        width = this.node.clientWidth;\n        height = this.node.clientHeight;\n      }\n\n      // Giving up...\n      if (!width || !height) {\n        throw new Error('Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element');\n      }\n      const v = this.viewbox();\n      const zoomX = width / v.width;\n      const zoomY = height / v.height;\n      const zoom = Math.min(zoomX, zoomY);\n      if (level == null) {\n        return zoom;\n      }\n      let zoomAmount = zoom / level;\n\n      // Set the zoomAmount to the highest value which is safe to process and recover from\n      // The * 100 is a bit of wiggle room for the matrix transformation\n      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100;\n      point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);\n      const box = new Box(v).transform(new Matrix({\n        scale: zoomAmount,\n        origin: point\n      }));\n      return this.viewbox(box);\n    }\n  }\n});\nregister(Box, 'Box');","map":{"version":3,"names":["delimiter","globals","register","registerMethods","Matrix","Point","parser","isNulledBox","box","width","height","x","y","domContains","node","document","documentElement","contains","parentNode","call","Box","constructor","args","init","addOffset","window","pageXOffset","pageYOffset","source","base","split","map","parseFloat","Array","isArray","left","top","arguments","length","slice","w","h","x2","y2","cx","cy","isNulled","merge","Math","min","max","toArray","toString","transform","m","xMin","Infinity","xMax","yMin","yMax","pts","forEach","p","getBox","el","getBBoxFn","retry","Error","e","bbox","getBBox","clone","addTo","svg","show","remove","nodeName","rbox","getRBox","getBoundingClientRect","screenCTM","inverseO","inside","viewbox","attr","zoom","level","point","clientWidth","clientHeight","v","zoomX","zoomY","zoomAmount","Number","MAX_SAFE_INTEGER","scale","origin"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/@svgdotjs/svg.js/src/types/Box.js"],"sourcesContent":["import { delimiter } from '../modules/core/regex.js'\nimport { globals } from '../utils/window.js'\nimport { register } from '../utils/adopter.js'\nimport { registerMethods } from '../utils/methods.js'\nimport Matrix from './Matrix.js'\nimport Point from './Point.js'\nimport parser from '../modules/core/parser.js'\n\nexport function isNulledBox(box) {\n  return !box.width && !box.height && !box.x && !box.y\n}\n\nexport function domContains(node) {\n  return (\n    node === globals.document ||\n    (\n      globals.document.documentElement.contains ||\n      function (node) {\n        // This is IE - it does not support contains() for top-level SVGs\n        while (node.parentNode) {\n          node = node.parentNode\n        }\n        return node === globals.document\n      }\n    ).call(globals.document.documentElement, node)\n  )\n}\n\nexport default class Box {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  addOffset() {\n    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n    this.x += globals.window.pageXOffset\n    this.y += globals.window.pageYOffset\n    return new Box(this)\n  }\n\n  init(source) {\n    const base = [0, 0, 0, 0]\n    source =\n      typeof source === 'string'\n        ? source.split(delimiter).map(parseFloat)\n        : Array.isArray(source)\n          ? source\n          : typeof source === 'object'\n            ? [\n                source.left != null ? source.left : source.x,\n                source.top != null ? source.top : source.y,\n                source.width,\n                source.height\n              ]\n            : arguments.length === 4\n              ? [].slice.call(arguments)\n              : base\n\n    this.x = source[0] || 0\n    this.y = source[1] || 0\n    this.width = this.w = source[2] || 0\n    this.height = this.h = source[3] || 0\n\n    // Add more bounding box properties\n    this.x2 = this.x + this.w\n    this.y2 = this.y + this.h\n    this.cx = this.x + this.w / 2\n    this.cy = this.y + this.h / 2\n\n    return this\n  }\n\n  isNulled() {\n    return isNulledBox(this)\n  }\n\n  // Merge rect box with another, return a new instance\n  merge(box) {\n    const x = Math.min(this.x, box.x)\n    const y = Math.min(this.y, box.y)\n    const width = Math.max(this.x + this.width, box.x + box.width) - x\n    const height = Math.max(this.y + this.height, box.y + box.height) - y\n\n    return new Box(x, y, width, height)\n  }\n\n  toArray() {\n    return [this.x, this.y, this.width, this.height]\n  }\n\n  toString() {\n    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\n  }\n\n  transform(m) {\n    if (!(m instanceof Matrix)) {\n      m = new Matrix(m)\n    }\n\n    let xMin = Infinity\n    let xMax = -Infinity\n    let yMin = Infinity\n    let yMax = -Infinity\n\n    const pts = [\n      new Point(this.x, this.y),\n      new Point(this.x2, this.y),\n      new Point(this.x, this.y2),\n      new Point(this.x2, this.y2)\n    ]\n\n    pts.forEach(function (p) {\n      p = p.transform(m)\n      xMin = Math.min(xMin, p.x)\n      xMax = Math.max(xMax, p.x)\n      yMin = Math.min(yMin, p.y)\n      yMax = Math.max(yMax, p.y)\n    })\n\n    return new Box(xMin, yMin, xMax - xMin, yMax - yMin)\n  }\n}\n\nfunction getBox(el, getBBoxFn, retry) {\n  let box\n\n  try {\n    // Try to get the box with the provided function\n    box = getBBoxFn(el.node)\n\n    // If the box is worthless and not even in the dom, retry\n    // by throwing an error here...\n    if (isNulledBox(box) && !domContains(el.node)) {\n      throw new Error('Element not in the dom')\n    }\n  } catch (e) {\n    // ... and calling the retry handler here\n    box = retry(el)\n  }\n\n  return box\n}\n\nexport function bbox() {\n  // Function to get bbox is getBBox()\n  const getBBox = (node) => node.getBBox()\n\n  // Take all measures so that a stupid browser renders the element\n  // so we can get the bbox from it when we try again\n  const retry = (el) => {\n    try {\n      const clone = el.clone().addTo(parser().svg).show()\n      const box = clone.node.getBBox()\n      clone.remove()\n      return box\n    } catch (e) {\n      // We give up...\n      throw new Error(\n        `Getting bbox of element \"${\n          el.node.nodeName\n        }\" is not possible: ${e.toString()}`\n      )\n    }\n  }\n\n  const box = getBox(this, getBBox, retry)\n  const bbox = new Box(box)\n\n  return bbox\n}\n\nexport function rbox(el) {\n  const getRBox = (node) => node.getBoundingClientRect()\n  const retry = (el) => {\n    // There is no point in trying tricks here because if we insert the element into the dom ourselves\n    // it obviously will be at the wrong position\n    throw new Error(\n      `Getting rbox of element \"${el.node.nodeName}\" is not possible`\n    )\n  }\n\n  const box = getBox(this, getRBox, retry)\n  const rbox = new Box(box)\n\n  // If an element was passed, we want the bbox in the coordinate system of that element\n  if (el) {\n    return rbox.transform(el.screenCTM().inverseO())\n  }\n\n  // Else we want it in absolute screen coordinates\n  // Therefore we need to add the scrollOffset\n  return rbox.addOffset()\n}\n\n// Checks whether the given point is inside the bounding box\nexport function inside(x, y) {\n  const box = this.bbox()\n\n  return (\n    x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height\n  )\n}\n\nregisterMethods({\n  viewbox: {\n    viewbox(x, y, width, height) {\n      // act as getter\n      if (x == null) return new Box(this.attr('viewBox'))\n\n      // act as setter\n      return this.attr('viewBox', new Box(x, y, width, height))\n    },\n\n    zoom(level, point) {\n      // Its best to rely on the attributes here and here is why:\n      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)\n      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely\n      //                        that means, their clientRect is always as big as the content.\n      //                        Furthermore this size is incorrect if the element is further transformed by its parents\n      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!\n      // getBBox: returns the bounding box of its content - that doesn't help!\n      let { width, height } = this.attr(['width', 'height'])\n\n      // Width and height is a string when a number with a unit is present which we can't use\n      // So we try clientXYZ\n      if (\n        (!width && !height) ||\n        typeof width === 'string' ||\n        typeof height === 'string'\n      ) {\n        width = this.node.clientWidth\n        height = this.node.clientHeight\n      }\n\n      // Giving up...\n      if (!width || !height) {\n        throw new Error(\n          'Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element'\n        )\n      }\n\n      const v = this.viewbox()\n\n      const zoomX = width / v.width\n      const zoomY = height / v.height\n      const zoom = Math.min(zoomX, zoomY)\n\n      if (level == null) {\n        return zoom\n      }\n\n      let zoomAmount = zoom / level\n\n      // Set the zoomAmount to the highest value which is safe to process and recover from\n      // The * 100 is a bit of wiggle room for the matrix transformation\n      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100\n\n      point =\n        point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y)\n\n      const box = new Box(v).transform(\n        new Matrix({ scale: zoomAmount, origin: point })\n      )\n\n      return this.viewbox(box)\n    }\n  }\n})\n\nregister(Box, 'Box')\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}