{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Base from './Base';\nimport { walk, asyncRun, getNodeIndexInNodeList } from '../utils';\n\n//  组织结构图\n// 和逻辑结构图基本一样，只是方向变成向下生长，所以先计算节点的top，后计算节点的left、最后调整节点的left即可\nclass OrganizationStructure extends Base {\n  //  构造函数\n  constructor(opt = {}) {\n    super(opt);\n  }\n\n  //  布局\n  doLayout(callback) {\n    let task = [() => {\n      this.computedBaseValue();\n    }, () => {\n      this.computedLeftValue();\n    }, () => {\n      this.adjustLeftValue();\n    }, () => {\n      callback(this.root);\n    }];\n    asyncRun(task);\n  }\n\n  //  遍历数据计算节点的left、width、height\n  computedBaseValue() {\n    walk(this.renderer.renderTree, null, (cur, parent, isRoot, layerIndex) => {\n      let newNode = this.createNode(cur, parent, isRoot, layerIndex);\n      // 根节点定位在画布中心位置\n      if (isRoot) {\n        this.setNodeCenter(newNode);\n      } else {\n        // 非根节点\n        // 定位到父节点下方\n        newNode.top = parent._node.top + parent._node.height + this.getMarginX(layerIndex);\n      }\n      if (!cur.data.expand) {\n        return true;\n      }\n    }, (cur, parent, isRoot, layerIndex) => {\n      // 返回时计算节点的areaWidth，也就是子节点所占的宽度之和，包括外边距\n      let len = cur.data.expand === false ? 0 : cur._node.children.length;\n      cur._node.childrenAreaWidth = len ? cur._node.children.reduce((h, item) => {\n        return h + item.width;\n      }, 0) + (len + 1) * this.getMarginY(layerIndex + 1) : 0;\n\n      // 如果存在概要，则和概要的高度取最大值\n      let generalizationNodeWidth = cur._node.checkHasGeneralization() ? cur._node._generalizationNodeWidth + this.getMarginY(layerIndex + 1) : 0;\n      cur._node.childrenAreaWidth2 = Math.max(cur._node.childrenAreaWidth, generalizationNodeWidth);\n    }, true, 0);\n  }\n\n  //  遍历节点树计算节点的left\n  computedLeftValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (node.getData('expand') && node.children && node.children.length) {\n        let marginX = this.getMarginY(layerIndex + 1);\n        // 第一个子节点的left值 = 该节点中心的left值 - 子节点的宽度之和的一半\n        let left = node.left + node.width / 2 - node.childrenAreaWidth / 2;\n        let totalLeft = left + marginX;\n        node.children.forEach(cur => {\n          cur.left = totalLeft;\n          totalLeft += cur.width + marginX;\n        });\n      }\n    }, null, true);\n  }\n\n  //  调整节点left\n  adjustLeftValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (!node.getData('expand')) {\n        return;\n      }\n      // 判断子节点所占的宽度之和是否大于该节点自身，大于则需要调整位置\n      let difference = node.childrenAreaWidth2 - this.getMarginY(layerIndex + 1) * 2 - node.width;\n      if (difference > 0) {\n        this.updateBrothers(node, difference / 2);\n      }\n    }, null, true);\n  }\n\n  //  更新兄弟节点的left\n  updateBrothers(node, addWidth) {\n    if (node.parent) {\n      let childrenList = node.parent.children;\n      let index = getNodeIndexInNodeList(node, childrenList);\n      childrenList.forEach((item, _index) => {\n        if (item.hasCustomPosition()) {\n          // 适配自定义位置\n          return;\n        }\n        let _offset = 0;\n        // 上面的节点往上移\n        if (_index < index) {\n          _offset = -addWidth;\n        } else if (_index > index) {\n          // 下面的节点往下移\n          _offset = addWidth;\n        }\n        item.left += _offset;\n        // 同步更新子节点的位置\n        if (item.children && item.children.length) {\n          this.updateChildren(item.children, 'left', _offset);\n        }\n      });\n      // 更新父节点的位置\n      this.updateBrothers(node.parent, addWidth);\n    }\n  }\n\n  //  绘制连线，连接该节点到其子节点\n  renderLine(node, lines, style, lineStyle) {\n    if (lineStyle === 'direct') {\n      this.renderLineDirect(node, lines, style);\n    } else {\n      this.renderLineStraight(node, lines, style);\n    }\n  }\n\n  //  直连风格\n  renderLineDirect(node, lines, style) {\n    if (node.children.length <= 0) {\n      return [];\n    }\n    let {\n      left,\n      top,\n      width,\n      height\n    } = node;\n    const {\n      nodeUseLineStyle\n    } = this.mindMap.themeConfig;\n    let x1 = left + width / 2;\n    let y1 = top + height;\n    node.children.forEach((item, index) => {\n      let x2 = item.left + item.width / 2;\n      let y2 = item.top;\n      // 节点使用横线风格，需要额外渲染横线\n      let nodeUseLineStylePath = nodeUseLineStyle ? ` L ${item.left},${y2} L ${item.left + item.width},${y2}` : '';\n      let path = `M ${x1},${y1} L ${x2},${y2}` + nodeUseLineStylePath;\n      this.setLineStyle(style, lines[index], path, item);\n    });\n  }\n\n  //  直线风格连线\n  renderLineStraight(node, lines, style) {\n    if (node.children.length <= 0) {\n      return [];\n    }\n    let {\n      left,\n      top,\n      width,\n      height,\n      expandBtnSize,\n      isRoot\n    } = node;\n    if (!this.mindMap.opt.alwaysShowExpandBtn) {\n      expandBtnSize = 0;\n    }\n    let x1 = left + width / 2;\n    let y1 = top + height;\n    let marginX = this.getMarginX(node.layerIndex + 1);\n    let s1 = marginX * 0.7;\n    let minx = Infinity;\n    let maxx = -Infinity;\n    let len = node.children.length;\n    node.children.forEach((item, index) => {\n      let x2 = item.left + item.width / 2;\n      let y2 = y1 + s1 > item.top ? item.top + item.height : item.top;\n      if (x2 < minx) {\n        minx = x2;\n      }\n      if (x2 > maxx) {\n        maxx = x2;\n      }\n      // 节点使用横线风格，需要额外渲染横线\n      let nodeUseLineStylePath = this.mindMap.themeConfig.nodeUseLineStyle ? ` L ${item.left},${y2} L ${item.left + item.width},${y2}` : '';\n      let path = `M ${x2},${y1 + s1} L ${x2},${y2}` + nodeUseLineStylePath;\n      this.setLineStyle(style, lines[index], path, item);\n    });\n    minx = Math.min(x1, minx);\n    maxx = Math.max(x1, maxx);\n    // 父节点的竖线\n    let line1 = this.lineDraw.path();\n    node.style.line(line1);\n    expandBtnSize = len > 0 && !isRoot ? expandBtnSize : 0;\n    line1.plot(this.transformPath(`M ${x1},${y1 + expandBtnSize} L ${x1},${y1 + s1}`));\n    node._lines.push(line1);\n    style && style(line1, node);\n    // 水平线\n    if (len > 0) {\n      let lin2 = this.lineDraw.path();\n      node.style.line(lin2);\n      lin2.plot(this.transformPath(`M ${minx},${y1 + s1} L ${maxx},${y1 + s1}`));\n      node._lines.push(lin2);\n      style && style(lin2, node);\n    }\n  }\n\n  //  渲染按钮\n  renderExpandBtn(node, btn) {\n    let {\n      width,\n      height,\n      expandBtnSize\n    } = node;\n    let {\n      translateX,\n      translateY\n    } = btn.transform();\n    btn.translate(width / 2 - expandBtnSize / 2 - translateX, height + expandBtnSize / 2 - translateY);\n  }\n\n  //  创建概要节点\n  renderGeneralization(list) {\n    list.forEach(item => {\n      let {\n        bottom,\n        left,\n        right,\n        generalizationLineMargin,\n        generalizationNodeMargin\n      } = this.getNodeGeneralizationRenderBoundaries(item, 'v');\n      let x1 = left;\n      let y1 = bottom + generalizationLineMargin;\n      let x2 = right;\n      let y2 = bottom + generalizationLineMargin;\n      let cx = x1 + (x2 - x1) / 2;\n      let cy = y1 + 20;\n      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;\n      item.generalizationLine.plot(this.transformPath(path));\n      item.generalizationNode.top = bottom + generalizationNodeMargin;\n      item.generalizationNode.left = left + (right - left - item.generalizationNode.width) / 2;\n    });\n  }\n\n  // 渲染展开收起按钮的隐藏占位元素\n  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {\n    rect.size(width, expandBtnSize).x(0).y(height);\n  }\n}\nexport default OrganizationStructure;","map":{"version":3,"names":["Base","walk","asyncRun","getNodeIndexInNodeList","OrganizationStructure","constructor","opt","doLayout","callback","task","computedBaseValue","computedLeftValue","adjustLeftValue","root","renderer","renderTree","cur","parent","isRoot","layerIndex","newNode","createNode","setNodeCenter","top","_node","height","getMarginX","data","expand","len","children","length","childrenAreaWidth","reduce","h","item","width","getMarginY","generalizationNodeWidth","checkHasGeneralization","_generalizationNodeWidth","childrenAreaWidth2","Math","max","node","getData","marginX","left","totalLeft","forEach","difference","updateBrothers","addWidth","childrenList","index","_index","hasCustomPosition","_offset","updateChildren","renderLine","lines","style","lineStyle","renderLineDirect","renderLineStraight","nodeUseLineStyle","mindMap","themeConfig","x1","y1","x2","y2","nodeUseLineStylePath","path","setLineStyle","expandBtnSize","alwaysShowExpandBtn","s1","minx","Infinity","maxx","min","line1","lineDraw","line","plot","transformPath","_lines","push","lin2","renderExpandBtn","btn","translateX","translateY","transform","translate","renderGeneralization","list","bottom","right","generalizationLineMargin","generalizationNodeMargin","getNodeGeneralizationRenderBoundaries","cx","cy","generalizationLine","generalizationNode","renderExpandBtnRect","rect","size","x","y"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/simple-mind-map/src/layouts/OrganizationStructure.js"],"sourcesContent":["import Base from './Base'\r\nimport { walk, asyncRun, getNodeIndexInNodeList } from '../utils'\r\n\r\n//  组织结构图\r\n// 和逻辑结构图基本一样，只是方向变成向下生长，所以先计算节点的top，后计算节点的left、最后调整节点的left即可\r\nclass OrganizationStructure extends Base {\r\n  //  构造函数\r\n  constructor(opt = {}) {\r\n    super(opt)\r\n  }\r\n\r\n  //  布局\r\n  doLayout(callback) {\r\n    let task = [\r\n      () => {\r\n        this.computedBaseValue()\r\n      },\r\n      () => {\r\n        this.computedLeftValue()\r\n      },\r\n      () => {\r\n        this.adjustLeftValue()\r\n      },\r\n      () => {\r\n        callback(this.root)\r\n      }\r\n    ]\r\n    asyncRun(task)\r\n  }\r\n\r\n  //  遍历数据计算节点的left、width、height\r\n  computedBaseValue() {\r\n    walk(\r\n      this.renderer.renderTree,\r\n      null,\r\n      (cur, parent, isRoot, layerIndex) => {\r\n        let newNode = this.createNode(cur, parent, isRoot, layerIndex)\r\n        // 根节点定位在画布中心位置\r\n        if (isRoot) {\r\n          this.setNodeCenter(newNode)\r\n        } else {\r\n          // 非根节点\r\n          // 定位到父节点下方\r\n          newNode.top =\r\n            parent._node.top + parent._node.height + this.getMarginX(layerIndex)\r\n        }\r\n        if (!cur.data.expand) {\r\n          return true\r\n        }\r\n      },\r\n      (cur, parent, isRoot, layerIndex) => {\r\n        // 返回时计算节点的areaWidth，也就是子节点所占的宽度之和，包括外边距\r\n        let len = cur.data.expand === false ? 0 : cur._node.children.length\r\n        cur._node.childrenAreaWidth = len\r\n          ? cur._node.children.reduce((h, item) => {\r\n              return h + item.width\r\n            }, 0) +\r\n            (len + 1) * this.getMarginY(layerIndex + 1)\r\n          : 0\r\n\r\n        // 如果存在概要，则和概要的高度取最大值\r\n        let generalizationNodeWidth = cur._node.checkHasGeneralization()\r\n          ? cur._node._generalizationNodeWidth + this.getMarginY(layerIndex + 1)\r\n          : 0\r\n        cur._node.childrenAreaWidth2 = Math.max(\r\n          cur._node.childrenAreaWidth,\r\n          generalizationNodeWidth\r\n        )\r\n      },\r\n      true,\r\n      0\r\n    )\r\n  }\r\n\r\n  //  遍历节点树计算节点的left\r\n  computedLeftValue() {\r\n    walk(\r\n      this.root,\r\n      null,\r\n      (node, parent, isRoot, layerIndex) => {\r\n        if (node.getData('expand') && node.children && node.children.length) {\r\n          let marginX = this.getMarginY(layerIndex + 1)\r\n          // 第一个子节点的left值 = 该节点中心的left值 - 子节点的宽度之和的一半\r\n          let left = node.left + node.width / 2 - node.childrenAreaWidth / 2\r\n          let totalLeft = left + marginX\r\n          node.children.forEach(cur => {\r\n            cur.left = totalLeft\r\n            totalLeft += cur.width + marginX\r\n          })\r\n        }\r\n      },\r\n      null,\r\n      true\r\n    )\r\n  }\r\n\r\n  //  调整节点left\r\n  adjustLeftValue() {\r\n    walk(\r\n      this.root,\r\n      null,\r\n      (node, parent, isRoot, layerIndex) => {\r\n        if (!node.getData('expand')) {\r\n          return\r\n        }\r\n        // 判断子节点所占的宽度之和是否大于该节点自身，大于则需要调整位置\r\n        let difference =\r\n          node.childrenAreaWidth2 -\r\n          this.getMarginY(layerIndex + 1) * 2 -\r\n          node.width\r\n        if (difference > 0) {\r\n          this.updateBrothers(node, difference / 2)\r\n        }\r\n      },\r\n      null,\r\n      true\r\n    )\r\n  }\r\n\r\n  //  更新兄弟节点的left\r\n  updateBrothers(node, addWidth) {\r\n    if (node.parent) {\r\n      let childrenList = node.parent.children\r\n      let index = getNodeIndexInNodeList(node, childrenList)\r\n      childrenList.forEach((item, _index) => {\r\n        if (item.hasCustomPosition()) {\r\n          // 适配自定义位置\r\n          return\r\n        }\r\n        let _offset = 0\r\n        // 上面的节点往上移\r\n        if (_index < index) {\r\n          _offset = -addWidth\r\n        } else if (_index > index) {\r\n          // 下面的节点往下移\r\n          _offset = addWidth\r\n        }\r\n        item.left += _offset\r\n        // 同步更新子节点的位置\r\n        if (item.children && item.children.length) {\r\n          this.updateChildren(item.children, 'left', _offset)\r\n        }\r\n      })\r\n      // 更新父节点的位置\r\n      this.updateBrothers(node.parent, addWidth)\r\n    }\r\n  }\r\n\r\n  //  绘制连线，连接该节点到其子节点\r\n  renderLine(node, lines, style, lineStyle) {\r\n    if (lineStyle === 'direct') {\r\n      this.renderLineDirect(node, lines, style)\r\n    } else {\r\n      this.renderLineStraight(node, lines, style)\r\n    }\r\n  }\r\n\r\n  //  直连风格\r\n  renderLineDirect(node, lines, style) {\r\n    if (node.children.length <= 0) {\r\n      return []\r\n    }\r\n    let { left, top, width, height } = node\r\n    const { nodeUseLineStyle } = this.mindMap.themeConfig\r\n    let x1 = left + width / 2\r\n    let y1 = top + height\r\n    node.children.forEach((item, index) => {\r\n      let x2 = item.left + item.width / 2\r\n      let y2 = item.top\r\n      // 节点使用横线风格，需要额外渲染横线\r\n      let nodeUseLineStylePath = nodeUseLineStyle\r\n        ? ` L ${item.left},${y2} L ${item.left + item.width},${y2}`\r\n        : ''\r\n      let path = `M ${x1},${y1} L ${x2},${y2}` + nodeUseLineStylePath\r\n      this.setLineStyle(style, lines[index], path, item)\r\n    })\r\n  }\r\n\r\n  //  直线风格连线\r\n  renderLineStraight(node, lines, style) {\r\n    if (node.children.length <= 0) {\r\n      return []\r\n    }\r\n    let { left, top, width, height, expandBtnSize, isRoot } = node\r\n    if (!this.mindMap.opt.alwaysShowExpandBtn) {\r\n      expandBtnSize = 0\r\n    }\r\n    let x1 = left + width / 2\r\n    let y1 = top + height\r\n    let marginX = this.getMarginX(node.layerIndex + 1)\r\n    let s1 = marginX * 0.7\r\n    let minx = Infinity\r\n    let maxx = -Infinity\r\n    let len = node.children.length\r\n    node.children.forEach((item, index) => {\r\n      let x2 = item.left + item.width / 2\r\n      let y2 = y1 + s1 > item.top ? item.top + item.height : item.top\r\n      if (x2 < minx) {\r\n        minx = x2\r\n      }\r\n      if (x2 > maxx) {\r\n        maxx = x2\r\n      }\r\n      // 节点使用横线风格，需要额外渲染横线\r\n      let nodeUseLineStylePath = this.mindMap.themeConfig.nodeUseLineStyle\r\n        ? ` L ${item.left},${y2} L ${item.left + item.width},${y2}`\r\n        : ''\r\n      let path = `M ${x2},${y1 + s1} L ${x2},${y2}` + nodeUseLineStylePath\r\n      this.setLineStyle(style, lines[index], path, item)\r\n    })\r\n    minx = Math.min(x1, minx)\r\n    maxx = Math.max(x1, maxx)\r\n    // 父节点的竖线\r\n    let line1 = this.lineDraw.path()\r\n    node.style.line(line1)\r\n    expandBtnSize = len > 0 && !isRoot ? expandBtnSize : 0\r\n    line1.plot(\r\n      this.transformPath(`M ${x1},${y1 + expandBtnSize} L ${x1},${y1 + s1}`)\r\n    )\r\n    node._lines.push(line1)\r\n    style && style(line1, node)\r\n    // 水平线\r\n    if (len > 0) {\r\n      let lin2 = this.lineDraw.path()\r\n      node.style.line(lin2)\r\n      lin2.plot(this.transformPath(`M ${minx},${y1 + s1} L ${maxx},${y1 + s1}`))\r\n      node._lines.push(lin2)\r\n      style && style(lin2, node)\r\n    }\r\n  }\r\n\r\n  //  渲染按钮\r\n  renderExpandBtn(node, btn) {\r\n    let { width, height, expandBtnSize } = node\r\n    let { translateX, translateY } = btn.transform()\r\n    btn.translate(\r\n      width / 2 - expandBtnSize / 2 - translateX,\r\n      height + expandBtnSize / 2 - translateY\r\n    )\r\n  }\r\n\r\n  //  创建概要节点\r\n  renderGeneralization(list) {\r\n    list.forEach(item => {\r\n      let {\r\n        bottom,\r\n        left,\r\n        right,\r\n        generalizationLineMargin,\r\n        generalizationNodeMargin\r\n      } = this.getNodeGeneralizationRenderBoundaries(item, 'v')\r\n      let x1 = left\r\n      let y1 = bottom + generalizationLineMargin\r\n      let x2 = right\r\n      let y2 = bottom + generalizationLineMargin\r\n      let cx = x1 + (x2 - x1) / 2\r\n      let cy = y1 + 20\r\n      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`\r\n      item.generalizationLine.plot(this.transformPath(path))\r\n      item.generalizationNode.top = bottom + generalizationNodeMargin\r\n      item.generalizationNode.left =\r\n        left + (right - left - item.generalizationNode.width) / 2\r\n    })\r\n  }\r\n\r\n  // 渲染展开收起按钮的隐藏占位元素\r\n  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {\r\n    rect.size(width, expandBtnSize).x(0).y(height)\r\n  }\r\n}\r\n\r\nexport default OrganizationStructure\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}