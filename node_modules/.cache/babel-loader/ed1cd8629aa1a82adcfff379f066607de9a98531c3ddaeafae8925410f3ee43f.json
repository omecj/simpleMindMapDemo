{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Node from '../core/render/node/Node';\nimport { CONSTANTS, initRootNodePositionMap } from '../constants/constant';\nimport Lru from '../utils/Lru';\nimport { createUid } from '../utils/index';\n\n//  布局基类\nclass Base {\n  //  构造函数\n  constructor(renderer) {\n    // 渲染实例\n    this.renderer = renderer;\n    // 控制实例\n    this.mindMap = renderer.mindMap;\n    // 绘图对象\n    this.draw = this.mindMap.draw;\n    this.lineDraw = this.mindMap.lineDraw;\n    // 根节点\n    this.root = null;\n    this.lru = new Lru(this.mindMap.opt.maxNodeCacheCount);\n    // 当initRootNodePosition不为默认的值时，根节点的位置距默认的配置时根节点距离的差值\n    this.rootNodeCenterOffset = null;\n  }\n\n  //  计算节点位置\n  doLayout() {\n    throw new Error('【computed】方法为必要方法，需要子类进行重写！');\n  }\n\n  //  连线\n  renderLine() {\n    throw new Error('【renderLine】方法为必要方法，需要子类进行重写！');\n  }\n\n  //  定位展开收缩按钮\n  renderExpandBtn() {\n    throw new Error('【renderExpandBtn】方法为必要方法，需要子类进行重写！');\n  }\n\n  //  概要节点\n  renderGeneralization() {}\n\n  // 通过uid缓存节点\n  cacheNode(uid, node) {\n    // 记录本次渲染时的节点\n    this.renderer.nodeCache[uid] = node;\n    // 缓存所有渲染过的节点\n    this.lru.add(uid, node);\n  }\n\n  // 检查当前来源是否需要重新计算节点大小\n  checkIsNeedResizeSources() {\n    return [CONSTANTS.CHANGE_THEME, CONSTANTS.TRANSFORM_TO_NORMAL_NODE].includes(this.renderer.renderSource);\n  }\n\n  // 层级类型改变\n  checkIsLayerTypeChange(oldIndex, newIndex) {\n    if (oldIndex >= 2 && newIndex >= 2) return false;\n    if (oldIndex >= 2 && newIndex < 2) return true;\n    if (oldIndex < 2 && newIndex >= 2) return true;\n  }\n\n  // 检查是否是结构布局改变重新渲染展开收起按钮占位元素\n  checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(node) {\n    if (this.renderer.renderSource === CONSTANTS.CHANGE_LAYOUT) {\n      node.needRerenderExpandBtnPlaceholderRect = true;\n    }\n  }\n\n  //  创建节点实例\n  createNode(data, parent, isRoot, layerIndex) {\n    // 创建节点\n    const uid = data.data.uid;\n    let newNode = null;\n    // 数据上保存了节点引用，那么直接复用节点\n    if (data && data._node && !this.renderer.reRender) {\n      newNode = data._node;\n      const isLayerTypeChange = this.checkIsLayerTypeChange(newNode.layerIndex, layerIndex);\n      newNode.reset();\n      newNode.layerIndex = layerIndex;\n      this.cacheNode(data._node.uid, newNode);\n      this.checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(newNode);\n      // 主题或主题配置改变了、节点层级改变了，需要重新渲染节点文本等情况需要重新计算节点大小和布局\n      if (this.checkIsNeedResizeSources() || isLayerTypeChange || newNode.getData('resetRichText')) {\n        newNode.getSize();\n        newNode.needLayout = true;\n      }\n    } else if ((this.lru.has(uid) || this.renderer.lastNodeCache[uid]) && !this.renderer.reRender) {\n      // 节点数据上没有节点实例\n      // 但是通过uid在节点缓存池中找到了缓存的节点\n      // 或者在上一次渲染缓存对象中找到了节点\n      // 也可以直接复用\n      newNode = this.lru.get(uid) || this.renderer.lastNodeCache[uid];\n      // 保存该节点上一次的数据\n      const lastData = JSON.stringify(newNode.getData());\n      const isLayerTypeChange = this.checkIsLayerTypeChange(newNode.layerIndex, layerIndex);\n      newNode.reset();\n      newNode.nodeData = newNode.handleData(data || {});\n      newNode.layerIndex = layerIndex;\n      this.cacheNode(uid, newNode);\n      this.checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(newNode);\n      data._node = newNode;\n      // 主题或主题配置改变了需要重新计算节点大小和布局\n      const isResizeSource = this.checkIsNeedResizeSources();\n      // 主题或主题配置改变了、节点层级改变了，需要重新渲染节点文本，节点数据改变了等情况需要重新计算节点大小和布局\n      const isNodeDataChange = lastData !== JSON.stringify(data.data);\n      if (isResizeSource || isNodeDataChange || isLayerTypeChange || newNode.getData('resetRichText')) {\n        newNode.getSize();\n        newNode.needLayout = true;\n      }\n    } else {\n      // 创建新节点\n      const newUid = uid || createUid();\n      newNode = new Node({\n        data,\n        uid: newUid,\n        renderer: this.renderer,\n        mindMap: this.mindMap,\n        draw: this.draw,\n        layerIndex\n      });\n      // uid保存到数据上，为了节点复用\n      data.data.uid = newUid;\n      this.cacheNode(newUid, newNode);\n      // 数据关联实际节点\n      data._node = newNode;\n    }\n    // 如果该节点数据是已激活状态，那么添加到激活节点列表里\n    if (data.data.isActive) {\n      this.renderer.addNodeToActiveList(newNode);\n    }\n    // 如果当前节点在激活节点列表里，那么添加上激活的状态\n    if (this.mindMap.renderer.findActiveNodeIndex(newNode) !== -1) {\n      newNode.setData({\n        isActive: true\n      });\n    }\n    // 根节点\n    if (isRoot) {\n      newNode.isRoot = true;\n      this.root = newNode;\n    } else {\n      // 互相收集\n      newNode.parent = parent._node;\n      parent._node.addChildren(newNode);\n    }\n    return newNode;\n  }\n\n  // 格式化节点位置\n  formatPosition(value, size, nodeSize) {\n    if (typeof value === 'number') {\n      return value;\n    } else if (initRootNodePositionMap[value] !== undefined) {\n      return size * initRootNodePositionMap[value];\n    } else if (/^\\d\\d*%$/.test(value)) {\n      return Number.parseFloat(value) / 100 * size;\n    } else {\n      return (size - nodeSize) / 2;\n    }\n  }\n\n  // 规范initRootNodePosition配置\n  formatInitRootNodePosition(pos) {\n    const {\n      CENTER\n    } = CONSTANTS.INIT_ROOT_NODE_POSITION;\n    if (!pos || !Array.isArray(pos) || pos.length < 2) {\n      pos = [CENTER, CENTER];\n    }\n    return pos;\n  }\n\n  //  定位节点到画布中间\n  setNodeCenter(node, position) {\n    let {\n      initRootNodePosition\n    } = this.mindMap.opt;\n    initRootNodePosition = this.formatInitRootNodePosition(position || initRootNodePosition);\n    node.left = this.formatPosition(initRootNodePosition[0], this.mindMap.width, node.width);\n    node.top = this.formatPosition(initRootNodePosition[1], this.mindMap.height, node.height);\n  }\n\n  // 当initRootNodePosition配置不为默认的['center','center']时，计算当前配置和默认配置情况下，根节点位置的差值\n  getRootCenterOffset(width, height) {\n    // 因为根节点的大小不会影响这个差值，所以计算一次就足够了\n    if (this.rootNodeCenterOffset) return this.rootNodeCenterOffset;\n    let {\n      initRootNodePosition\n    } = this.mindMap.opt;\n    const {\n      CENTER\n    } = CONSTANTS.INIT_ROOT_NODE_POSITION;\n    initRootNodePosition = this.formatInitRootNodePosition(initRootNodePosition);\n    if (initRootNodePosition[0] === CENTER && initRootNodePosition[1] === CENTER) {\n      // 如果initRootNodePosition是默认的，那么不需要计算\n      this.rootNodeCenterOffset = {\n        x: 0,\n        y: 0\n      };\n    } else {\n      // 否则需要计算当前配置和默认配置的差值\n      const tmpNode = {\n        width: width,\n        height: height\n      };\n      const tmpNode2 = {\n        width: width,\n        height: height\n      };\n      this.setNodeCenter(tmpNode, [CENTER, CENTER]);\n      this.setNodeCenter(tmpNode2);\n      this.rootNodeCenterOffset = {\n        x: tmpNode2.left - tmpNode.left,\n        y: tmpNode2.top - tmpNode.top\n      };\n    }\n    return this.rootNodeCenterOffset;\n  }\n\n  //  更新子节点属性\n  updateChildren(children, prop, offset) {\n    children.forEach(item => {\n      item[prop] += offset;\n      if (item.children && item.children.length && !item.hasCustomPosition()) {\n        // 适配自定义位置\n        this.updateChildren(item.children, prop, offset);\n      }\n    });\n  }\n\n  //  更新子节点多个属性\n  updateChildrenPro(children, props) {\n    children.forEach(item => {\n      Object.keys(props).forEach(prop => {\n        item[prop] += props[prop];\n      });\n      if (item.children && item.children.length && !item.hasCustomPosition()) {\n        // 适配自定义位置\n        this.updateChildrenPro(item.children, props);\n      }\n    });\n  }\n\n  //  递归计算节点的宽度\n  getNodeAreaWidth(node, withGeneralization = false) {\n    let widthArr = [];\n    let totalGeneralizationNodeWidth = 0;\n    let loop = (node, width) => {\n      if (withGeneralization && node.checkHasGeneralization()) {\n        totalGeneralizationNodeWidth += node._generalizationNodeWidth;\n      }\n      if (node.children.length) {\n        width += node.width / 2;\n        node.children.forEach(item => {\n          loop(item, width);\n        });\n      } else {\n        width += node.width;\n        widthArr.push(width);\n      }\n    };\n    loop(node, 0);\n    return Math.max(...widthArr) + totalGeneralizationNodeWidth;\n  }\n\n  //  二次贝塞尔曲线\n  quadraticCurvePath(x1, y1, x2, y2) {\n    let cx = x1 + (x2 - x1) * 0.2;\n    let cy = y1 + (y2 - y1) * 0.8;\n    return `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;\n  }\n\n  //  三次贝塞尔曲线\n  cubicBezierPath(x1, y1, x2, y2) {\n    let cx1 = x1 + (x2 - x1) / 2;\n    let cy1 = y1;\n    let cx2 = cx1;\n    let cy2 = y2;\n    return `M ${x1},${y1} C ${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`;\n  }\n\n  // 根据a,b两个点的位置，计算去除圆角大小后的新的b点\n  computeNewPoint(a, b, radius = 0) {\n    // x坐标相同\n    if (a[0] === b[0]) {\n      // b在a下方\n      if (b[1] > a[1]) {\n        return [b[0], b[1] - radius];\n      } else {\n        // b在a上方\n        return [b[0], b[1] + radius];\n      }\n    } else if (a[1] === b[1]) {\n      // y坐标相同\n      // b在a右边\n      if (b[0] > a[0]) {\n        return [b[0] - radius, b[1]];\n      } else {\n        return [b[0] + radius, b[1]];\n      }\n    }\n  }\n\n  // 创建一段折线路径\n  // 最后一个拐角支持圆角\n  createFoldLine(list) {\n    const {\n      lineRadius\n    } = this.mindMap.themeConfig;\n    const len = list.length;\n    let path = '';\n    let radiusPath = '';\n    if (len >= 3 && lineRadius > 0) {\n      const start = list[len - 3];\n      const center = list[len - 2];\n      const end = list[len - 1];\n      // 如果三点在一条直线，那么不用处理\n      const isOneLine = start[0] === center[0] && center[0] === end[0] || start[1] === center[1] && center[1] === end[1];\n      if (!isOneLine) {\n        const cStart = this.computeNewPoint(start, center, lineRadius);\n        const cEnd = this.computeNewPoint(end, center, lineRadius);\n        radiusPath = `Q ${center[0]},${center[1]} ${cEnd[0]},${cEnd[1]}`;\n        list.splice(len - 2, 1, cStart, radiusPath);\n      }\n    }\n    list.forEach((item, index) => {\n      if (typeof item === 'string') {\n        path += item;\n      } else {\n        const [x, y] = item;\n        if (index === 0) {\n          path += `M ${x},${y}`;\n        } else {\n          path += `L ${x},${y}`;\n        }\n      }\n    });\n    return path;\n  }\n\n  //   获取节点的marginX\n  getMarginX(layerIndex) {\n    const {\n      themeConfig,\n      opt\n    } = this.mindMap;\n    const {\n      second,\n      node\n    } = themeConfig;\n    const hoverRectPadding = opt.hoverRectPadding * 2;\n    return layerIndex === 1 ? second.marginX + hoverRectPadding : node.marginX + hoverRectPadding;\n  }\n\n  //  获取节点的marginY\n  getMarginY(layerIndex) {\n    const {\n      themeConfig,\n      opt\n    } = this.mindMap;\n    const {\n      second,\n      node\n    } = themeConfig;\n    const hoverRectPadding = opt.hoverRectPadding * 2;\n    return layerIndex === 1 ? second.marginY + hoverRectPadding : node.marginY + hoverRectPadding;\n  }\n\n  //  获取节点包括概要在内的宽度\n  getNodeWidthWithGeneralization(node) {\n    return Math.max(node.width, node.checkHasGeneralization() ? node._generalizationNodeWidth : 0);\n  }\n\n  //  获取节点包括概要在内的高度\n  getNodeHeightWithGeneralization(node) {\n    return Math.max(node.height, node.checkHasGeneralization() ? node._generalizationNodeHeight : 0);\n  }\n\n  //  获取节点的边界值\n  /**\r\n   * dir：生长方向，h（水平）、v（垂直）\r\n   * isLeft：是否向左生长\r\n   */\n  getNodeBoundaries(node, dir) {\n    let {\n      generalizationLineMargin,\n      generalizationNodeMargin\n    } = this.mindMap.themeConfig;\n    let walk = root => {\n      let _left = Infinity;\n      let _right = -Infinity;\n      let _top = Infinity;\n      let _bottom = -Infinity;\n      if (root.children && root.children.length > 0) {\n        root.children.forEach(child => {\n          let {\n            left,\n            right,\n            top,\n            bottom\n          } = walk(child);\n          // 概要内容的宽度\n          let generalizationWidth = child.checkHasGeneralization() && child.getData('expand') ? child._generalizationNodeWidth + generalizationNodeMargin : 0;\n          // 概要内容的高度\n          let generalizationHeight = child.checkHasGeneralization() && child.getData('expand') ? child._generalizationNodeHeight + generalizationNodeMargin : 0;\n          if (left - (dir === 'h' ? generalizationWidth : 0) < _left) {\n            _left = left - (dir === 'h' ? generalizationWidth : 0);\n          }\n          if (right + (dir === 'h' ? generalizationWidth : 0) > _right) {\n            _right = right + (dir === 'h' ? generalizationWidth : 0);\n          }\n          if (top < _top) {\n            _top = top;\n          }\n          if (bottom + (dir === 'v' ? generalizationHeight : 0) > _bottom) {\n            _bottom = bottom + (dir === 'v' ? generalizationHeight : 0);\n          }\n        });\n      }\n      let cur = {\n        left: root.left,\n        right: root.left + root.width,\n        top: root.top,\n        bottom: root.top + root.height\n      };\n      return {\n        left: cur.left < _left ? cur.left : _left,\n        right: cur.right > _right ? cur.right : _right,\n        top: cur.top < _top ? cur.top : _top,\n        bottom: cur.bottom > _bottom ? cur.bottom : _bottom\n      };\n    };\n    let {\n      left,\n      right,\n      top,\n      bottom\n    } = walk(node);\n    return {\n      left,\n      right,\n      top,\n      bottom,\n      generalizationLineMargin,\n      generalizationNodeMargin\n    };\n  }\n\n  // 获取指定索引区间的子节点的边界范围\n  getChildrenBoundaries(node, dir, startIndex = 0, endIndex) {\n    let {\n      generalizationLineMargin,\n      generalizationNodeMargin\n    } = this.mindMap.themeConfig;\n    const children = node.children.slice(startIndex, endIndex + 1);\n    let left = Infinity;\n    let right = -Infinity;\n    let top = Infinity;\n    let bottom = -Infinity;\n    children.forEach(item => {\n      const cur = this.getNodeBoundaries(item, dir);\n      left = cur.left < left ? cur.left : left;\n      right = cur.right > right ? cur.right : right;\n      top = cur.top < top ? cur.top : top;\n      bottom = cur.bottom > bottom ? cur.bottom : bottom;\n    });\n    return {\n      left,\n      right,\n      top,\n      bottom,\n      generalizationLineMargin,\n      generalizationNodeMargin\n    };\n  }\n\n  // 获取节点概要的渲染边界\n  getNodeGeneralizationRenderBoundaries(item, dir) {\n    let res = null;\n    // 区间\n    if (item.range) {\n      res = this.getChildrenBoundaries(item.node, dir, item.range[0], item.range[1]);\n    } else {\n      // 整体概要\n      res = this.getNodeBoundaries(item.node, dir);\n    }\n    return res;\n  }\n\n  // 获取节点实际存在几个子节点\n  getNodeActChildrenLength(node) {\n    return node.nodeData.children && node.nodeData.children.length;\n  }\n\n  // 设置连线样式\n  setLineStyle(style, line, path, childNode) {\n    line.plot(this.transformPath(path));\n    style && style(line, childNode, true);\n  }\n\n  // 转换路径，可以转换成特殊风格的线条样式\n  transformPath(path) {\n    const {\n      customTransformNodeLinePath\n    } = this.mindMap.opt;\n    if (customTransformNodeLinePath) {\n      return customTransformNodeLinePath(path);\n    } else {\n      return path;\n    }\n  }\n}\nexport default Base;","map":{"version":3,"names":["Node","CONSTANTS","initRootNodePositionMap","Lru","createUid","Base","constructor","renderer","mindMap","draw","lineDraw","root","lru","opt","maxNodeCacheCount","rootNodeCenterOffset","doLayout","Error","renderLine","renderExpandBtn","renderGeneralization","cacheNode","uid","node","nodeCache","add","checkIsNeedResizeSources","CHANGE_THEME","TRANSFORM_TO_NORMAL_NODE","includes","renderSource","checkIsLayerTypeChange","oldIndex","newIndex","checkIsLayoutChangeRerenderExpandBtnPlaceholderRect","CHANGE_LAYOUT","needRerenderExpandBtnPlaceholderRect","createNode","data","parent","isRoot","layerIndex","newNode","_node","reRender","isLayerTypeChange","reset","getData","getSize","needLayout","has","lastNodeCache","get","lastData","JSON","stringify","nodeData","handleData","isResizeSource","isNodeDataChange","newUid","isActive","addNodeToActiveList","findActiveNodeIndex","setData","addChildren","formatPosition","value","size","nodeSize","undefined","test","Number","parseFloat","formatInitRootNodePosition","pos","CENTER","INIT_ROOT_NODE_POSITION","Array","isArray","length","setNodeCenter","position","initRootNodePosition","left","width","top","height","getRootCenterOffset","x","y","tmpNode","tmpNode2","updateChildren","children","prop","offset","forEach","item","hasCustomPosition","updateChildrenPro","props","Object","keys","getNodeAreaWidth","withGeneralization","widthArr","totalGeneralizationNodeWidth","loop","checkHasGeneralization","_generalizationNodeWidth","push","Math","max","quadraticCurvePath","x1","y1","x2","y2","cx","cy","cubicBezierPath","cx1","cy1","cx2","cy2","computeNewPoint","a","b","radius","createFoldLine","list","lineRadius","themeConfig","len","path","radiusPath","start","center","end","isOneLine","cStart","cEnd","splice","index","getMarginX","second","hoverRectPadding","marginX","getMarginY","marginY","getNodeWidthWithGeneralization","getNodeHeightWithGeneralization","_generalizationNodeHeight","getNodeBoundaries","dir","generalizationLineMargin","generalizationNodeMargin","walk","_left","Infinity","_right","_top","_bottom","child","right","bottom","generalizationWidth","generalizationHeight","cur","getChildrenBoundaries","startIndex","endIndex","slice","getNodeGeneralizationRenderBoundaries","res","range","getNodeActChildrenLength","setLineStyle","style","line","childNode","plot","transformPath","customTransformNodeLinePath"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/simple-mind-map/src/layouts/Base.js"],"sourcesContent":["import Node from '../core/render/node/Node'\r\nimport { CONSTANTS, initRootNodePositionMap } from '../constants/constant'\r\nimport Lru from '../utils/Lru'\r\nimport { createUid } from '../utils/index'\r\n\r\n//  布局基类\r\nclass Base {\r\n  //  构造函数\r\n  constructor(renderer) {\r\n    // 渲染实例\r\n    this.renderer = renderer\r\n    // 控制实例\r\n    this.mindMap = renderer.mindMap\r\n    // 绘图对象\r\n    this.draw = this.mindMap.draw\r\n    this.lineDraw = this.mindMap.lineDraw\r\n    // 根节点\r\n    this.root = null\r\n    this.lru = new Lru(this.mindMap.opt.maxNodeCacheCount)\r\n    // 当initRootNodePosition不为默认的值时，根节点的位置距默认的配置时根节点距离的差值\r\n    this.rootNodeCenterOffset = null\r\n  }\r\n\r\n  //  计算节点位置\r\n  doLayout() {\r\n    throw new Error('【computed】方法为必要方法，需要子类进行重写！')\r\n  }\r\n\r\n  //  连线\r\n  renderLine() {\r\n    throw new Error('【renderLine】方法为必要方法，需要子类进行重写！')\r\n  }\r\n\r\n  //  定位展开收缩按钮\r\n  renderExpandBtn() {\r\n    throw new Error('【renderExpandBtn】方法为必要方法，需要子类进行重写！')\r\n  }\r\n\r\n  //  概要节点\r\n  renderGeneralization() {}\r\n\r\n  // 通过uid缓存节点\r\n  cacheNode(uid, node) {\r\n    // 记录本次渲染时的节点\r\n    this.renderer.nodeCache[uid] = node\r\n    // 缓存所有渲染过的节点\r\n    this.lru.add(uid, node)\r\n  }\r\n\r\n  // 检查当前来源是否需要重新计算节点大小\r\n  checkIsNeedResizeSources() {\r\n    return [\r\n      CONSTANTS.CHANGE_THEME,\r\n      CONSTANTS.TRANSFORM_TO_NORMAL_NODE\r\n    ].includes(this.renderer.renderSource)\r\n  }\r\n\r\n  // 层级类型改变\r\n  checkIsLayerTypeChange(oldIndex, newIndex) {\r\n    if (oldIndex >= 2 && newIndex >= 2) return false\r\n    if (oldIndex >= 2 && newIndex < 2) return true\r\n    if (oldIndex < 2 && newIndex >= 2) return true\r\n  }\r\n\r\n  // 检查是否是结构布局改变重新渲染展开收起按钮占位元素\r\n  checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(node) {\r\n    if (this.renderer.renderSource === CONSTANTS.CHANGE_LAYOUT) {\r\n      node.needRerenderExpandBtnPlaceholderRect = true\r\n    }\r\n  }\r\n\r\n  //  创建节点实例\r\n  createNode(data, parent, isRoot, layerIndex) {\r\n    // 创建节点\r\n    const uid = data.data.uid\r\n    let newNode = null\r\n    // 数据上保存了节点引用，那么直接复用节点\r\n    if (data && data._node && !this.renderer.reRender) {\r\n      newNode = data._node\r\n      const isLayerTypeChange = this.checkIsLayerTypeChange(\r\n        newNode.layerIndex,\r\n        layerIndex\r\n      )\r\n      newNode.reset()\r\n      newNode.layerIndex = layerIndex\r\n      this.cacheNode(data._node.uid, newNode)\r\n      this.checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(newNode)\r\n      // 主题或主题配置改变了、节点层级改变了，需要重新渲染节点文本等情况需要重新计算节点大小和布局\r\n      if (\r\n        this.checkIsNeedResizeSources() ||\r\n        isLayerTypeChange ||\r\n        newNode.getData('resetRichText')\r\n      ) {\r\n        newNode.getSize()\r\n        newNode.needLayout = true\r\n      }\r\n    } else if (\r\n      (this.lru.has(uid) || this.renderer.lastNodeCache[uid]) &&\r\n      !this.renderer.reRender\r\n    ) {\r\n      // 节点数据上没有节点实例\r\n      // 但是通过uid在节点缓存池中找到了缓存的节点\r\n      // 或者在上一次渲染缓存对象中找到了节点\r\n      // 也可以直接复用\r\n      newNode = this.lru.get(uid) || this.renderer.lastNodeCache[uid]\r\n      // 保存该节点上一次的数据\r\n      const lastData = JSON.stringify(newNode.getData())\r\n      const isLayerTypeChange = this.checkIsLayerTypeChange(\r\n        newNode.layerIndex,\r\n        layerIndex\r\n      )\r\n      newNode.reset()\r\n      newNode.nodeData = newNode.handleData(data || {})\r\n      newNode.layerIndex = layerIndex\r\n      this.cacheNode(uid, newNode)\r\n      this.checkIsLayoutChangeRerenderExpandBtnPlaceholderRect(newNode)\r\n      data._node = newNode\r\n      // 主题或主题配置改变了需要重新计算节点大小和布局\r\n      const isResizeSource = this.checkIsNeedResizeSources()\r\n      // 主题或主题配置改变了、节点层级改变了，需要重新渲染节点文本，节点数据改变了等情况需要重新计算节点大小和布局\r\n      const isNodeDataChange = lastData !== JSON.stringify(data.data)\r\n      if (\r\n        isResizeSource ||\r\n        isNodeDataChange ||\r\n        isLayerTypeChange ||\r\n        newNode.getData('resetRichText')\r\n      ) {\r\n        newNode.getSize()\r\n        newNode.needLayout = true\r\n      }\r\n    } else {\r\n      // 创建新节点\r\n      const newUid = uid || createUid()\r\n      newNode = new Node({\r\n        data,\r\n        uid: newUid,\r\n        renderer: this.renderer,\r\n        mindMap: this.mindMap,\r\n        draw: this.draw,\r\n        layerIndex\r\n      })\r\n      // uid保存到数据上，为了节点复用\r\n      data.data.uid = newUid\r\n      this.cacheNode(newUid, newNode)\r\n      // 数据关联实际节点\r\n      data._node = newNode\r\n    }\r\n    // 如果该节点数据是已激活状态，那么添加到激活节点列表里\r\n    if (data.data.isActive) {\r\n      this.renderer.addNodeToActiveList(newNode)\r\n    }\r\n    // 如果当前节点在激活节点列表里，那么添加上激活的状态\r\n    if (this.mindMap.renderer.findActiveNodeIndex(newNode) !== -1) {\r\n      newNode.setData({\r\n        isActive: true\r\n      })\r\n    }\r\n    // 根节点\r\n    if (isRoot) {\r\n      newNode.isRoot = true\r\n      this.root = newNode\r\n    } else {\r\n      // 互相收集\r\n      newNode.parent = parent._node\r\n      parent._node.addChildren(newNode)\r\n    }\r\n    return newNode\r\n  }\r\n\r\n  // 格式化节点位置\r\n  formatPosition(value, size, nodeSize) {\r\n    if (typeof value === 'number') {\r\n      return value\r\n    } else if (initRootNodePositionMap[value] !== undefined) {\r\n      return size * initRootNodePositionMap[value]\r\n    } else if (/^\\d\\d*%$/.test(value)) {\r\n      return (Number.parseFloat(value) / 100) * size\r\n    } else {\r\n      return (size - nodeSize) / 2\r\n    }\r\n  }\r\n\r\n  // 规范initRootNodePosition配置\r\n  formatInitRootNodePosition(pos) {\r\n    const { CENTER } = CONSTANTS.INIT_ROOT_NODE_POSITION\r\n    if (!pos || !Array.isArray(pos) || pos.length < 2) {\r\n      pos = [CENTER, CENTER]\r\n    }\r\n    return pos\r\n  }\r\n\r\n  //  定位节点到画布中间\r\n  setNodeCenter(node, position) {\r\n    let { initRootNodePosition } = this.mindMap.opt\r\n    initRootNodePosition = this.formatInitRootNodePosition(\r\n      position || initRootNodePosition\r\n    )\r\n    node.left = this.formatPosition(\r\n      initRootNodePosition[0],\r\n      this.mindMap.width,\r\n      node.width\r\n    )\r\n    node.top = this.formatPosition(\r\n      initRootNodePosition[1],\r\n      this.mindMap.height,\r\n      node.height\r\n    )\r\n  }\r\n\r\n  // 当initRootNodePosition配置不为默认的['center','center']时，计算当前配置和默认配置情况下，根节点位置的差值\r\n  getRootCenterOffset(width, height) {\r\n    // 因为根节点的大小不会影响这个差值，所以计算一次就足够了\r\n    if (this.rootNodeCenterOffset) return this.rootNodeCenterOffset\r\n    let { initRootNodePosition } = this.mindMap.opt\r\n    const { CENTER } = CONSTANTS.INIT_ROOT_NODE_POSITION\r\n    initRootNodePosition = this.formatInitRootNodePosition(initRootNodePosition)\r\n    if (\r\n      initRootNodePosition[0] === CENTER &&\r\n      initRootNodePosition[1] === CENTER\r\n    ) {\r\n      // 如果initRootNodePosition是默认的，那么不需要计算\r\n      this.rootNodeCenterOffset = {\r\n        x: 0,\r\n        y: 0\r\n      }\r\n    } else {\r\n      // 否则需要计算当前配置和默认配置的差值\r\n      const tmpNode = {\r\n        width: width,\r\n        height: height\r\n      }\r\n      const tmpNode2 = {\r\n        width: width,\r\n        height: height\r\n      }\r\n      this.setNodeCenter(tmpNode, [CENTER, CENTER])\r\n      this.setNodeCenter(tmpNode2)\r\n      this.rootNodeCenterOffset = {\r\n        x: tmpNode2.left - tmpNode.left,\r\n        y: tmpNode2.top - tmpNode.top\r\n      }\r\n    }\r\n    return this.rootNodeCenterOffset\r\n  }\r\n\r\n  //  更新子节点属性\r\n  updateChildren(children, prop, offset) {\r\n    children.forEach(item => {\r\n      item[prop] += offset\r\n      if (item.children && item.children.length && !item.hasCustomPosition()) {\r\n        // 适配自定义位置\r\n        this.updateChildren(item.children, prop, offset)\r\n      }\r\n    })\r\n  }\r\n\r\n  //  更新子节点多个属性\r\n  updateChildrenPro(children, props) {\r\n    children.forEach(item => {\r\n      Object.keys(props).forEach(prop => {\r\n        item[prop] += props[prop]\r\n      })\r\n      if (item.children && item.children.length && !item.hasCustomPosition()) {\r\n        // 适配自定义位置\r\n        this.updateChildrenPro(item.children, props)\r\n      }\r\n    })\r\n  }\r\n\r\n  //  递归计算节点的宽度\r\n  getNodeAreaWidth(node, withGeneralization = false) {\r\n    let widthArr = []\r\n    let totalGeneralizationNodeWidth = 0\r\n    let loop = (node, width) => {\r\n      if (withGeneralization && node.checkHasGeneralization()) {\r\n        totalGeneralizationNodeWidth += node._generalizationNodeWidth\r\n      }\r\n      if (node.children.length) {\r\n        width += node.width / 2\r\n        node.children.forEach(item => {\r\n          loop(item, width)\r\n        })\r\n      } else {\r\n        width += node.width\r\n        widthArr.push(width)\r\n      }\r\n    }\r\n    loop(node, 0)\r\n    return Math.max(...widthArr) + totalGeneralizationNodeWidth\r\n  }\r\n\r\n  //  二次贝塞尔曲线\r\n  quadraticCurvePath(x1, y1, x2, y2) {\r\n    let cx = x1 + (x2 - x1) * 0.2\r\n    let cy = y1 + (y2 - y1) * 0.8\r\n    return `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`\r\n  }\r\n\r\n  //  三次贝塞尔曲线\r\n  cubicBezierPath(x1, y1, x2, y2) {\r\n    let cx1 = x1 + (x2 - x1) / 2\r\n    let cy1 = y1\r\n    let cx2 = cx1\r\n    let cy2 = y2\r\n    return `M ${x1},${y1} C ${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`\r\n  }\r\n\r\n  // 根据a,b两个点的位置，计算去除圆角大小后的新的b点\r\n  computeNewPoint(a, b, radius = 0) {\r\n    // x坐标相同\r\n    if (a[0] === b[0]) {\r\n      // b在a下方\r\n      if (b[1] > a[1]) {\r\n        return [b[0], b[1] - radius]\r\n      } else {\r\n        // b在a上方\r\n        return [b[0], b[1] + radius]\r\n      }\r\n    } else if (a[1] === b[1]) {\r\n      // y坐标相同\r\n      // b在a右边\r\n      if (b[0] > a[0]) {\r\n        return [b[0] - radius, b[1]]\r\n      } else {\r\n        return [b[0] + radius, b[1]]\r\n      }\r\n    }\r\n  }\r\n\r\n  // 创建一段折线路径\r\n  // 最后一个拐角支持圆角\r\n  createFoldLine(list) {\r\n    const { lineRadius } = this.mindMap.themeConfig\r\n    const len = list.length\r\n    let path = ''\r\n    let radiusPath = ''\r\n    if (len >= 3 && lineRadius > 0) {\r\n      const start = list[len - 3]\r\n      const center = list[len - 2]\r\n      const end = list[len - 1]\r\n      // 如果三点在一条直线，那么不用处理\r\n      const isOneLine =\r\n        (start[0] === center[0] && center[0] === end[0]) ||\r\n        (start[1] === center[1] && center[1] === end[1])\r\n      if (!isOneLine) {\r\n        const cStart = this.computeNewPoint(start, center, lineRadius)\r\n        const cEnd = this.computeNewPoint(end, center, lineRadius)\r\n        radiusPath = `Q ${center[0]},${center[1]} ${cEnd[0]},${cEnd[1]}`\r\n        list.splice(len - 2, 1, cStart, radiusPath)\r\n      }\r\n    }\r\n    list.forEach((item, index) => {\r\n      if (typeof item === 'string') {\r\n        path += item\r\n      } else {\r\n        const [x, y] = item\r\n        if (index === 0) {\r\n          path += `M ${x},${y}`\r\n        } else {\r\n          path += `L ${x},${y}`\r\n        }\r\n      }\r\n    })\r\n    return path\r\n  }\r\n\r\n  //   获取节点的marginX\r\n  getMarginX(layerIndex) {\r\n    const { themeConfig, opt } = this.mindMap\r\n    const { second, node } = themeConfig\r\n    const hoverRectPadding = opt.hoverRectPadding * 2\r\n    return layerIndex === 1\r\n      ? second.marginX + hoverRectPadding\r\n      : node.marginX + hoverRectPadding\r\n  }\r\n\r\n  //  获取节点的marginY\r\n  getMarginY(layerIndex) {\r\n    const { themeConfig, opt } = this.mindMap\r\n    const { second, node } = themeConfig\r\n    const hoverRectPadding = opt.hoverRectPadding * 2\r\n    return layerIndex === 1\r\n      ? second.marginY + hoverRectPadding\r\n      : node.marginY + hoverRectPadding\r\n  }\r\n\r\n  //  获取节点包括概要在内的宽度\r\n  getNodeWidthWithGeneralization(node) {\r\n    return Math.max(\r\n      node.width,\r\n      node.checkHasGeneralization() ? node._generalizationNodeWidth : 0\r\n    )\r\n  }\r\n\r\n  //  获取节点包括概要在内的高度\r\n  getNodeHeightWithGeneralization(node) {\r\n    return Math.max(\r\n      node.height,\r\n      node.checkHasGeneralization() ? node._generalizationNodeHeight : 0\r\n    )\r\n  }\r\n\r\n  //  获取节点的边界值\r\n  /**\r\n   * dir：生长方向，h（水平）、v（垂直）\r\n   * isLeft：是否向左生长\r\n   */\r\n  getNodeBoundaries(node, dir) {\r\n    let { generalizationLineMargin, generalizationNodeMargin } =\r\n      this.mindMap.themeConfig\r\n    let walk = root => {\r\n      let _left = Infinity\r\n      let _right = -Infinity\r\n      let _top = Infinity\r\n      let _bottom = -Infinity\r\n      if (root.children && root.children.length > 0) {\r\n        root.children.forEach(child => {\r\n          let { left, right, top, bottom } = walk(child)\r\n          // 概要内容的宽度\r\n          let generalizationWidth =\r\n            child.checkHasGeneralization() && child.getData('expand')\r\n              ? child._generalizationNodeWidth + generalizationNodeMargin\r\n              : 0\r\n          // 概要内容的高度\r\n          let generalizationHeight =\r\n            child.checkHasGeneralization() && child.getData('expand')\r\n              ? child._generalizationNodeHeight + generalizationNodeMargin\r\n              : 0\r\n          if (left - (dir === 'h' ? generalizationWidth : 0) < _left) {\r\n            _left = left - (dir === 'h' ? generalizationWidth : 0)\r\n          }\r\n          if (right + (dir === 'h' ? generalizationWidth : 0) > _right) {\r\n            _right = right + (dir === 'h' ? generalizationWidth : 0)\r\n          }\r\n          if (top < _top) {\r\n            _top = top\r\n          }\r\n          if (bottom + (dir === 'v' ? generalizationHeight : 0) > _bottom) {\r\n            _bottom = bottom + (dir === 'v' ? generalizationHeight : 0)\r\n          }\r\n        })\r\n      }\r\n      let cur = {\r\n        left: root.left,\r\n        right: root.left + root.width,\r\n        top: root.top,\r\n        bottom: root.top + root.height\r\n      }\r\n      return {\r\n        left: cur.left < _left ? cur.left : _left,\r\n        right: cur.right > _right ? cur.right : _right,\r\n        top: cur.top < _top ? cur.top : _top,\r\n        bottom: cur.bottom > _bottom ? cur.bottom : _bottom\r\n      }\r\n    }\r\n    let { left, right, top, bottom } = walk(node)\r\n    return {\r\n      left,\r\n      right,\r\n      top,\r\n      bottom,\r\n      generalizationLineMargin,\r\n      generalizationNodeMargin\r\n    }\r\n  }\r\n\r\n  // 获取指定索引区间的子节点的边界范围\r\n  getChildrenBoundaries(node, dir, startIndex = 0, endIndex) {\r\n    let { generalizationLineMargin, generalizationNodeMargin } =\r\n      this.mindMap.themeConfig\r\n    const children = node.children.slice(startIndex, endIndex + 1)\r\n    let left = Infinity\r\n    let right = -Infinity\r\n    let top = Infinity\r\n    let bottom = -Infinity\r\n    children.forEach(item => {\r\n      const cur = this.getNodeBoundaries(item, dir)\r\n      left = cur.left < left ? cur.left : left\r\n      right = cur.right > right ? cur.right : right\r\n      top = cur.top < top ? cur.top : top\r\n      bottom = cur.bottom > bottom ? cur.bottom : bottom\r\n    })\r\n    return {\r\n      left,\r\n      right,\r\n      top,\r\n      bottom,\r\n      generalizationLineMargin,\r\n      generalizationNodeMargin\r\n    }\r\n  }\r\n\r\n  // 获取节点概要的渲染边界\r\n  getNodeGeneralizationRenderBoundaries(item, dir) {\r\n    let res = null\r\n    // 区间\r\n    if (item.range) {\r\n      res = this.getChildrenBoundaries(\r\n        item.node,\r\n        dir,\r\n        item.range[0],\r\n        item.range[1]\r\n      )\r\n    } else {\r\n      // 整体概要\r\n      res = this.getNodeBoundaries(item.node, dir)\r\n    }\r\n    return res\r\n  }\r\n\r\n  // 获取节点实际存在几个子节点\r\n  getNodeActChildrenLength(node) {\r\n    return node.nodeData.children && node.nodeData.children.length\r\n  }\r\n\r\n  // 设置连线样式\r\n  setLineStyle(style, line, path, childNode) {\r\n    line.plot(this.transformPath(path))\r\n    style && style(line, childNode, true)\r\n  }\r\n\r\n  // 转换路径，可以转换成特殊风格的线条样式\r\n  transformPath(path) {\r\n    const { customTransformNodeLinePath } = this.mindMap.opt\r\n    if (customTransformNodeLinePath) {\r\n      return customTransformNodeLinePath(path)\r\n    } else {\r\n      return path\r\n    }\r\n  }\r\n}\r\n\r\nexport default Base\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}