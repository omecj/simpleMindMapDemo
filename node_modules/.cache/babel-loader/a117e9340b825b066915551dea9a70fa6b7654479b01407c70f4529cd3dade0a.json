{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\n// Map function\nexport function map(array, block) {\n  let i;\n  const il = array.length;\n  const result = [];\n  for (i = 0; i < il; i++) {\n    result.push(block(array[i]));\n  }\n  return result;\n}\n\n// Filter function\nexport function filter(array, block) {\n  let i;\n  const il = array.length;\n  const result = [];\n  for (i = 0; i < il; i++) {\n    if (block(array[i])) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n}\n\n// Degrees to radians\nexport function radians(d) {\n  return d % 360 * Math.PI / 180;\n}\n\n// Radians to degrees\nexport function degrees(r) {\n  return r * 180 / Math.PI % 360;\n}\n\n// Convert camel cased string to dash separated\nexport function unCamelCase(s) {\n  return s.replace(/([A-Z])/g, function (m, g) {\n    return '-' + g.toLowerCase();\n  });\n}\n\n// Capitalize first letter of a string\nexport function capitalize(s) {\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\n// Calculate proportional width and height values when necessary\nexport function proportionalSize(element, width, height, box) {\n  if (width == null || height == null) {\n    box = box || element.bbox();\n    if (width == null) {\n      width = box.width / box.height * height;\n    } else if (height == null) {\n      height = box.height / box.width * width;\n    }\n  }\n  return {\n    width: width,\n    height: height\n  };\n}\n\n/**\n * This function adds support for string origins.\n * It searches for an origin in o.origin o.ox and o.originX.\n * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50\n **/\nexport function getOrigin(o, element) {\n  const origin = o.origin;\n  // First check if origin is in ox or originX\n  let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center';\n  let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center';\n\n  // Then check if origin was used and overwrite in that case\n  if (origin != null) {\n    ;\n    [ox, oy] = Array.isArray(origin) ? origin : typeof origin === 'object' ? [origin.x, origin.y] : [origin, origin];\n  }\n\n  // Make sure to only call bbox when actually needed\n  const condX = typeof ox === 'string';\n  const condY = typeof oy === 'string';\n  if (condX || condY) {\n    const {\n      height,\n      width,\n      x,\n      y\n    } = element.bbox();\n\n    // And only overwrite if string was passed for this specific axis\n    if (condX) {\n      ox = ox.includes('left') ? x : ox.includes('right') ? x + width : x + width / 2;\n    }\n    if (condY) {\n      oy = oy.includes('top') ? y : oy.includes('bottom') ? y + height : y + height / 2;\n    }\n  }\n\n  // Return the origin as it is if it wasn't a string\n  return [ox, oy];\n}\nconst descriptiveElements = new Set(['desc', 'metadata', 'title']);\nexport const isDescriptive = element => descriptiveElements.has(element.nodeName);\nexport const writeDataToDom = (element, data, defaults = {}) => {\n  const cloned = {\n    ...data\n  };\n  for (const key in cloned) {\n    if (cloned[key].valueOf() === defaults[key]) {\n      delete cloned[key];\n    }\n  }\n  if (Object.keys(cloned).length) {\n    element.node.setAttribute('data-svgjs', JSON.stringify(cloned)); // see #428\n  } else {\n    element.node.removeAttribute('data-svgjs');\n    element.node.removeAttribute('svgjs:data');\n  }\n};","map":{"version":3,"names":["map","array","block","i","il","length","result","push","filter","radians","d","Math","PI","degrees","r","unCamelCase","s","replace","m","g","toLowerCase","capitalize","charAt","toUpperCase","slice","proportionalSize","element","width","height","box","bbox","getOrigin","o","origin","ox","originX","oy","originY","Array","isArray","x","y","condX","condY","includes","descriptiveElements","Set","isDescriptive","has","nodeName","writeDataToDom","data","defaults","cloned","key","valueOf","Object","keys","node","setAttribute","JSON","stringify","removeAttribute"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/@svgdotjs/svg.js/src/utils/utils.js"],"sourcesContent":["// Map function\nexport function map(array, block) {\n  let i\n  const il = array.length\n  const result = []\n\n  for (i = 0; i < il; i++) {\n    result.push(block(array[i]))\n  }\n\n  return result\n}\n\n// Filter function\nexport function filter(array, block) {\n  let i\n  const il = array.length\n  const result = []\n\n  for (i = 0; i < il; i++) {\n    if (block(array[i])) {\n      result.push(array[i])\n    }\n  }\n\n  return result\n}\n\n// Degrees to radians\nexport function radians(d) {\n  return ((d % 360) * Math.PI) / 180\n}\n\n// Radians to degrees\nexport function degrees(r) {\n  return ((r * 180) / Math.PI) % 360\n}\n\n// Convert camel cased string to dash separated\nexport function unCamelCase(s) {\n  return s.replace(/([A-Z])/g, function (m, g) {\n    return '-' + g.toLowerCase()\n  })\n}\n\n// Capitalize first letter of a string\nexport function capitalize(s) {\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\n// Calculate proportional width and height values when necessary\nexport function proportionalSize(element, width, height, box) {\n  if (width == null || height == null) {\n    box = box || element.bbox()\n\n    if (width == null) {\n      width = (box.width / box.height) * height\n    } else if (height == null) {\n      height = (box.height / box.width) * width\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  }\n}\n\n/**\n * This function adds support for string origins.\n * It searches for an origin in o.origin o.ox and o.originX.\n * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50\n **/\nexport function getOrigin(o, element) {\n  const origin = o.origin\n  // First check if origin is in ox or originX\n  let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center'\n  let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center'\n\n  // Then check if origin was used and overwrite in that case\n  if (origin != null) {\n    ;[ox, oy] = Array.isArray(origin)\n      ? origin\n      : typeof origin === 'object'\n        ? [origin.x, origin.y]\n        : [origin, origin]\n  }\n\n  // Make sure to only call bbox when actually needed\n  const condX = typeof ox === 'string'\n  const condY = typeof oy === 'string'\n  if (condX || condY) {\n    const { height, width, x, y } = element.bbox()\n\n    // And only overwrite if string was passed for this specific axis\n    if (condX) {\n      ox = ox.includes('left')\n        ? x\n        : ox.includes('right')\n          ? x + width\n          : x + width / 2\n    }\n\n    if (condY) {\n      oy = oy.includes('top')\n        ? y\n        : oy.includes('bottom')\n          ? y + height\n          : y + height / 2\n    }\n  }\n\n  // Return the origin as it is if it wasn't a string\n  return [ox, oy]\n}\n\nconst descriptiveElements = new Set(['desc', 'metadata', 'title'])\nexport const isDescriptive = (element) =>\n  descriptiveElements.has(element.nodeName)\n\nexport const writeDataToDom = (element, data, defaults = {}) => {\n  const cloned = { ...data }\n\n  for (const key in cloned) {\n    if (cloned[key].valueOf() === defaults[key]) {\n      delete cloned[key]\n    }\n  }\n\n  if (Object.keys(cloned).length) {\n    element.node.setAttribute('data-svgjs', JSON.stringify(cloned)) // see #428\n  } else {\n    element.node.removeAttribute('data-svgjs')\n    element.node.removeAttribute('svgjs:data')\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}