{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Ease } from './Controller.js';\nimport { delimiter, numberAndUnit, isPathLetter } from '../modules/core/regex.js';\nimport { extend } from '../utils/adopter.js';\nimport Color from '../types/Color.js';\nimport PathArray from '../types/PathArray.js';\nimport SVGArray from '../types/SVGArray.js';\nimport SVGNumber from '../types/SVGNumber.js';\nconst getClassForType = value => {\n  const type = typeof value;\n  if (type === 'number') {\n    return SVGNumber;\n  } else if (type === 'string') {\n    if (Color.isColor(value)) {\n      return Color;\n    } else if (delimiter.test(value)) {\n      return isPathLetter.test(value) ? PathArray : SVGArray;\n    } else if (numberAndUnit.test(value)) {\n      return SVGNumber;\n    } else {\n      return NonMorphable;\n    }\n  } else if (morphableTypes.indexOf(value.constructor) > -1) {\n    return value.constructor;\n  } else if (Array.isArray(value)) {\n    return SVGArray;\n  } else if (type === 'object') {\n    return ObjectBag;\n  } else {\n    return NonMorphable;\n  }\n};\nexport default class Morphable {\n  constructor(stepper) {\n    this._stepper = stepper || new Ease('-');\n    this._from = null;\n    this._to = null;\n    this._type = null;\n    this._context = null;\n    this._morphObj = null;\n  }\n  at(pos) {\n    return this._morphObj.morph(this._from, this._to, pos, this._stepper, this._context);\n  }\n  done() {\n    const complete = this._context.map(this._stepper.done).reduce(function (last, curr) {\n      return last && curr;\n    }, true);\n    return complete;\n  }\n  from(val) {\n    if (val == null) {\n      return this._from;\n    }\n    this._from = this._set(val);\n    return this;\n  }\n  stepper(stepper) {\n    if (stepper == null) return this._stepper;\n    this._stepper = stepper;\n    return this;\n  }\n  to(val) {\n    if (val == null) {\n      return this._to;\n    }\n    this._to = this._set(val);\n    return this;\n  }\n  type(type) {\n    // getter\n    if (type == null) {\n      return this._type;\n    }\n\n    // setter\n    this._type = type;\n    return this;\n  }\n  _set(value) {\n    if (!this._type) {\n      this.type(getClassForType(value));\n    }\n    let result = new this._type(value);\n    if (this._type === Color) {\n      result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;\n    }\n    if (this._type === ObjectBag) {\n      result = this._to ? result.align(this._to) : this._from ? result.align(this._from) : result;\n    }\n    result = result.toConsumable();\n    this._morphObj = this._morphObj || new this._type();\n    this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function (o) {\n      o.done = true;\n      return o;\n    });\n    return result;\n  }\n}\nexport class NonMorphable {\n  constructor(...args) {\n    this.init(...args);\n  }\n  init(val) {\n    val = Array.isArray(val) ? val[0] : val;\n    this.value = val;\n    return this;\n  }\n  toArray() {\n    return [this.value];\n  }\n  valueOf() {\n    return this.value;\n  }\n}\nexport class TransformBag {\n  constructor(...args) {\n    this.init(...args);\n  }\n  init(obj) {\n    if (Array.isArray(obj)) {\n      obj = {\n        scaleX: obj[0],\n        scaleY: obj[1],\n        shear: obj[2],\n        rotate: obj[3],\n        translateX: obj[4],\n        translateY: obj[5],\n        originX: obj[6],\n        originY: obj[7]\n      };\n    }\n    Object.assign(this, TransformBag.defaults, obj);\n    return this;\n  }\n  toArray() {\n    const v = this;\n    return [v.scaleX, v.scaleY, v.shear, v.rotate, v.translateX, v.translateY, v.originX, v.originY];\n  }\n}\nTransformBag.defaults = {\n  scaleX: 1,\n  scaleY: 1,\n  shear: 0,\n  rotate: 0,\n  translateX: 0,\n  translateY: 0,\n  originX: 0,\n  originY: 0\n};\nconst sortByKey = (a, b) => {\n  return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0;\n};\nexport class ObjectBag {\n  constructor(...args) {\n    this.init(...args);\n  }\n  align(other) {\n    const values = this.values;\n    for (let i = 0, il = values.length; i < il; ++i) {\n      // If the type is the same we only need to check if the color is in the correct format\n      if (values[i + 1] === other[i + 1]) {\n        if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {\n          const space = other[i + 7];\n          const color = new Color(this.values.splice(i + 3, 5))[space]().toArray();\n          this.values.splice(i + 3, 0, ...color);\n        }\n        i += values[i + 2] + 2;\n        continue;\n      }\n      if (!other[i + 1]) {\n        return this;\n      }\n\n      // The types differ, so we overwrite the new type with the old one\n      // And initialize it with the types default (e.g. black for color or 0 for number)\n      const defaultObject = new other[i + 1]().toArray();\n\n      // Than we fix the values array\n      const toDelete = values[i + 2] + 3;\n      values.splice(i, toDelete, other[i], other[i + 1], other[i + 2], ...defaultObject);\n      i += values[i + 2] + 2;\n    }\n    return this;\n  }\n  init(objOrArr) {\n    this.values = [];\n    if (Array.isArray(objOrArr)) {\n      this.values = objOrArr.slice();\n      return;\n    }\n    objOrArr = objOrArr || {};\n    const entries = [];\n    for (const i in objOrArr) {\n      const Type = getClassForType(objOrArr[i]);\n      const val = new Type(objOrArr[i]).toArray();\n      entries.push([i, Type, val.length, ...val]);\n    }\n    entries.sort(sortByKey);\n    this.values = entries.reduce((last, curr) => last.concat(curr), []);\n    return this;\n  }\n  toArray() {\n    return this.values;\n  }\n  valueOf() {\n    const obj = {};\n    const arr = this.values;\n\n    // for (var i = 0, len = arr.length; i < len; i += 2) {\n    while (arr.length) {\n      const key = arr.shift();\n      const Type = arr.shift();\n      const num = arr.shift();\n      const values = arr.splice(0, num);\n      obj[key] = new Type(values); // .valueOf()\n    }\n    return obj;\n  }\n}\nconst morphableTypes = [NonMorphable, TransformBag, ObjectBag];\nexport function registerMorphableType(type = []) {\n  morphableTypes.push(...[].concat(type));\n}\nexport function makeMorphable() {\n  extend(morphableTypes, {\n    to(val) {\n      return new Morphable().type(this.constructor).from(this.toArray()) // this.valueOf())\n      .to(val);\n    },\n    fromArray(arr) {\n      this.init(arr);\n      return this;\n    },\n    toConsumable() {\n      return this.toArray();\n    },\n    morph(from, to, pos, stepper, context) {\n      const mapper = function (i, index) {\n        return stepper.step(i, to[index], pos, context[index], context);\n      };\n      return this.fromArray(from.map(mapper));\n    }\n  });\n}","map":{"version":3,"names":["Ease","delimiter","numberAndUnit","isPathLetter","extend","Color","PathArray","SVGArray","SVGNumber","getClassForType","value","type","isColor","test","NonMorphable","morphableTypes","indexOf","constructor","Array","isArray","ObjectBag","Morphable","stepper","_stepper","_from","_to","_type","_context","_morphObj","at","pos","morph","done","complete","map","reduce","last","curr","from","val","_set","to","result","align","toConsumable","apply","length","Object","o","args","init","toArray","valueOf","TransformBag","obj","scaleX","scaleY","shear","rotate","translateX","translateY","originX","originY","assign","defaults","v","sortByKey","a","b","other","values","i","il","space","color","splice","defaultObject","toDelete","objOrArr","slice","entries","Type","push","sort","concat","arr","key","shift","num","registerMorphableType","makeMorphable","fromArray","context","mapper","index","step"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/@svgdotjs/svg.js/src/animation/Morphable.js"],"sourcesContent":["import { Ease } from './Controller.js'\nimport {\n  delimiter,\n  numberAndUnit,\n  isPathLetter\n} from '../modules/core/regex.js'\nimport { extend } from '../utils/adopter.js'\nimport Color from '../types/Color.js'\nimport PathArray from '../types/PathArray.js'\nimport SVGArray from '../types/SVGArray.js'\nimport SVGNumber from '../types/SVGNumber.js'\n\nconst getClassForType = (value) => {\n  const type = typeof value\n\n  if (type === 'number') {\n    return SVGNumber\n  } else if (type === 'string') {\n    if (Color.isColor(value)) {\n      return Color\n    } else if (delimiter.test(value)) {\n      return isPathLetter.test(value) ? PathArray : SVGArray\n    } else if (numberAndUnit.test(value)) {\n      return SVGNumber\n    } else {\n      return NonMorphable\n    }\n  } else if (morphableTypes.indexOf(value.constructor) > -1) {\n    return value.constructor\n  } else if (Array.isArray(value)) {\n    return SVGArray\n  } else if (type === 'object') {\n    return ObjectBag\n  } else {\n    return NonMorphable\n  }\n}\n\nexport default class Morphable {\n  constructor(stepper) {\n    this._stepper = stepper || new Ease('-')\n\n    this._from = null\n    this._to = null\n    this._type = null\n    this._context = null\n    this._morphObj = null\n  }\n\n  at(pos) {\n    return this._morphObj.morph(\n      this._from,\n      this._to,\n      pos,\n      this._stepper,\n      this._context\n    )\n  }\n\n  done() {\n    const complete = this._context.map(this._stepper.done).reduce(function (\n      last,\n      curr\n    ) {\n      return last && curr\n    }, true)\n    return complete\n  }\n\n  from(val) {\n    if (val == null) {\n      return this._from\n    }\n\n    this._from = this._set(val)\n    return this\n  }\n\n  stepper(stepper) {\n    if (stepper == null) return this._stepper\n    this._stepper = stepper\n    return this\n  }\n\n  to(val) {\n    if (val == null) {\n      return this._to\n    }\n\n    this._to = this._set(val)\n    return this\n  }\n\n  type(type) {\n    // getter\n    if (type == null) {\n      return this._type\n    }\n\n    // setter\n    this._type = type\n    return this\n  }\n\n  _set(value) {\n    if (!this._type) {\n      this.type(getClassForType(value))\n    }\n\n    let result = new this._type(value)\n    if (this._type === Color) {\n      result = this._to\n        ? result[this._to[4]]()\n        : this._from\n          ? result[this._from[4]]()\n          : result\n    }\n\n    if (this._type === ObjectBag) {\n      result = this._to\n        ? result.align(this._to)\n        : this._from\n          ? result.align(this._from)\n          : result\n    }\n\n    result = result.toConsumable()\n\n    this._morphObj = this._morphObj || new this._type()\n    this._context =\n      this._context ||\n      Array.apply(null, Array(result.length))\n        .map(Object)\n        .map(function (o) {\n          o.done = true\n          return o\n        })\n    return result\n  }\n}\n\nexport class NonMorphable {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  init(val) {\n    val = Array.isArray(val) ? val[0] : val\n    this.value = val\n    return this\n  }\n\n  toArray() {\n    return [this.value]\n  }\n\n  valueOf() {\n    return this.value\n  }\n}\n\nexport class TransformBag {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  init(obj) {\n    if (Array.isArray(obj)) {\n      obj = {\n        scaleX: obj[0],\n        scaleY: obj[1],\n        shear: obj[2],\n        rotate: obj[3],\n        translateX: obj[4],\n        translateY: obj[5],\n        originX: obj[6],\n        originY: obj[7]\n      }\n    }\n\n    Object.assign(this, TransformBag.defaults, obj)\n    return this\n  }\n\n  toArray() {\n    const v = this\n\n    return [\n      v.scaleX,\n      v.scaleY,\n      v.shear,\n      v.rotate,\n      v.translateX,\n      v.translateY,\n      v.originX,\n      v.originY\n    ]\n  }\n}\n\nTransformBag.defaults = {\n  scaleX: 1,\n  scaleY: 1,\n  shear: 0,\n  rotate: 0,\n  translateX: 0,\n  translateY: 0,\n  originX: 0,\n  originY: 0\n}\n\nconst sortByKey = (a, b) => {\n  return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0\n}\n\nexport class ObjectBag {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  align(other) {\n    const values = this.values\n    for (let i = 0, il = values.length; i < il; ++i) {\n      // If the type is the same we only need to check if the color is in the correct format\n      if (values[i + 1] === other[i + 1]) {\n        if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {\n          const space = other[i + 7]\n          const color = new Color(this.values.splice(i + 3, 5))\n            [space]()\n            .toArray()\n          this.values.splice(i + 3, 0, ...color)\n        }\n\n        i += values[i + 2] + 2\n        continue\n      }\n\n      if (!other[i + 1]) {\n        return this\n      }\n\n      // The types differ, so we overwrite the new type with the old one\n      // And initialize it with the types default (e.g. black for color or 0 for number)\n      const defaultObject = new other[i + 1]().toArray()\n\n      // Than we fix the values array\n      const toDelete = values[i + 2] + 3\n\n      values.splice(\n        i,\n        toDelete,\n        other[i],\n        other[i + 1],\n        other[i + 2],\n        ...defaultObject\n      )\n\n      i += values[i + 2] + 2\n    }\n    return this\n  }\n\n  init(objOrArr) {\n    this.values = []\n\n    if (Array.isArray(objOrArr)) {\n      this.values = objOrArr.slice()\n      return\n    }\n\n    objOrArr = objOrArr || {}\n    const entries = []\n\n    for (const i in objOrArr) {\n      const Type = getClassForType(objOrArr[i])\n      const val = new Type(objOrArr[i]).toArray()\n      entries.push([i, Type, val.length, ...val])\n    }\n\n    entries.sort(sortByKey)\n\n    this.values = entries.reduce((last, curr) => last.concat(curr), [])\n    return this\n  }\n\n  toArray() {\n    return this.values\n  }\n\n  valueOf() {\n    const obj = {}\n    const arr = this.values\n\n    // for (var i = 0, len = arr.length; i < len; i += 2) {\n    while (arr.length) {\n      const key = arr.shift()\n      const Type = arr.shift()\n      const num = arr.shift()\n      const values = arr.splice(0, num)\n      obj[key] = new Type(values) // .valueOf()\n    }\n\n    return obj\n  }\n}\n\nconst morphableTypes = [NonMorphable, TransformBag, ObjectBag]\n\nexport function registerMorphableType(type = []) {\n  morphableTypes.push(...[].concat(type))\n}\n\nexport function makeMorphable() {\n  extend(morphableTypes, {\n    to(val) {\n      return new Morphable()\n        .type(this.constructor)\n        .from(this.toArray()) // this.valueOf())\n        .to(val)\n    },\n    fromArray(arr) {\n      this.init(arr)\n      return this\n    },\n    toConsumable() {\n      return this.toArray()\n    },\n    morph(from, to, pos, stepper, context) {\n      const mapper = function (i, index) {\n        return stepper.step(i, to[index], pos, context[index], context)\n      }\n\n      return this.fromArray(from.map(mapper))\n    }\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}