{"ast":null,"code":"import { getOrigin, isDescriptive } from '../../utils/utils.js';\nimport { delimiter, transforms } from '../core/regex.js';\nimport { registerMethods } from '../../utils/methods.js';\nimport Matrix from '../../types/Matrix.js';\n\n// Reset all transformations\nexport function untransform() {\n  return this.attr('transform', null);\n}\n\n// merge the whole transformation chain into one matrix and returns it\nexport function matrixify() {\n  const matrix = (this.attr('transform') || ''\n  // split transformations\n  ).split(transforms).slice(0, -1).map(function (str) {\n    // generate key => value pairs\n    const kv = str.trim().split('(');\n    return [kv[0], kv[1].split(delimiter).map(function (str) {\n      return parseFloat(str);\n    })];\n  }).reverse()\n  // merge every transformation into one matrix\n  .reduce(function (matrix, transform) {\n    if (transform[0] === 'matrix') {\n      return matrix.lmultiply(Matrix.fromArray(transform[1]));\n    }\n    return matrix[transform[0]].apply(matrix, transform[1]);\n  }, new Matrix());\n  return matrix;\n}\n\n// add an element to another parent without changing the visual representation on the screen\nexport function toParent(parent, i) {\n  if (this === parent) return this;\n  if (isDescriptive(this.node)) return this.addTo(parent, i);\n  const ctm = this.screenCTM();\n  const pCtm = parent.screenCTM().inverse();\n  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm));\n  return this;\n}\n\n// same as above with parent equals root-svg\nexport function toRoot(i) {\n  return this.toParent(this.root(), i);\n}\n\n// Add transformations\nexport function transform(o, relative) {\n  // Act as a getter if no object was passed\n  if (o == null || typeof o === 'string') {\n    const decomposed = new Matrix(this).decompose();\n    return o == null ? decomposed : decomposed[o];\n  }\n  if (!Matrix.isMatrixLike(o)) {\n    // Set the origin according to the defined transform\n    o = {\n      ...o,\n      origin: getOrigin(o, this)\n    };\n  }\n\n  // The user can pass a boolean, an Element or an Matrix or nothing\n  const cleanRelative = relative === true ? this : relative || false;\n  const result = new Matrix(cleanRelative).transform(o);\n  return this.attr('transform', result);\n}\nregisterMethods('Element', {\n  untransform,\n  matrixify,\n  toParent,\n  toRoot,\n  transform\n});","map":{"version":3,"names":["getOrigin","isDescriptive","delimiter","transforms","registerMethods","Matrix","untransform","attr","matrixify","matrix","split","slice","map","str","kv","trim","parseFloat","reverse","reduce","transform","lmultiply","fromArray","apply","toParent","parent","i","node","addTo","ctm","screenCTM","pCtm","inverse","multiply","toRoot","root","o","relative","decomposed","decompose","isMatrixLike","origin","cleanRelative","result"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/@svgdotjs/svg.js/src/modules/optional/transform.js"],"sourcesContent":["import { getOrigin, isDescriptive } from '../../utils/utils.js'\nimport { delimiter, transforms } from '../core/regex.js'\nimport { registerMethods } from '../../utils/methods.js'\nimport Matrix from '../../types/Matrix.js'\n\n// Reset all transformations\nexport function untransform() {\n  return this.attr('transform', null)\n}\n\n// merge the whole transformation chain into one matrix and returns it\nexport function matrixify() {\n  const matrix = (this.attr('transform') || '')\n    // split transformations\n    .split(transforms)\n    .slice(0, -1)\n    .map(function (str) {\n      // generate key => value pairs\n      const kv = str.trim().split('(')\n      return [\n        kv[0],\n        kv[1].split(delimiter).map(function (str) {\n          return parseFloat(str)\n        })\n      ]\n    })\n    .reverse()\n    // merge every transformation into one matrix\n    .reduce(function (matrix, transform) {\n      if (transform[0] === 'matrix') {\n        return matrix.lmultiply(Matrix.fromArray(transform[1]))\n      }\n      return matrix[transform[0]].apply(matrix, transform[1])\n    }, new Matrix())\n\n  return matrix\n}\n\n// add an element to another parent without changing the visual representation on the screen\nexport function toParent(parent, i) {\n  if (this === parent) return this\n\n  if (isDescriptive(this.node)) return this.addTo(parent, i)\n\n  const ctm = this.screenCTM()\n  const pCtm = parent.screenCTM().inverse()\n\n  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm))\n\n  return this\n}\n\n// same as above with parent equals root-svg\nexport function toRoot(i) {\n  return this.toParent(this.root(), i)\n}\n\n// Add transformations\nexport function transform(o, relative) {\n  // Act as a getter if no object was passed\n  if (o == null || typeof o === 'string') {\n    const decomposed = new Matrix(this).decompose()\n    return o == null ? decomposed : decomposed[o]\n  }\n\n  if (!Matrix.isMatrixLike(o)) {\n    // Set the origin according to the defined transform\n    o = { ...o, origin: getOrigin(o, this) }\n  }\n\n  // The user can pass a boolean, an Element or an Matrix or nothing\n  const cleanRelative = relative === true ? this : relative || false\n  const result = new Matrix(cleanRelative).transform(o)\n  return this.attr('transform', result)\n}\n\nregisterMethods('Element', {\n  untransform,\n  matrixify,\n  toParent,\n  toRoot,\n  transform\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}