{"ast":null,"code":"import { adopt, assignNewId, eid, extend, makeInstance, create, register } from '../utils/adopter.js';\nimport { find, findOne } from '../modules/core/selector.js';\nimport { globals } from '../utils/window.js';\nimport { map } from '../utils/utils.js';\nimport { svg, html } from '../modules/core/namespaces.js';\nimport EventTarget from '../types/EventTarget.js';\nimport List from '../types/List.js';\nimport attr from '../modules/core/attr.js';\nexport default class Dom extends EventTarget {\n  constructor(node, attrs) {\n    super();\n    this.node = node;\n    this.type = node.nodeName;\n    if (attrs && node !== attrs) {\n      this.attr(attrs);\n    }\n  }\n\n  // Add given element at a position\n  add(element, i) {\n    element = makeInstance(element);\n\n    // If non-root svg nodes are added we have to remove their namespaces\n    if (element.removeNamespace && this.node instanceof globals.window.SVGElement) {\n      element.removeNamespace();\n    }\n    if (i == null) {\n      this.node.appendChild(element.node);\n    } else if (element.node !== this.node.childNodes[i]) {\n      this.node.insertBefore(element.node, this.node.childNodes[i]);\n    }\n    return this;\n  }\n\n  // Add element to given container and return self\n  addTo(parent, i) {\n    return makeInstance(parent).put(this, i);\n  }\n\n  // Returns all child elements\n  children() {\n    return new List(map(this.node.children, function (node) {\n      return adopt(node);\n    }));\n  }\n\n  // Remove all elements in this container\n  clear() {\n    // remove children\n    while (this.node.hasChildNodes()) {\n      this.node.removeChild(this.node.lastChild);\n    }\n    return this;\n  }\n\n  // Clone element\n  clone(deep = true, assignNewIds = true) {\n    // write dom data to the dom so the clone can pickup the data\n    this.writeDataToDom();\n\n    // clone element\n    let nodeClone = this.node.cloneNode(deep);\n    if (assignNewIds) {\n      // assign new id\n      nodeClone = assignNewId(nodeClone);\n    }\n    return new this.constructor(nodeClone);\n  }\n\n  // Iterates over all children and invokes a given block\n  each(block, deep) {\n    const children = this.children();\n    let i, il;\n    for (i = 0, il = children.length; i < il; i++) {\n      block.apply(children[i], [i, children]);\n      if (deep) {\n        children[i].each(block, deep);\n      }\n    }\n    return this;\n  }\n  element(nodeName, attrs) {\n    return this.put(new Dom(create(nodeName), attrs));\n  }\n\n  // Get first child\n  first() {\n    return adopt(this.node.firstChild);\n  }\n\n  // Get a element at the given index\n  get(i) {\n    return adopt(this.node.childNodes[i]);\n  }\n  getEventHolder() {\n    return this.node;\n  }\n  getEventTarget() {\n    return this.node;\n  }\n\n  // Checks if the given element is a child\n  has(element) {\n    return this.index(element) >= 0;\n  }\n  html(htmlOrFn, outerHTML) {\n    return this.xml(htmlOrFn, outerHTML, html);\n  }\n\n  // Get / set id\n  id(id) {\n    // generate new id if no id set\n    if (typeof id === 'undefined' && !this.node.id) {\n      this.node.id = eid(this.type);\n    }\n\n    // don't set directly with this.node.id to make `null` work correctly\n    return this.attr('id', id);\n  }\n\n  // Gets index of given element\n  index(element) {\n    return [].slice.call(this.node.childNodes).indexOf(element.node);\n  }\n\n  // Get the last child\n  last() {\n    return adopt(this.node.lastChild);\n  }\n\n  // matches the element vs a css selector\n  matches(selector) {\n    const el = this.node;\n    const matcher = el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector || null;\n    return matcher && matcher.call(el, selector);\n  }\n\n  // Returns the parent element instance\n  parent(type) {\n    let parent = this;\n\n    // check for parent\n    if (!parent.node.parentNode) return null;\n\n    // get parent element\n    parent = adopt(parent.node.parentNode);\n    if (!type) return parent;\n\n    // loop through ancestors if type is given\n    do {\n      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;\n    } while (parent = adopt(parent.node.parentNode));\n    return parent;\n  }\n\n  // Basically does the same as `add()` but returns the added element instead\n  put(element, i) {\n    element = makeInstance(element);\n    this.add(element, i);\n    return element;\n  }\n\n  // Add element to given container and return container\n  putIn(parent, i) {\n    return makeInstance(parent).add(this, i);\n  }\n\n  // Remove element\n  remove() {\n    if (this.parent()) {\n      this.parent().removeElement(this);\n    }\n    return this;\n  }\n\n  // Remove a given child\n  removeElement(element) {\n    this.node.removeChild(element.node);\n    return this;\n  }\n\n  // Replace this with element\n  replace(element) {\n    element = makeInstance(element);\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(element.node, this.node);\n    }\n    return element;\n  }\n  round(precision = 2, map = null) {\n    const factor = 10 ** precision;\n    const attrs = this.attr(map);\n    for (const i in attrs) {\n      if (typeof attrs[i] === 'number') {\n        attrs[i] = Math.round(attrs[i] * factor) / factor;\n      }\n    }\n    this.attr(attrs);\n    return this;\n  }\n\n  // Import / Export raw svg\n  svg(svgOrFn, outerSVG) {\n    return this.xml(svgOrFn, outerSVG, svg);\n  }\n\n  // Return id on string conversion\n  toString() {\n    return this.id();\n  }\n  words(text) {\n    // This is faster than removing all children and adding a new one\n    this.node.textContent = text;\n    return this;\n  }\n  wrap(node) {\n    const parent = this.parent();\n    if (!parent) {\n      return this.addTo(node);\n    }\n    const position = parent.index(this);\n    return parent.put(node, position).put(this);\n  }\n\n  // write svgjs data to the dom\n  writeDataToDom() {\n    // dump variables recursively\n    this.each(function () {\n      this.writeDataToDom();\n    });\n    return this;\n  }\n\n  // Import / Export raw svg\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML;\n      outerXML = xmlOrFn;\n      xmlOrFn = null;\n    }\n\n    // act as getter if no svg string is given\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      // The default for exports is, that the outerNode is included\n      outerXML = outerXML == null ? true : outerXML;\n\n      // write svgjs data to the dom\n      this.writeDataToDom();\n      let current = this;\n\n      // An export modifier was passed\n      if (xmlOrFn != null) {\n        current = adopt(current.node.cloneNode(true));\n\n        // If the user wants outerHTML we need to process this node, too\n        if (outerXML) {\n          const result = xmlOrFn(current);\n          current = result || current;\n\n          // The user does not want this node? Well, then he gets nothing\n          if (result === false) return '';\n        }\n\n        // Deep loop through all children and apply modifier\n        current.each(function () {\n          const result = xmlOrFn(this);\n          const _this = result || this;\n\n          // If modifier returns false, discard node\n          if (result === false) {\n            this.remove();\n\n            // If modifier returns new node, use it\n          } else if (result && this !== _this) {\n            this.replace(_this);\n          }\n        }, true);\n      }\n\n      // Return outer or inner content\n      return outerXML ? current.node.outerHTML : current.node.innerHTML;\n    }\n\n    // Act as setter if we got a string\n\n    // The default for import is, that the current node is not replaced\n    outerXML = outerXML == null ? false : outerXML;\n\n    // Create temporary holder\n    const well = create('wrapper', ns);\n    const fragment = globals.document.createDocumentFragment();\n\n    // Dump raw svg\n    well.innerHTML = xmlOrFn;\n\n    // Transplant nodes into the fragment\n    for (let len = well.children.length; len--;) {\n      fragment.appendChild(well.firstElementChild);\n    }\n    const parent = this.parent();\n\n    // Add the whole fragment at once\n    return outerXML ? this.replace(fragment) && parent : this.add(fragment);\n  }\n}\nextend(Dom, {\n  attr,\n  find,\n  findOne\n});\nregister(Dom, 'Dom');","map":{"version":3,"names":["adopt","assignNewId","eid","extend","makeInstance","create","register","find","findOne","globals","map","svg","html","EventTarget","List","attr","Dom","constructor","node","attrs","type","nodeName","add","element","i","removeNamespace","window","SVGElement","appendChild","childNodes","insertBefore","addTo","parent","put","children","clear","hasChildNodes","removeChild","lastChild","clone","deep","assignNewIds","writeDataToDom","nodeClone","cloneNode","each","block","il","length","apply","first","firstChild","get","getEventHolder","getEventTarget","has","index","htmlOrFn","outerHTML","xml","id","slice","call","indexOf","last","matches","selector","el","matcher","matchesSelector","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","parentNode","putIn","remove","removeElement","replace","replaceChild","round","precision","factor","Math","svgOrFn","outerSVG","toString","words","text","textContent","wrap","position","xmlOrFn","outerXML","ns","current","result","_this","innerHTML","well","fragment","document","createDocumentFragment","len","firstElementChild"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/@svgdotjs/svg.js/src/elements/Dom.js"],"sourcesContent":["import {\n  adopt,\n  assignNewId,\n  eid,\n  extend,\n  makeInstance,\n  create,\n  register\n} from '../utils/adopter.js'\nimport { find, findOne } from '../modules/core/selector.js'\nimport { globals } from '../utils/window.js'\nimport { map } from '../utils/utils.js'\nimport { svg, html } from '../modules/core/namespaces.js'\nimport EventTarget from '../types/EventTarget.js'\nimport List from '../types/List.js'\nimport attr from '../modules/core/attr.js'\n\nexport default class Dom extends EventTarget {\n  constructor(node, attrs) {\n    super()\n    this.node = node\n    this.type = node.nodeName\n\n    if (attrs && node !== attrs) {\n      this.attr(attrs)\n    }\n  }\n\n  // Add given element at a position\n  add(element, i) {\n    element = makeInstance(element)\n\n    // If non-root svg nodes are added we have to remove their namespaces\n    if (\n      element.removeNamespace &&\n      this.node instanceof globals.window.SVGElement\n    ) {\n      element.removeNamespace()\n    }\n\n    if (i == null) {\n      this.node.appendChild(element.node)\n    } else if (element.node !== this.node.childNodes[i]) {\n      this.node.insertBefore(element.node, this.node.childNodes[i])\n    }\n\n    return this\n  }\n\n  // Add element to given container and return self\n  addTo(parent, i) {\n    return makeInstance(parent).put(this, i)\n  }\n\n  // Returns all child elements\n  children() {\n    return new List(\n      map(this.node.children, function (node) {\n        return adopt(node)\n      })\n    )\n  }\n\n  // Remove all elements in this container\n  clear() {\n    // remove children\n    while (this.node.hasChildNodes()) {\n      this.node.removeChild(this.node.lastChild)\n    }\n\n    return this\n  }\n\n  // Clone element\n  clone(deep = true, assignNewIds = true) {\n    // write dom data to the dom so the clone can pickup the data\n    this.writeDataToDom()\n\n    // clone element\n    let nodeClone = this.node.cloneNode(deep)\n    if (assignNewIds) {\n      // assign new id\n      nodeClone = assignNewId(nodeClone)\n    }\n    return new this.constructor(nodeClone)\n  }\n\n  // Iterates over all children and invokes a given block\n  each(block, deep) {\n    const children = this.children()\n    let i, il\n\n    for (i = 0, il = children.length; i < il; i++) {\n      block.apply(children[i], [i, children])\n\n      if (deep) {\n        children[i].each(block, deep)\n      }\n    }\n\n    return this\n  }\n\n  element(nodeName, attrs) {\n    return this.put(new Dom(create(nodeName), attrs))\n  }\n\n  // Get first child\n  first() {\n    return adopt(this.node.firstChild)\n  }\n\n  // Get a element at the given index\n  get(i) {\n    return adopt(this.node.childNodes[i])\n  }\n\n  getEventHolder() {\n    return this.node\n  }\n\n  getEventTarget() {\n    return this.node\n  }\n\n  // Checks if the given element is a child\n  has(element) {\n    return this.index(element) >= 0\n  }\n\n  html(htmlOrFn, outerHTML) {\n    return this.xml(htmlOrFn, outerHTML, html)\n  }\n\n  // Get / set id\n  id(id) {\n    // generate new id if no id set\n    if (typeof id === 'undefined' && !this.node.id) {\n      this.node.id = eid(this.type)\n    }\n\n    // don't set directly with this.node.id to make `null` work correctly\n    return this.attr('id', id)\n  }\n\n  // Gets index of given element\n  index(element) {\n    return [].slice.call(this.node.childNodes).indexOf(element.node)\n  }\n\n  // Get the last child\n  last() {\n    return adopt(this.node.lastChild)\n  }\n\n  // matches the element vs a css selector\n  matches(selector) {\n    const el = this.node\n    const matcher =\n      el.matches ||\n      el.matchesSelector ||\n      el.msMatchesSelector ||\n      el.mozMatchesSelector ||\n      el.webkitMatchesSelector ||\n      el.oMatchesSelector ||\n      null\n    return matcher && matcher.call(el, selector)\n  }\n\n  // Returns the parent element instance\n  parent(type) {\n    let parent = this\n\n    // check for parent\n    if (!parent.node.parentNode) return null\n\n    // get parent element\n    parent = adopt(parent.node.parentNode)\n\n    if (!type) return parent\n\n    // loop through ancestors if type is given\n    do {\n      if (\n        typeof type === 'string' ? parent.matches(type) : parent instanceof type\n      )\n        return parent\n    } while ((parent = adopt(parent.node.parentNode)))\n\n    return parent\n  }\n\n  // Basically does the same as `add()` but returns the added element instead\n  put(element, i) {\n    element = makeInstance(element)\n    this.add(element, i)\n    return element\n  }\n\n  // Add element to given container and return container\n  putIn(parent, i) {\n    return makeInstance(parent).add(this, i)\n  }\n\n  // Remove element\n  remove() {\n    if (this.parent()) {\n      this.parent().removeElement(this)\n    }\n\n    return this\n  }\n\n  // Remove a given child\n  removeElement(element) {\n    this.node.removeChild(element.node)\n\n    return this\n  }\n\n  // Replace this with element\n  replace(element) {\n    element = makeInstance(element)\n\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(element.node, this.node)\n    }\n\n    return element\n  }\n\n  round(precision = 2, map = null) {\n    const factor = 10 ** precision\n    const attrs = this.attr(map)\n\n    for (const i in attrs) {\n      if (typeof attrs[i] === 'number') {\n        attrs[i] = Math.round(attrs[i] * factor) / factor\n      }\n    }\n\n    this.attr(attrs)\n    return this\n  }\n\n  // Import / Export raw svg\n  svg(svgOrFn, outerSVG) {\n    return this.xml(svgOrFn, outerSVG, svg)\n  }\n\n  // Return id on string conversion\n  toString() {\n    return this.id()\n  }\n\n  words(text) {\n    // This is faster than removing all children and adding a new one\n    this.node.textContent = text\n    return this\n  }\n\n  wrap(node) {\n    const parent = this.parent()\n\n    if (!parent) {\n      return this.addTo(node)\n    }\n\n    const position = parent.index(this)\n    return parent.put(node, position).put(this)\n  }\n\n  // write svgjs data to the dom\n  writeDataToDom() {\n    // dump variables recursively\n    this.each(function () {\n      this.writeDataToDom()\n    })\n\n    return this\n  }\n\n  // Import / Export raw svg\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML\n      outerXML = xmlOrFn\n      xmlOrFn = null\n    }\n\n    // act as getter if no svg string is given\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      // The default for exports is, that the outerNode is included\n      outerXML = outerXML == null ? true : outerXML\n\n      // write svgjs data to the dom\n      this.writeDataToDom()\n      let current = this\n\n      // An export modifier was passed\n      if (xmlOrFn != null) {\n        current = adopt(current.node.cloneNode(true))\n\n        // If the user wants outerHTML we need to process this node, too\n        if (outerXML) {\n          const result = xmlOrFn(current)\n          current = result || current\n\n          // The user does not want this node? Well, then he gets nothing\n          if (result === false) return ''\n        }\n\n        // Deep loop through all children and apply modifier\n        current.each(function () {\n          const result = xmlOrFn(this)\n          const _this = result || this\n\n          // If modifier returns false, discard node\n          if (result === false) {\n            this.remove()\n\n            // If modifier returns new node, use it\n          } else if (result && this !== _this) {\n            this.replace(_this)\n          }\n        }, true)\n      }\n\n      // Return outer or inner content\n      return outerXML ? current.node.outerHTML : current.node.innerHTML\n    }\n\n    // Act as setter if we got a string\n\n    // The default for import is, that the current node is not replaced\n    outerXML = outerXML == null ? false : outerXML\n\n    // Create temporary holder\n    const well = create('wrapper', ns)\n    const fragment = globals.document.createDocumentFragment()\n\n    // Dump raw svg\n    well.innerHTML = xmlOrFn\n\n    // Transplant nodes into the fragment\n    for (let len = well.children.length; len--; ) {\n      fragment.appendChild(well.firstElementChild)\n    }\n\n    const parent = this.parent()\n\n    // Add the whole fragment at once\n    return outerXML ? this.replace(fragment) && parent : this.add(fragment)\n  }\n}\n\nextend(Dom, { attr, find, findOne })\nregister(Dom, 'Dom')\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}