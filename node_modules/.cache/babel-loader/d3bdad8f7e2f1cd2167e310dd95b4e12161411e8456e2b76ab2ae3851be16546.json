{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Controller, Ease, Stepper } from './Controller.js';\nimport { extend, register } from '../utils/adopter.js';\nimport { from, to } from '../modules/core/gradiented.js';\nimport { getOrigin } from '../utils/utils.js';\nimport { noop, timeline } from '../modules/core/defaults.js';\nimport { registerMethods } from '../utils/methods.js';\nimport { rx, ry } from '../modules/core/circled.js';\nimport Animator from './Animator.js';\nimport Box from '../types/Box.js';\nimport EventTarget from '../types/EventTarget.js';\nimport Matrix from '../types/Matrix.js';\nimport Morphable, { TransformBag, ObjectBag } from './Morphable.js';\nimport Point from '../types/Point.js';\nimport SVGNumber from '../types/SVGNumber.js';\nimport Timeline from './Timeline.js';\nexport default class Runner extends EventTarget {\n  constructor(options) {\n    super();\n\n    // Store a unique id on the runner, so that we can identify it later\n    this.id = Runner.id++;\n\n    // Ensure a default value\n    options = options == null ? timeline.duration : options;\n\n    // Ensure that we get a controller\n    options = typeof options === 'function' ? new Controller(options) : options;\n\n    // Declare all of the variables\n    this._element = null;\n    this._timeline = null;\n    this.done = false;\n    this._queue = [];\n\n    // Work out the stepper and the duration\n    this._duration = typeof options === 'number' && options;\n    this._isDeclarative = options instanceof Controller;\n    this._stepper = this._isDeclarative ? options : new Ease();\n\n    // We copy the current values from the timeline because they can change\n    this._history = {};\n\n    // Store the state of the runner\n    this.enabled = true;\n    this._time = 0;\n    this._lastTime = 0;\n\n    // At creation, the runner is in reset state\n    this._reseted = true;\n\n    // Save transforms applied to this runner\n    this.transforms = new Matrix();\n    this.transformId = 1;\n\n    // Looping variables\n    this._haveReversed = false;\n    this._reverse = false;\n    this._loopsDone = 0;\n    this._swing = false;\n    this._wait = 0;\n    this._times = 1;\n    this._frameId = null;\n\n    // Stores how long a runner is stored after being done\n    this._persist = this._isDeclarative ? true : null;\n  }\n  static sanitise(duration, delay, when) {\n    // Initialise the default parameters\n    let times = 1;\n    let swing = false;\n    let wait = 0;\n    duration = duration ?? timeline.duration;\n    delay = delay ?? timeline.delay;\n    when = when || 'last';\n\n    // If we have an object, unpack the values\n    if (typeof duration === 'object' && !(duration instanceof Stepper)) {\n      delay = duration.delay ?? delay;\n      when = duration.when ?? when;\n      swing = duration.swing || swing;\n      times = duration.times ?? times;\n      wait = duration.wait ?? wait;\n      duration = duration.duration ?? timeline.duration;\n    }\n    return {\n      duration: duration,\n      delay: delay,\n      swing: swing,\n      times: times,\n      wait: wait,\n      when: when\n    };\n  }\n  active(enabled) {\n    if (enabled == null) return this.enabled;\n    this.enabled = enabled;\n    return this;\n  }\n\n  /*\n  Private Methods\n  ===============\n  Methods that shouldn't be used externally\n  */\n  addTransform(transform) {\n    this.transforms.lmultiplyO(transform);\n    return this;\n  }\n  after(fn) {\n    return this.on('finished', fn);\n  }\n  animate(duration, delay, when) {\n    const o = Runner.sanitise(duration, delay, when);\n    const runner = new Runner(o.duration);\n    if (this._timeline) runner.timeline(this._timeline);\n    if (this._element) runner.element(this._element);\n    return runner.loop(o).schedule(o.delay, o.when);\n  }\n  clearTransform() {\n    this.transforms = new Matrix();\n    return this;\n  }\n\n  // TODO: Keep track of all transformations so that deletion is faster\n  clearTransformsFromQueue() {\n    if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {\n      this._queue = this._queue.filter(item => {\n        return !item.isTransform;\n      });\n    }\n  }\n  delay(delay) {\n    return this.animate(0, delay);\n  }\n  duration() {\n    return this._times * (this._wait + this._duration) - this._wait;\n  }\n  during(fn) {\n    return this.queue(null, fn);\n  }\n  ease(fn) {\n    this._stepper = new Ease(fn);\n    return this;\n  }\n  /*\n  Runner Definitions\n  ==================\n  These methods help us define the runtime behaviour of the Runner or they\n  help us make new runners from the current runner\n  */\n\n  element(element) {\n    if (element == null) return this._element;\n    this._element = element;\n    element._prepareRunner();\n    return this;\n  }\n  finish() {\n    return this.step(Infinity);\n  }\n  loop(times, swing, wait) {\n    // Deal with the user passing in an object\n    if (typeof times === 'object') {\n      swing = times.swing;\n      wait = times.wait;\n      times = times.times;\n    }\n\n    // Sanitise the values and store them\n    this._times = times || Infinity;\n    this._swing = swing || false;\n    this._wait = wait || 0;\n\n    // Allow true to be passed\n    if (this._times === true) {\n      this._times = Infinity;\n    }\n    return this;\n  }\n  loops(p) {\n    const loopDuration = this._duration + this._wait;\n    if (p == null) {\n      const loopsDone = Math.floor(this._time / loopDuration);\n      const relativeTime = this._time - loopsDone * loopDuration;\n      const position = relativeTime / this._duration;\n      return Math.min(loopsDone + position, this._times);\n    }\n    const whole = Math.floor(p);\n    const partial = p % 1;\n    const time = loopDuration * whole + this._duration * partial;\n    return this.time(time);\n  }\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist;\n    this._persist = dtOrForever;\n    return this;\n  }\n  position(p) {\n    // Get all of the variables we need\n    const x = this._time;\n    const d = this._duration;\n    const w = this._wait;\n    const t = this._times;\n    const s = this._swing;\n    const r = this._reverse;\n    let position;\n    if (p == null) {\n      /*\n      This function converts a time to a position in the range [0, 1]\n      The full explanation can be found in this desmos demonstration\n        https://www.desmos.com/calculator/u4fbavgche\n      The logic is slightly simplified here because we can use booleans\n      */\n\n      // Figure out the value without thinking about the start or end time\n      const f = function (x) {\n        const swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));\n        const backwards = swinging && !r || !swinging && r;\n        const uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;\n        const clipped = Math.max(Math.min(uncliped, 1), 0);\n        return clipped;\n      };\n\n      // Figure out the value by incorporating the start time\n      const endTime = t * (w + d) - w;\n      position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));\n      return position;\n    }\n\n    // Work out the loops done and add the position to the loops done\n    const loopsDone = Math.floor(this.loops());\n    const swingForward = s && loopsDone % 2 === 0;\n    const forwards = swingForward && !r || r && swingForward;\n    position = loopsDone + (forwards ? p : 1 - p);\n    return this.loops(position);\n  }\n  progress(p) {\n    if (p == null) {\n      return Math.min(1, this._time / this.duration());\n    }\n    return this.time(p * this.duration());\n  }\n\n  /*\n  Basic Functionality\n  ===================\n  These methods allow us to attach basic functions to the runner directly\n  */\n  queue(initFn, runFn, retargetFn, isTransform) {\n    this._queue.push({\n      initialiser: initFn || noop,\n      runner: runFn || noop,\n      retarget: retargetFn,\n      isTransform: isTransform,\n      initialised: false,\n      finished: false\n    });\n    const timeline = this.timeline();\n    timeline && this.timeline()._continue();\n    return this;\n  }\n  reset() {\n    if (this._reseted) return this;\n    this.time(0);\n    this._reseted = true;\n    return this;\n  }\n  reverse(reverse) {\n    this._reverse = reverse == null ? !this._reverse : reverse;\n    return this;\n  }\n  schedule(timeline, delay, when) {\n    // The user doesn't need to pass a timeline if we already have one\n    if (!(timeline instanceof Timeline)) {\n      when = delay;\n      delay = timeline;\n      timeline = this.timeline();\n    }\n\n    // If there is no timeline, yell at the user...\n    if (!timeline) {\n      throw Error('Runner cannot be scheduled without timeline');\n    }\n\n    // Schedule the runner on the timeline provided\n    timeline.schedule(this, delay, when);\n    return this;\n  }\n  step(dt) {\n    // If we are inactive, this stepper just gets skipped\n    if (!this.enabled) return this;\n\n    // Update the time and get the new position\n    dt = dt == null ? 16 : dt;\n    this._time += dt;\n    const position = this.position();\n\n    // Figure out if we need to run the stepper in this frame\n    const running = this._lastPosition !== position && this._time >= 0;\n    this._lastPosition = position;\n\n    // Figure out if we just started\n    const duration = this.duration();\n    const justStarted = this._lastTime <= 0 && this._time > 0;\n    const justFinished = this._lastTime < duration && this._time >= duration;\n    this._lastTime = this._time;\n    if (justStarted) {\n      this.fire('start', this);\n    }\n\n    // Work out if the runner is finished set the done flag here so animations\n    // know, that they are running in the last step (this is good for\n    // transformations which can be merged)\n    const declarative = this._isDeclarative;\n    this.done = !declarative && !justFinished && this._time >= duration;\n\n    // Runner is running. So its not in reset state anymore\n    this._reseted = false;\n    let converged = false;\n    // Call initialise and the run function\n    if (running || declarative) {\n      this._initialise(running);\n\n      // clear the transforms on this runner so they dont get added again and again\n      this.transforms = new Matrix();\n      converged = this._run(declarative ? dt : position);\n      this.fire('step', this);\n    }\n    // correct the done flag here\n    // declarative animations itself know when they converged\n    this.done = this.done || converged && declarative;\n    if (justFinished) {\n      this.fire('finished', this);\n    }\n    return this;\n  }\n\n  /*\n  Runner animation methods\n  ========================\n  Control how the animation plays\n  */\n  time(time) {\n    if (time == null) {\n      return this._time;\n    }\n    const dt = time - this._time;\n    this.step(dt);\n    return this;\n  }\n  timeline(timeline) {\n    // check explicitly for undefined so we can set the timeline to null\n    if (typeof timeline === 'undefined') return this._timeline;\n    this._timeline = timeline;\n    return this;\n  }\n  unschedule() {\n    const timeline = this.timeline();\n    timeline && timeline.unschedule(this);\n    return this;\n  }\n\n  // Run each initialise function in the runner if required\n  _initialise(running) {\n    // If we aren't running, we shouldn't initialise when not declarative\n    if (!running && !this._isDeclarative) return;\n\n    // Loop through all of the initialisers\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current initialiser\n      const current = this._queue[i];\n\n      // Determine whether we need to initialise\n      const needsIt = this._isDeclarative || !current.initialised && running;\n      running = !current.finished;\n\n      // Call the initialiser if we need to\n      if (needsIt && running) {\n        current.initialiser.call(this);\n        current.initialised = true;\n      }\n    }\n  }\n\n  // Save a morpher to the morpher list so that we can retarget it later\n  _rememberMorpher(method, morpher) {\n    this._history[method] = {\n      morpher: morpher,\n      caller: this._queue[this._queue.length - 1]\n    };\n\n    // We have to resume the timeline in case a controller\n    // is already done without being ever run\n    // This can happen when e.g. this is done:\n    //    anim = el.animate(new SVG.Spring)\n    // and later\n    //    anim.move(...)\n    if (this._isDeclarative) {\n      const timeline = this.timeline();\n      timeline && timeline.play();\n    }\n  }\n\n  // Try to set the target for a morpher if the morpher exists, otherwise\n  // Run each run function for the position or dt given\n  _run(positionOrDt) {\n    // Run all of the _queue directly\n    let allfinished = true;\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current function to run\n      const current = this._queue[i];\n\n      // Run the function if its not finished, we keep track of the finished\n      // flag for the sake of declarative _queue\n      const converged = current.runner.call(this, positionOrDt);\n      current.finished = current.finished || converged === true;\n      allfinished = allfinished && current.finished;\n    }\n\n    // We report when all of the constructors are finished\n    return allfinished;\n  }\n\n  // do nothing and return false\n  _tryRetarget(method, target, extra) {\n    if (this._history[method]) {\n      // if the last method wasn't even initialised, throw it away\n      if (!this._history[method].caller.initialised) {\n        const index = this._queue.indexOf(this._history[method].caller);\n        this._queue.splice(index, 1);\n        return false;\n      }\n\n      // for the case of transformations, we use the special retarget function\n      // which has access to the outer scope\n      if (this._history[method].caller.retarget) {\n        this._history[method].caller.retarget.call(this, target, extra);\n        // for everything else a simple morpher change is sufficient\n      } else {\n        this._history[method].morpher.to(target);\n      }\n      this._history[method].caller.finished = false;\n      const timeline = this.timeline();\n      timeline && timeline.play();\n      return true;\n    }\n    return false;\n  }\n}\nRunner.id = 0;\nexport class FakeRunner {\n  constructor(transforms = new Matrix(), id = -1, done = true) {\n    this.transforms = transforms;\n    this.id = id;\n    this.done = done;\n  }\n  clearTransformsFromQueue() {}\n}\nextend([Runner, FakeRunner], {\n  mergeWith(runner) {\n    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);\n  }\n});\n\n// FakeRunner.emptyRunner = new FakeRunner()\n\nconst lmultiply = (last, curr) => last.lmultiplyO(curr);\nconst getRunnerTransform = runner => runner.transforms;\nfunction mergeTransforms() {\n  // Find the matrix to apply to the element and apply it\n  const runners = this._transformationRunners.runners;\n  const netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());\n  this.transform(netTransform);\n  this._transformationRunners.merge();\n  if (this._transformationRunners.length() === 1) {\n    this._frameId = null;\n  }\n}\nexport class RunnerArray {\n  constructor() {\n    this.runners = [];\n    this.ids = [];\n  }\n  add(runner) {\n    if (this.runners.includes(runner)) return;\n    const id = runner.id + 1;\n    this.runners.push(runner);\n    this.ids.push(id);\n    return this;\n  }\n  clearBefore(id) {\n    const deleteCnt = this.ids.indexOf(id + 1) || 1;\n    this.ids.splice(0, deleteCnt, 0);\n    this.runners.splice(0, deleteCnt, new FakeRunner()).forEach(r => r.clearTransformsFromQueue());\n    return this;\n  }\n  edit(id, newRunner) {\n    const index = this.ids.indexOf(id + 1);\n    this.ids.splice(index, 1, id + 1);\n    this.runners.splice(index, 1, newRunner);\n    return this;\n  }\n  getByID(id) {\n    return this.runners[this.ids.indexOf(id + 1)];\n  }\n  length() {\n    return this.ids.length;\n  }\n  merge() {\n    let lastRunner = null;\n    for (let i = 0; i < this.runners.length; ++i) {\n      const runner = this.runners[i];\n      const condition = lastRunner && runner.done && lastRunner.done && (\n      // don't merge runner when persisted on timeline\n      !runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));\n      if (condition) {\n        // the +1 happens in the function\n        this.remove(runner.id);\n        const newRunner = runner.mergeWith(lastRunner);\n        this.edit(lastRunner.id, newRunner);\n        lastRunner = newRunner;\n        --i;\n      } else {\n        lastRunner = runner;\n      }\n    }\n    return this;\n  }\n  remove(id) {\n    const index = this.ids.indexOf(id + 1);\n    this.ids.splice(index, 1);\n    this.runners.splice(index, 1);\n    return this;\n  }\n}\nregisterMethods({\n  Element: {\n    animate(duration, delay, when) {\n      const o = Runner.sanitise(duration, delay, when);\n      const timeline = this.timeline();\n      return new Runner(o.duration).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);\n    },\n    delay(by, when) {\n      return this.animate(0, by, when);\n    },\n    // this function searches for all runners on the element and deletes the ones\n    // which run before the current one. This is because absolute transformations\n    // overwrite anything anyway so there is no need to waste time computing\n    // other runners\n    _clearTransformRunnersBefore(currentRunner) {\n      this._transformationRunners.clearBefore(currentRunner.id);\n    },\n    _currentTransform(current) {\n      return this._transformationRunners.runners\n      // we need the equal sign here to make sure, that also transformations\n      // on the same runner which execute before the current transformation are\n      // taken into account\n      .filter(runner => runner.id <= current.id).map(getRunnerTransform).reduce(lmultiply, new Matrix());\n    },\n    _addRunner(runner) {\n      this._transformationRunners.add(runner);\n\n      // Make sure that the runner merge is executed at the very end of\n      // all Animator functions. That is why we use immediate here to execute\n      // the merge right after all frames are run\n      Animator.cancelImmediate(this._frameId);\n      this._frameId = Animator.immediate(mergeTransforms.bind(this));\n    },\n    _prepareRunner() {\n      if (this._frameId == null) {\n        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));\n      }\n    }\n  }\n});\n\n// Will output the elements from array A that are not in the array B\nconst difference = (a, b) => a.filter(x => !b.includes(x));\nextend(Runner, {\n  attr(a, v) {\n    return this.styleAttr('attr', a, v);\n  },\n  // Add animatable styles\n  css(s, v) {\n    return this.styleAttr('css', s, v);\n  },\n  styleAttr(type, nameOrAttrs, val) {\n    if (typeof nameOrAttrs === 'string') {\n      return this.styleAttr(type, {\n        [nameOrAttrs]: val\n      });\n    }\n    let attrs = nameOrAttrs;\n    if (this._tryRetarget(type, attrs)) return this;\n    let morpher = new Morphable(this._stepper).to(attrs);\n    let keys = Object.keys(attrs);\n    this.queue(function () {\n      morpher = morpher.from(this.element()[type](keys));\n    }, function (pos) {\n      this.element()[type](morpher.at(pos).valueOf());\n      return morpher.done();\n    }, function (newToAttrs) {\n      // Check if any new keys were added\n      const newKeys = Object.keys(newToAttrs);\n      const differences = difference(newKeys, keys);\n\n      // If their are new keys, initialize them and add them to morpher\n      if (differences.length) {\n        // Get the values\n        const addedFromAttrs = this.element()[type](differences);\n\n        // Get the already initialized values\n        const oldFromAttrs = new ObjectBag(morpher.from()).valueOf();\n\n        // Merge old and new\n        Object.assign(oldFromAttrs, addedFromAttrs);\n        morpher.from(oldFromAttrs);\n      }\n\n      // Get the object from the morpher\n      const oldToAttrs = new ObjectBag(morpher.to()).valueOf();\n\n      // Merge in new attributes\n      Object.assign(oldToAttrs, newToAttrs);\n\n      // Change morpher target\n      morpher.to(oldToAttrs);\n\n      // Make sure that we save the work we did so we don't need it to do again\n      keys = newKeys;\n      attrs = newToAttrs;\n    });\n    this._rememberMorpher(type, morpher);\n    return this;\n  },\n  zoom(level, point) {\n    if (this._tryRetarget('zoom', level, point)) return this;\n    let morpher = new Morphable(this._stepper).to(new SVGNumber(level));\n    this.queue(function () {\n      morpher = morpher.from(this.element().zoom());\n    }, function (pos) {\n      this.element().zoom(morpher.at(pos), point);\n      return morpher.done();\n    }, function (newLevel, newPoint) {\n      point = newPoint;\n      morpher.to(newLevel);\n    });\n    this._rememberMorpher('zoom', morpher);\n    return this;\n  },\n  /**\n   ** absolute transformations\n   **/\n\n  //\n  // M v -----|-----(D M v = F v)------|----->  T v\n  //\n  // 1. define the final state (T) and decompose it (once)\n  //    t = [tx, ty, the, lam, sy, sx]\n  // 2. on every frame: pull the current state of all previous transforms\n  //    (M - m can change)\n  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]\n  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)\n  //   - Note F(0) = M\n  //   - Note F(1) = T\n  // 4. Now you get the delta matrix as a result: D = F * inv(M)\n\n  transform(transforms, relative, affine) {\n    // If we have a declarative function, we should retarget it if possible\n    relative = transforms.relative || relative;\n    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {\n      return this;\n    }\n\n    // Parse the parameters\n    const isMatrix = Matrix.isMatrixLike(transforms);\n    affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix;\n\n    // Create a morpher and set its type\n    const morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);\n    let origin;\n    let element;\n    let current;\n    let currentAngle;\n    let startTransform;\n    function setup() {\n      // make sure element and origin is defined\n      element = element || this.element();\n      origin = origin || getOrigin(transforms, element);\n      startTransform = new Matrix(relative ? undefined : element);\n\n      // add the runner to the element so it can merge transformations\n      element._addRunner(this);\n\n      // Deactivate all transforms that have run so far if we are absolute\n      if (!relative) {\n        element._clearTransformRunnersBefore(this);\n      }\n    }\n    function run(pos) {\n      // clear all other transforms before this in case something is saved\n      // on this runner. We are absolute. We dont need these!\n      if (!relative) this.clearTransform();\n      const {\n        x,\n        y\n      } = new Point(origin).transform(element._currentTransform(this));\n      let target = new Matrix({\n        ...transforms,\n        origin: [x, y]\n      });\n      let start = this._isDeclarative && current ? current : startTransform;\n      if (affine) {\n        target = target.decompose(x, y);\n        start = start.decompose(x, y);\n\n        // Get the current and target angle as it was set\n        const rTarget = target.rotate;\n        const rCurrent = start.rotate;\n\n        // Figure out the shortest path to rotate directly\n        const possibilities = [rTarget - 360, rTarget, rTarget + 360];\n        const distances = possibilities.map(a => Math.abs(a - rCurrent));\n        const shortest = Math.min(...distances);\n        const index = distances.indexOf(shortest);\n        target.rotate = possibilities[index];\n      }\n      if (relative) {\n        // we have to be careful here not to overwrite the rotation\n        // with the rotate method of Matrix\n        if (!isMatrix) {\n          target.rotate = transforms.rotate || 0;\n        }\n        if (this._isDeclarative && currentAngle) {\n          start.rotate = currentAngle;\n        }\n      }\n      morpher.from(start);\n      morpher.to(target);\n      const affineParameters = morpher.at(pos);\n      currentAngle = affineParameters.rotate;\n      current = new Matrix(affineParameters);\n      this.addTransform(current);\n      element._addRunner(this);\n      return morpher.done();\n    }\n    function retarget(newTransforms) {\n      // only get a new origin if it changed since the last call\n      if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) {\n        origin = getOrigin(newTransforms, element);\n      }\n\n      // overwrite the old transformations with the new ones\n      transforms = {\n        ...newTransforms,\n        origin\n      };\n    }\n    this.queue(setup, run, retarget, true);\n    this._isDeclarative && this._rememberMorpher('transform', morpher);\n    return this;\n  },\n  // Animatable x-axis\n  x(x) {\n    return this._queueNumber('x', x);\n  },\n  // Animatable y-axis\n  y(y) {\n    return this._queueNumber('y', y);\n  },\n  ax(x) {\n    return this._queueNumber('ax', x);\n  },\n  ay(y) {\n    return this._queueNumber('ay', y);\n  },\n  dx(x = 0) {\n    return this._queueNumberDelta('x', x);\n  },\n  dy(y = 0) {\n    return this._queueNumberDelta('y', y);\n  },\n  dmove(x, y) {\n    return this.dx(x).dy(y);\n  },\n  _queueNumberDelta(method, to) {\n    to = new SVGNumber(to);\n\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this;\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to);\n    let from = null;\n    this.queue(function () {\n      from = this.element()[method]();\n      morpher.from(from);\n      morpher.to(from + to);\n    }, function (pos) {\n      this.element()[method](morpher.at(pos));\n      return morpher.done();\n    }, function (newTo) {\n      morpher.to(from + new SVGNumber(newTo));\n    });\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher);\n    return this;\n  },\n  _queueObject(method, to) {\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this;\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to);\n    this.queue(function () {\n      morpher.from(this.element()[method]());\n    }, function (pos) {\n      this.element()[method](morpher.at(pos));\n      return morpher.done();\n    });\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher);\n    return this;\n  },\n  _queueNumber(method, value) {\n    return this._queueObject(method, new SVGNumber(value));\n  },\n  // Animatable center x-axis\n  cx(x) {\n    return this._queueNumber('cx', x);\n  },\n  // Animatable center y-axis\n  cy(y) {\n    return this._queueNumber('cy', y);\n  },\n  // Add animatable move\n  move(x, y) {\n    return this.x(x).y(y);\n  },\n  amove(x, y) {\n    return this.ax(x).ay(y);\n  },\n  // Add animatable center\n  center(x, y) {\n    return this.cx(x).cy(y);\n  },\n  // Add animatable size\n  size(width, height) {\n    // animate bbox based size for all other elements\n    let box;\n    if (!width || !height) {\n      box = this._element.bbox();\n    }\n    if (!width) {\n      width = box.width / box.height * height;\n    }\n    if (!height) {\n      height = box.height / box.width * width;\n    }\n    return this.width(width).height(height);\n  },\n  // Add animatable width\n  width(width) {\n    return this._queueNumber('width', width);\n  },\n  // Add animatable height\n  height(height) {\n    return this._queueNumber('height', height);\n  },\n  // Add animatable plot\n  plot(a, b, c, d) {\n    // Lines can be plotted with 4 arguments\n    if (arguments.length === 4) {\n      return this.plot([a, b, c, d]);\n    }\n    if (this._tryRetarget('plot', a)) return this;\n    const morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);\n    this.queue(function () {\n      morpher.from(this._element.array());\n    }, function (pos) {\n      this._element.plot(morpher.at(pos));\n      return morpher.done();\n    });\n    this._rememberMorpher('plot', morpher);\n    return this;\n  },\n  // Add leading method\n  leading(value) {\n    return this._queueNumber('leading', value);\n  },\n  // Add animatable viewbox\n  viewbox(x, y, width, height) {\n    return this._queueObject('viewbox', new Box(x, y, width, height));\n  },\n  update(o) {\n    if (typeof o !== 'object') {\n      return this.update({\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      });\n    }\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n    if (o.color != null) this.attr('stop-color', o.color);\n    if (o.offset != null) this.attr('offset', o.offset);\n    return this;\n  }\n});\nextend(Runner, {\n  rx,\n  ry,\n  from,\n  to\n});\nregister(Runner, 'Runner');","map":{"version":3,"names":["Controller","Ease","Stepper","extend","register","from","to","getOrigin","noop","timeline","registerMethods","rx","ry","Animator","Box","EventTarget","Matrix","Morphable","TransformBag","ObjectBag","Point","SVGNumber","Timeline","Runner","constructor","options","id","duration","_element","_timeline","done","_queue","_duration","_isDeclarative","_stepper","_history","enabled","_time","_lastTime","_reseted","transforms","transformId","_haveReversed","_reverse","_loopsDone","_swing","_wait","_times","_frameId","_persist","sanitise","delay","when","times","swing","wait","active","addTransform","transform","lmultiplyO","after","fn","on","animate","o","runner","element","loop","schedule","clearTransform","clearTransformsFromQueue","_runnerIds","includes","filter","item","isTransform","during","queue","ease","_prepareRunner","finish","step","Infinity","loops","p","loopDuration","loopsDone","Math","floor","relativeTime","position","min","whole","partial","time","persist","dtOrForever","x","d","w","t","s","r","f","swinging","backwards","uncliped","pow","clipped","max","endTime","round","swingForward","forwards","progress","initFn","runFn","retargetFn","push","initialiser","retarget","initialised","finished","_continue","reset","reverse","Error","dt","running","_lastPosition","justStarted","justFinished","fire","declarative","converged","_initialise","_run","unschedule","i","len","length","current","needsIt","call","_rememberMorpher","method","morpher","caller","play","positionOrDt","allfinished","_tryRetarget","target","extra","index","indexOf","splice","FakeRunner","mergeWith","lmultiply","last","curr","getRunnerTransform","mergeTransforms","runners","_transformationRunners","netTransform","map","reduce","merge","RunnerArray","ids","add","clearBefore","deleteCnt","forEach","edit","newRunner","getByID","lastRunner","condition","remove","Element","by","_clearTransformRunnersBefore","currentRunner","_currentTransform","_addRunner","cancelImmediate","immediate","bind","difference","a","b","attr","v","styleAttr","css","type","nameOrAttrs","val","attrs","keys","Object","pos","at","valueOf","newToAttrs","newKeys","differences","addedFromAttrs","oldFromAttrs","assign","oldToAttrs","zoom","level","point","newLevel","newPoint","relative","affine","isMatrix","isMatrixLike","origin","currentAngle","startTransform","setup","undefined","run","y","start","decompose","rTarget","rotate","rCurrent","possibilities","distances","abs","shortest","affineParameters","newTransforms","toString","_queueNumber","ax","ay","dx","_queueNumberDelta","dy","dmove","newTo","_queueObject","value","cx","cy","move","amove","center","size","width","height","box","bbox","plot","c","arguments","MorphArray","array","leading","viewbox","update","offset","color","opacity"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/@svgdotjs/svg.js/src/animation/Runner.js"],"sourcesContent":["import { Controller, Ease, Stepper } from './Controller.js'\nimport { extend, register } from '../utils/adopter.js'\nimport { from, to } from '../modules/core/gradiented.js'\nimport { getOrigin } from '../utils/utils.js'\nimport { noop, timeline } from '../modules/core/defaults.js'\nimport { registerMethods } from '../utils/methods.js'\nimport { rx, ry } from '../modules/core/circled.js'\nimport Animator from './Animator.js'\nimport Box from '../types/Box.js'\nimport EventTarget from '../types/EventTarget.js'\nimport Matrix from '../types/Matrix.js'\nimport Morphable, { TransformBag, ObjectBag } from './Morphable.js'\nimport Point from '../types/Point.js'\nimport SVGNumber from '../types/SVGNumber.js'\nimport Timeline from './Timeline.js'\n\nexport default class Runner extends EventTarget {\n  constructor(options) {\n    super()\n\n    // Store a unique id on the runner, so that we can identify it later\n    this.id = Runner.id++\n\n    // Ensure a default value\n    options = options == null ? timeline.duration : options\n\n    // Ensure that we get a controller\n    options = typeof options === 'function' ? new Controller(options) : options\n\n    // Declare all of the variables\n    this._element = null\n    this._timeline = null\n    this.done = false\n    this._queue = []\n\n    // Work out the stepper and the duration\n    this._duration = typeof options === 'number' && options\n    this._isDeclarative = options instanceof Controller\n    this._stepper = this._isDeclarative ? options : new Ease()\n\n    // We copy the current values from the timeline because they can change\n    this._history = {}\n\n    // Store the state of the runner\n    this.enabled = true\n    this._time = 0\n    this._lastTime = 0\n\n    // At creation, the runner is in reset state\n    this._reseted = true\n\n    // Save transforms applied to this runner\n    this.transforms = new Matrix()\n    this.transformId = 1\n\n    // Looping variables\n    this._haveReversed = false\n    this._reverse = false\n    this._loopsDone = 0\n    this._swing = false\n    this._wait = 0\n    this._times = 1\n\n    this._frameId = null\n\n    // Stores how long a runner is stored after being done\n    this._persist = this._isDeclarative ? true : null\n  }\n\n  static sanitise(duration, delay, when) {\n    // Initialise the default parameters\n    let times = 1\n    let swing = false\n    let wait = 0\n    duration = duration ?? timeline.duration\n    delay = delay ?? timeline.delay\n    when = when || 'last'\n\n    // If we have an object, unpack the values\n    if (typeof duration === 'object' && !(duration instanceof Stepper)) {\n      delay = duration.delay ?? delay\n      when = duration.when ?? when\n      swing = duration.swing || swing\n      times = duration.times ?? times\n      wait = duration.wait ?? wait\n      duration = duration.duration ?? timeline.duration\n    }\n\n    return {\n      duration: duration,\n      delay: delay,\n      swing: swing,\n      times: times,\n      wait: wait,\n      when: when\n    }\n  }\n\n  active(enabled) {\n    if (enabled == null) return this.enabled\n    this.enabled = enabled\n    return this\n  }\n\n  /*\n  Private Methods\n  ===============\n  Methods that shouldn't be used externally\n  */\n  addTransform(transform) {\n    this.transforms.lmultiplyO(transform)\n    return this\n  }\n\n  after(fn) {\n    return this.on('finished', fn)\n  }\n\n  animate(duration, delay, when) {\n    const o = Runner.sanitise(duration, delay, when)\n    const runner = new Runner(o.duration)\n    if (this._timeline) runner.timeline(this._timeline)\n    if (this._element) runner.element(this._element)\n    return runner.loop(o).schedule(o.delay, o.when)\n  }\n\n  clearTransform() {\n    this.transforms = new Matrix()\n    return this\n  }\n\n  // TODO: Keep track of all transformations so that deletion is faster\n  clearTransformsFromQueue() {\n    if (\n      !this.done ||\n      !this._timeline ||\n      !this._timeline._runnerIds.includes(this.id)\n    ) {\n      this._queue = this._queue.filter((item) => {\n        return !item.isTransform\n      })\n    }\n  }\n\n  delay(delay) {\n    return this.animate(0, delay)\n  }\n\n  duration() {\n    return this._times * (this._wait + this._duration) - this._wait\n  }\n\n  during(fn) {\n    return this.queue(null, fn)\n  }\n\n  ease(fn) {\n    this._stepper = new Ease(fn)\n    return this\n  }\n  /*\n  Runner Definitions\n  ==================\n  These methods help us define the runtime behaviour of the Runner or they\n  help us make new runners from the current runner\n  */\n\n  element(element) {\n    if (element == null) return this._element\n    this._element = element\n    element._prepareRunner()\n    return this\n  }\n\n  finish() {\n    return this.step(Infinity)\n  }\n\n  loop(times, swing, wait) {\n    // Deal with the user passing in an object\n    if (typeof times === 'object') {\n      swing = times.swing\n      wait = times.wait\n      times = times.times\n    }\n\n    // Sanitise the values and store them\n    this._times = times || Infinity\n    this._swing = swing || false\n    this._wait = wait || 0\n\n    // Allow true to be passed\n    if (this._times === true) {\n      this._times = Infinity\n    }\n\n    return this\n  }\n\n  loops(p) {\n    const loopDuration = this._duration + this._wait\n    if (p == null) {\n      const loopsDone = Math.floor(this._time / loopDuration)\n      const relativeTime = this._time - loopsDone * loopDuration\n      const position = relativeTime / this._duration\n      return Math.min(loopsDone + position, this._times)\n    }\n    const whole = Math.floor(p)\n    const partial = p % 1\n    const time = loopDuration * whole + this._duration * partial\n    return this.time(time)\n  }\n\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist\n    this._persist = dtOrForever\n    return this\n  }\n\n  position(p) {\n    // Get all of the variables we need\n    const x = this._time\n    const d = this._duration\n    const w = this._wait\n    const t = this._times\n    const s = this._swing\n    const r = this._reverse\n    let position\n\n    if (p == null) {\n      /*\n      This function converts a time to a position in the range [0, 1]\n      The full explanation can be found in this desmos demonstration\n        https://www.desmos.com/calculator/u4fbavgche\n      The logic is slightly simplified here because we can use booleans\n      */\n\n      // Figure out the value without thinking about the start or end time\n      const f = function (x) {\n        const swinging = s * Math.floor((x % (2 * (w + d))) / (w + d))\n        const backwards = (swinging && !r) || (!swinging && r)\n        const uncliped =\n          (Math.pow(-1, backwards) * (x % (w + d))) / d + backwards\n        const clipped = Math.max(Math.min(uncliped, 1), 0)\n        return clipped\n      }\n\n      // Figure out the value by incorporating the start time\n      const endTime = t * (w + d) - w\n      position =\n        x <= 0\n          ? Math.round(f(1e-5))\n          : x < endTime\n            ? f(x)\n            : Math.round(f(endTime - 1e-5))\n      return position\n    }\n\n    // Work out the loops done and add the position to the loops done\n    const loopsDone = Math.floor(this.loops())\n    const swingForward = s && loopsDone % 2 === 0\n    const forwards = (swingForward && !r) || (r && swingForward)\n    position = loopsDone + (forwards ? p : 1 - p)\n    return this.loops(position)\n  }\n\n  progress(p) {\n    if (p == null) {\n      return Math.min(1, this._time / this.duration())\n    }\n    return this.time(p * this.duration())\n  }\n\n  /*\n  Basic Functionality\n  ===================\n  These methods allow us to attach basic functions to the runner directly\n  */\n  queue(initFn, runFn, retargetFn, isTransform) {\n    this._queue.push({\n      initialiser: initFn || noop,\n      runner: runFn || noop,\n      retarget: retargetFn,\n      isTransform: isTransform,\n      initialised: false,\n      finished: false\n    })\n    const timeline = this.timeline()\n    timeline && this.timeline()._continue()\n    return this\n  }\n\n  reset() {\n    if (this._reseted) return this\n    this.time(0)\n    this._reseted = true\n    return this\n  }\n\n  reverse(reverse) {\n    this._reverse = reverse == null ? !this._reverse : reverse\n    return this\n  }\n\n  schedule(timeline, delay, when) {\n    // The user doesn't need to pass a timeline if we already have one\n    if (!(timeline instanceof Timeline)) {\n      when = delay\n      delay = timeline\n      timeline = this.timeline()\n    }\n\n    // If there is no timeline, yell at the user...\n    if (!timeline) {\n      throw Error('Runner cannot be scheduled without timeline')\n    }\n\n    // Schedule the runner on the timeline provided\n    timeline.schedule(this, delay, when)\n    return this\n  }\n\n  step(dt) {\n    // If we are inactive, this stepper just gets skipped\n    if (!this.enabled) return this\n\n    // Update the time and get the new position\n    dt = dt == null ? 16 : dt\n    this._time += dt\n    const position = this.position()\n\n    // Figure out if we need to run the stepper in this frame\n    const running = this._lastPosition !== position && this._time >= 0\n    this._lastPosition = position\n\n    // Figure out if we just started\n    const duration = this.duration()\n    const justStarted = this._lastTime <= 0 && this._time > 0\n    const justFinished = this._lastTime < duration && this._time >= duration\n\n    this._lastTime = this._time\n    if (justStarted) {\n      this.fire('start', this)\n    }\n\n    // Work out if the runner is finished set the done flag here so animations\n    // know, that they are running in the last step (this is good for\n    // transformations which can be merged)\n    const declarative = this._isDeclarative\n    this.done = !declarative && !justFinished && this._time >= duration\n\n    // Runner is running. So its not in reset state anymore\n    this._reseted = false\n\n    let converged = false\n    // Call initialise and the run function\n    if (running || declarative) {\n      this._initialise(running)\n\n      // clear the transforms on this runner so they dont get added again and again\n      this.transforms = new Matrix()\n      converged = this._run(declarative ? dt : position)\n\n      this.fire('step', this)\n    }\n    // correct the done flag here\n    // declarative animations itself know when they converged\n    this.done = this.done || (converged && declarative)\n    if (justFinished) {\n      this.fire('finished', this)\n    }\n    return this\n  }\n\n  /*\n  Runner animation methods\n  ========================\n  Control how the animation plays\n  */\n  time(time) {\n    if (time == null) {\n      return this._time\n    }\n    const dt = time - this._time\n    this.step(dt)\n    return this\n  }\n\n  timeline(timeline) {\n    // check explicitly for undefined so we can set the timeline to null\n    if (typeof timeline === 'undefined') return this._timeline\n    this._timeline = timeline\n    return this\n  }\n\n  unschedule() {\n    const timeline = this.timeline()\n    timeline && timeline.unschedule(this)\n    return this\n  }\n\n  // Run each initialise function in the runner if required\n  _initialise(running) {\n    // If we aren't running, we shouldn't initialise when not declarative\n    if (!running && !this._isDeclarative) return\n\n    // Loop through all of the initialisers\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current initialiser\n      const current = this._queue[i]\n\n      // Determine whether we need to initialise\n      const needsIt = this._isDeclarative || (!current.initialised && running)\n      running = !current.finished\n\n      // Call the initialiser if we need to\n      if (needsIt && running) {\n        current.initialiser.call(this)\n        current.initialised = true\n      }\n    }\n  }\n\n  // Save a morpher to the morpher list so that we can retarget it later\n  _rememberMorpher(method, morpher) {\n    this._history[method] = {\n      morpher: morpher,\n      caller: this._queue[this._queue.length - 1]\n    }\n\n    // We have to resume the timeline in case a controller\n    // is already done without being ever run\n    // This can happen when e.g. this is done:\n    //    anim = el.animate(new SVG.Spring)\n    // and later\n    //    anim.move(...)\n    if (this._isDeclarative) {\n      const timeline = this.timeline()\n      timeline && timeline.play()\n    }\n  }\n\n  // Try to set the target for a morpher if the morpher exists, otherwise\n  // Run each run function for the position or dt given\n  _run(positionOrDt) {\n    // Run all of the _queue directly\n    let allfinished = true\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current function to run\n      const current = this._queue[i]\n\n      // Run the function if its not finished, we keep track of the finished\n      // flag for the sake of declarative _queue\n      const converged = current.runner.call(this, positionOrDt)\n      current.finished = current.finished || converged === true\n      allfinished = allfinished && current.finished\n    }\n\n    // We report when all of the constructors are finished\n    return allfinished\n  }\n\n  // do nothing and return false\n  _tryRetarget(method, target, extra) {\n    if (this._history[method]) {\n      // if the last method wasn't even initialised, throw it away\n      if (!this._history[method].caller.initialised) {\n        const index = this._queue.indexOf(this._history[method].caller)\n        this._queue.splice(index, 1)\n        return false\n      }\n\n      // for the case of transformations, we use the special retarget function\n      // which has access to the outer scope\n      if (this._history[method].caller.retarget) {\n        this._history[method].caller.retarget.call(this, target, extra)\n        // for everything else a simple morpher change is sufficient\n      } else {\n        this._history[method].morpher.to(target)\n      }\n\n      this._history[method].caller.finished = false\n      const timeline = this.timeline()\n      timeline && timeline.play()\n      return true\n    }\n    return false\n  }\n}\n\nRunner.id = 0\n\nexport class FakeRunner {\n  constructor(transforms = new Matrix(), id = -1, done = true) {\n    this.transforms = transforms\n    this.id = id\n    this.done = done\n  }\n\n  clearTransformsFromQueue() {}\n}\n\nextend([Runner, FakeRunner], {\n  mergeWith(runner) {\n    return new FakeRunner(\n      runner.transforms.lmultiply(this.transforms),\n      runner.id\n    )\n  }\n})\n\n// FakeRunner.emptyRunner = new FakeRunner()\n\nconst lmultiply = (last, curr) => last.lmultiplyO(curr)\nconst getRunnerTransform = (runner) => runner.transforms\n\nfunction mergeTransforms() {\n  // Find the matrix to apply to the element and apply it\n  const runners = this._transformationRunners.runners\n  const netTransform = runners\n    .map(getRunnerTransform)\n    .reduce(lmultiply, new Matrix())\n\n  this.transform(netTransform)\n\n  this._transformationRunners.merge()\n\n  if (this._transformationRunners.length() === 1) {\n    this._frameId = null\n  }\n}\n\nexport class RunnerArray {\n  constructor() {\n    this.runners = []\n    this.ids = []\n  }\n\n  add(runner) {\n    if (this.runners.includes(runner)) return\n    const id = runner.id + 1\n\n    this.runners.push(runner)\n    this.ids.push(id)\n\n    return this\n  }\n\n  clearBefore(id) {\n    const deleteCnt = this.ids.indexOf(id + 1) || 1\n    this.ids.splice(0, deleteCnt, 0)\n    this.runners\n      .splice(0, deleteCnt, new FakeRunner())\n      .forEach((r) => r.clearTransformsFromQueue())\n    return this\n  }\n\n  edit(id, newRunner) {\n    const index = this.ids.indexOf(id + 1)\n    this.ids.splice(index, 1, id + 1)\n    this.runners.splice(index, 1, newRunner)\n    return this\n  }\n\n  getByID(id) {\n    return this.runners[this.ids.indexOf(id + 1)]\n  }\n\n  length() {\n    return this.ids.length\n  }\n\n  merge() {\n    let lastRunner = null\n    for (let i = 0; i < this.runners.length; ++i) {\n      const runner = this.runners[i]\n\n      const condition =\n        lastRunner &&\n        runner.done &&\n        lastRunner.done &&\n        // don't merge runner when persisted on timeline\n        (!runner._timeline ||\n          !runner._timeline._runnerIds.includes(runner.id)) &&\n        (!lastRunner._timeline ||\n          !lastRunner._timeline._runnerIds.includes(lastRunner.id))\n\n      if (condition) {\n        // the +1 happens in the function\n        this.remove(runner.id)\n        const newRunner = runner.mergeWith(lastRunner)\n        this.edit(lastRunner.id, newRunner)\n        lastRunner = newRunner\n        --i\n      } else {\n        lastRunner = runner\n      }\n    }\n\n    return this\n  }\n\n  remove(id) {\n    const index = this.ids.indexOf(id + 1)\n    this.ids.splice(index, 1)\n    this.runners.splice(index, 1)\n    return this\n  }\n}\n\nregisterMethods({\n  Element: {\n    animate(duration, delay, when) {\n      const o = Runner.sanitise(duration, delay, when)\n      const timeline = this.timeline()\n      return new Runner(o.duration)\n        .loop(o)\n        .element(this)\n        .timeline(timeline.play())\n        .schedule(o.delay, o.when)\n    },\n\n    delay(by, when) {\n      return this.animate(0, by, when)\n    },\n\n    // this function searches for all runners on the element and deletes the ones\n    // which run before the current one. This is because absolute transformations\n    // overwrite anything anyway so there is no need to waste time computing\n    // other runners\n    _clearTransformRunnersBefore(currentRunner) {\n      this._transformationRunners.clearBefore(currentRunner.id)\n    },\n\n    _currentTransform(current) {\n      return (\n        this._transformationRunners.runners\n          // we need the equal sign here to make sure, that also transformations\n          // on the same runner which execute before the current transformation are\n          // taken into account\n          .filter((runner) => runner.id <= current.id)\n          .map(getRunnerTransform)\n          .reduce(lmultiply, new Matrix())\n      )\n    },\n\n    _addRunner(runner) {\n      this._transformationRunners.add(runner)\n\n      // Make sure that the runner merge is executed at the very end of\n      // all Animator functions. That is why we use immediate here to execute\n      // the merge right after all frames are run\n      Animator.cancelImmediate(this._frameId)\n      this._frameId = Animator.immediate(mergeTransforms.bind(this))\n    },\n\n    _prepareRunner() {\n      if (this._frameId == null) {\n        this._transformationRunners = new RunnerArray().add(\n          new FakeRunner(new Matrix(this))\n        )\n      }\n    }\n  }\n})\n\n// Will output the elements from array A that are not in the array B\nconst difference = (a, b) => a.filter((x) => !b.includes(x))\n\nextend(Runner, {\n  attr(a, v) {\n    return this.styleAttr('attr', a, v)\n  },\n\n  // Add animatable styles\n  css(s, v) {\n    return this.styleAttr('css', s, v)\n  },\n\n  styleAttr(type, nameOrAttrs, val) {\n    if (typeof nameOrAttrs === 'string') {\n      return this.styleAttr(type, { [nameOrAttrs]: val })\n    }\n\n    let attrs = nameOrAttrs\n    if (this._tryRetarget(type, attrs)) return this\n\n    let morpher = new Morphable(this._stepper).to(attrs)\n    let keys = Object.keys(attrs)\n\n    this.queue(\n      function () {\n        morpher = morpher.from(this.element()[type](keys))\n      },\n      function (pos) {\n        this.element()[type](morpher.at(pos).valueOf())\n        return morpher.done()\n      },\n      function (newToAttrs) {\n        // Check if any new keys were added\n        const newKeys = Object.keys(newToAttrs)\n        const differences = difference(newKeys, keys)\n\n        // If their are new keys, initialize them and add them to morpher\n        if (differences.length) {\n          // Get the values\n          const addedFromAttrs = this.element()[type](differences)\n\n          // Get the already initialized values\n          const oldFromAttrs = new ObjectBag(morpher.from()).valueOf()\n\n          // Merge old and new\n          Object.assign(oldFromAttrs, addedFromAttrs)\n          morpher.from(oldFromAttrs)\n        }\n\n        // Get the object from the morpher\n        const oldToAttrs = new ObjectBag(morpher.to()).valueOf()\n\n        // Merge in new attributes\n        Object.assign(oldToAttrs, newToAttrs)\n\n        // Change morpher target\n        morpher.to(oldToAttrs)\n\n        // Make sure that we save the work we did so we don't need it to do again\n        keys = newKeys\n        attrs = newToAttrs\n      }\n    )\n\n    this._rememberMorpher(type, morpher)\n    return this\n  },\n\n  zoom(level, point) {\n    if (this._tryRetarget('zoom', level, point)) return this\n\n    let morpher = new Morphable(this._stepper).to(new SVGNumber(level))\n\n    this.queue(\n      function () {\n        morpher = morpher.from(this.element().zoom())\n      },\n      function (pos) {\n        this.element().zoom(morpher.at(pos), point)\n        return morpher.done()\n      },\n      function (newLevel, newPoint) {\n        point = newPoint\n        morpher.to(newLevel)\n      }\n    )\n\n    this._rememberMorpher('zoom', morpher)\n    return this\n  },\n\n  /**\n   ** absolute transformations\n   **/\n\n  //\n  // M v -----|-----(D M v = F v)------|----->  T v\n  //\n  // 1. define the final state (T) and decompose it (once)\n  //    t = [tx, ty, the, lam, sy, sx]\n  // 2. on every frame: pull the current state of all previous transforms\n  //    (M - m can change)\n  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]\n  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)\n  //   - Note F(0) = M\n  //   - Note F(1) = T\n  // 4. Now you get the delta matrix as a result: D = F * inv(M)\n\n  transform(transforms, relative, affine) {\n    // If we have a declarative function, we should retarget it if possible\n    relative = transforms.relative || relative\n    if (\n      this._isDeclarative &&\n      !relative &&\n      this._tryRetarget('transform', transforms)\n    ) {\n      return this\n    }\n\n    // Parse the parameters\n    const isMatrix = Matrix.isMatrixLike(transforms)\n    affine =\n      transforms.affine != null\n        ? transforms.affine\n        : affine != null\n          ? affine\n          : !isMatrix\n\n    // Create a morpher and set its type\n    const morpher = new Morphable(this._stepper).type(\n      affine ? TransformBag : Matrix\n    )\n\n    let origin\n    let element\n    let current\n    let currentAngle\n    let startTransform\n\n    function setup() {\n      // make sure element and origin is defined\n      element = element || this.element()\n      origin = origin || getOrigin(transforms, element)\n\n      startTransform = new Matrix(relative ? undefined : element)\n\n      // add the runner to the element so it can merge transformations\n      element._addRunner(this)\n\n      // Deactivate all transforms that have run so far if we are absolute\n      if (!relative) {\n        element._clearTransformRunnersBefore(this)\n      }\n    }\n\n    function run(pos) {\n      // clear all other transforms before this in case something is saved\n      // on this runner. We are absolute. We dont need these!\n      if (!relative) this.clearTransform()\n\n      const { x, y } = new Point(origin).transform(\n        element._currentTransform(this)\n      )\n\n      let target = new Matrix({ ...transforms, origin: [x, y] })\n      let start = this._isDeclarative && current ? current : startTransform\n\n      if (affine) {\n        target = target.decompose(x, y)\n        start = start.decompose(x, y)\n\n        // Get the current and target angle as it was set\n        const rTarget = target.rotate\n        const rCurrent = start.rotate\n\n        // Figure out the shortest path to rotate directly\n        const possibilities = [rTarget - 360, rTarget, rTarget + 360]\n        const distances = possibilities.map((a) => Math.abs(a - rCurrent))\n        const shortest = Math.min(...distances)\n        const index = distances.indexOf(shortest)\n        target.rotate = possibilities[index]\n      }\n\n      if (relative) {\n        // we have to be careful here not to overwrite the rotation\n        // with the rotate method of Matrix\n        if (!isMatrix) {\n          target.rotate = transforms.rotate || 0\n        }\n        if (this._isDeclarative && currentAngle) {\n          start.rotate = currentAngle\n        }\n      }\n\n      morpher.from(start)\n      morpher.to(target)\n\n      const affineParameters = morpher.at(pos)\n      currentAngle = affineParameters.rotate\n      current = new Matrix(affineParameters)\n\n      this.addTransform(current)\n      element._addRunner(this)\n      return morpher.done()\n    }\n\n    function retarget(newTransforms) {\n      // only get a new origin if it changed since the last call\n      if (\n        (newTransforms.origin || 'center').toString() !==\n        (transforms.origin || 'center').toString()\n      ) {\n        origin = getOrigin(newTransforms, element)\n      }\n\n      // overwrite the old transformations with the new ones\n      transforms = { ...newTransforms, origin }\n    }\n\n    this.queue(setup, run, retarget, true)\n    this._isDeclarative && this._rememberMorpher('transform', morpher)\n    return this\n  },\n\n  // Animatable x-axis\n  x(x) {\n    return this._queueNumber('x', x)\n  },\n\n  // Animatable y-axis\n  y(y) {\n    return this._queueNumber('y', y)\n  },\n\n  ax(x) {\n    return this._queueNumber('ax', x)\n  },\n\n  ay(y) {\n    return this._queueNumber('ay', y)\n  },\n\n  dx(x = 0) {\n    return this._queueNumberDelta('x', x)\n  },\n\n  dy(y = 0) {\n    return this._queueNumberDelta('y', y)\n  },\n\n  dmove(x, y) {\n    return this.dx(x).dy(y)\n  },\n\n  _queueNumberDelta(method, to) {\n    to = new SVGNumber(to)\n\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to)\n    let from = null\n    this.queue(\n      function () {\n        from = this.element()[method]()\n        morpher.from(from)\n        morpher.to(from + to)\n      },\n      function (pos) {\n        this.element()[method](morpher.at(pos))\n        return morpher.done()\n      },\n      function (newTo) {\n        morpher.to(from + new SVGNumber(newTo))\n      }\n    )\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher)\n    return this\n  },\n\n  _queueObject(method, to) {\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to)\n    this.queue(\n      function () {\n        morpher.from(this.element()[method]())\n      },\n      function (pos) {\n        this.element()[method](morpher.at(pos))\n        return morpher.done()\n      }\n    )\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher)\n    return this\n  },\n\n  _queueNumber(method, value) {\n    return this._queueObject(method, new SVGNumber(value))\n  },\n\n  // Animatable center x-axis\n  cx(x) {\n    return this._queueNumber('cx', x)\n  },\n\n  // Animatable center y-axis\n  cy(y) {\n    return this._queueNumber('cy', y)\n  },\n\n  // Add animatable move\n  move(x, y) {\n    return this.x(x).y(y)\n  },\n\n  amove(x, y) {\n    return this.ax(x).ay(y)\n  },\n\n  // Add animatable center\n  center(x, y) {\n    return this.cx(x).cy(y)\n  },\n\n  // Add animatable size\n  size(width, height) {\n    // animate bbox based size for all other elements\n    let box\n\n    if (!width || !height) {\n      box = this._element.bbox()\n    }\n\n    if (!width) {\n      width = (box.width / box.height) * height\n    }\n\n    if (!height) {\n      height = (box.height / box.width) * width\n    }\n\n    return this.width(width).height(height)\n  },\n\n  // Add animatable width\n  width(width) {\n    return this._queueNumber('width', width)\n  },\n\n  // Add animatable height\n  height(height) {\n    return this._queueNumber('height', height)\n  },\n\n  // Add animatable plot\n  plot(a, b, c, d) {\n    // Lines can be plotted with 4 arguments\n    if (arguments.length === 4) {\n      return this.plot([a, b, c, d])\n    }\n\n    if (this._tryRetarget('plot', a)) return this\n\n    const morpher = new Morphable(this._stepper)\n      .type(this._element.MorphArray)\n      .to(a)\n\n    this.queue(\n      function () {\n        morpher.from(this._element.array())\n      },\n      function (pos) {\n        this._element.plot(morpher.at(pos))\n        return morpher.done()\n      }\n    )\n\n    this._rememberMorpher('plot', morpher)\n    return this\n  },\n\n  // Add leading method\n  leading(value) {\n    return this._queueNumber('leading', value)\n  },\n\n  // Add animatable viewbox\n  viewbox(x, y, width, height) {\n    return this._queueObject('viewbox', new Box(x, y, width, height))\n  },\n\n  update(o) {\n    if (typeof o !== 'object') {\n      return this.update({\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      })\n    }\n\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity)\n    if (o.color != null) this.attr('stop-color', o.color)\n    if (o.offset != null) this.attr('offset', o.offset)\n\n    return this\n  }\n})\n\nextend(Runner, { rx, ry, from, to })\nregister(Runner, 'Runner')\n"],"mappings":";AAAA,SAASA,UAAU,EAAEC,IAAI,EAAEC,OAAO,QAAQ,iBAAiB;AAC3D,SAASC,MAAM,EAAEC,QAAQ,QAAQ,qBAAqB;AACtD,SAASC,IAAI,EAAEC,EAAE,QAAQ,+BAA+B;AACxD,SAASC,SAAS,QAAQ,mBAAmB;AAC7C,SAASC,IAAI,EAAEC,QAAQ,QAAQ,6BAA6B;AAC5D,SAASC,eAAe,QAAQ,qBAAqB;AACrD,SAASC,EAAE,EAAEC,EAAE,QAAQ,4BAA4B;AACnD,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,GAAG,MAAM,iBAAiB;AACjC,OAAOC,WAAW,MAAM,yBAAyB;AACjD,OAAOC,MAAM,MAAM,oBAAoB;AACvC,OAAOC,SAAS,IAAIC,YAAY,EAAEC,SAAS,QAAQ,gBAAgB;AACnE,OAAOC,KAAK,MAAM,mBAAmB;AACrC,OAAOC,SAAS,MAAM,uBAAuB;AAC7C,OAAOC,QAAQ,MAAM,eAAe;AAEpC,eAAe,MAAMC,MAAM,SAASR,WAAW,CAAC;EAC9CS,WAAWA,CAACC,OAAO,EAAE;IACnB,KAAK,CAAC,CAAC;;IAEP;IACA,IAAI,CAACC,EAAE,GAAGH,MAAM,CAACG,EAAE,EAAE;;IAErB;IACAD,OAAO,GAAGA,OAAO,IAAI,IAAI,GAAGhB,QAAQ,CAACkB,QAAQ,GAAGF,OAAO;;IAEvD;IACAA,OAAO,GAAG,OAAOA,OAAO,KAAK,UAAU,GAAG,IAAIzB,UAAU,CAACyB,OAAO,CAAC,GAAGA,OAAO;;IAE3E;IACA,IAAI,CAACG,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,IAAI,GAAG,KAAK;IACjB,IAAI,CAACC,MAAM,GAAG,EAAE;;IAEhB;IACA,IAAI,CAACC,SAAS,GAAG,OAAOP,OAAO,KAAK,QAAQ,IAAIA,OAAO;IACvD,IAAI,CAACQ,cAAc,GAAGR,OAAO,YAAYzB,UAAU;IACnD,IAAI,CAACkC,QAAQ,GAAG,IAAI,CAACD,cAAc,GAAGR,OAAO,GAAG,IAAIxB,IAAI,CAAC,CAAC;;IAE1D;IACA,IAAI,CAACkC,QAAQ,GAAG,CAAC,CAAC;;IAElB;IACA,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,SAAS,GAAG,CAAC;;IAElB;IACA,IAAI,CAACC,QAAQ,GAAG,IAAI;;IAEpB;IACA,IAAI,CAACC,UAAU,GAAG,IAAIxB,MAAM,CAAC,CAAC;IAC9B,IAAI,CAACyB,WAAW,GAAG,CAAC;;IAEpB;IACA,IAAI,CAACC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,IAAI,CAACC,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,MAAM,GAAG,CAAC;IAEf,IAAI,CAACC,QAAQ,GAAG,IAAI;;IAEpB;IACA,IAAI,CAACC,QAAQ,GAAG,IAAI,CAAChB,cAAc,GAAG,IAAI,GAAG,IAAI;EACnD;EAEA,OAAOiB,QAAQA,CAACvB,QAAQ,EAAEwB,KAAK,EAAEC,IAAI,EAAE;IACrC;IACA,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,KAAK,GAAG,KAAK;IACjB,IAAIC,IAAI,GAAG,CAAC;IACZ5B,QAAQ,GAAGA,QAAQ,IAAIlB,QAAQ,CAACkB,QAAQ;IACxCwB,KAAK,GAAGA,KAAK,IAAI1C,QAAQ,CAAC0C,KAAK;IAC/BC,IAAI,GAAGA,IAAI,IAAI,MAAM;;IAErB;IACA,IAAI,OAAOzB,QAAQ,KAAK,QAAQ,IAAI,EAAEA,QAAQ,YAAYzB,OAAO,CAAC,EAAE;MAClEiD,KAAK,GAAGxB,QAAQ,CAACwB,KAAK,IAAIA,KAAK;MAC/BC,IAAI,GAAGzB,QAAQ,CAACyB,IAAI,IAAIA,IAAI;MAC5BE,KAAK,GAAG3B,QAAQ,CAAC2B,KAAK,IAAIA,KAAK;MAC/BD,KAAK,GAAG1B,QAAQ,CAAC0B,KAAK,IAAIA,KAAK;MAC/BE,IAAI,GAAG5B,QAAQ,CAAC4B,IAAI,IAAIA,IAAI;MAC5B5B,QAAQ,GAAGA,QAAQ,CAACA,QAAQ,IAAIlB,QAAQ,CAACkB,QAAQ;IACnD;IAEA,OAAO;MACLA,QAAQ,EAAEA,QAAQ;MAClBwB,KAAK,EAAEA,KAAK;MACZG,KAAK,EAAEA,KAAK;MACZD,KAAK,EAAEA,KAAK;MACZE,IAAI,EAAEA,IAAI;MACVH,IAAI,EAAEA;IACR,CAAC;EACH;EAEAI,MAAMA,CAACpB,OAAO,EAAE;IACd,IAAIA,OAAO,IAAI,IAAI,EAAE,OAAO,IAAI,CAACA,OAAO;IACxC,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEqB,YAAYA,CAACC,SAAS,EAAE;IACtB,IAAI,CAAClB,UAAU,CAACmB,UAAU,CAACD,SAAS,CAAC;IACrC,OAAO,IAAI;EACb;EAEAE,KAAKA,CAACC,EAAE,EAAE;IACR,OAAO,IAAI,CAACC,EAAE,CAAC,UAAU,EAAED,EAAE,CAAC;EAChC;EAEAE,OAAOA,CAACpC,QAAQ,EAAEwB,KAAK,EAAEC,IAAI,EAAE;IAC7B,MAAMY,CAAC,GAAGzC,MAAM,CAAC2B,QAAQ,CAACvB,QAAQ,EAAEwB,KAAK,EAAEC,IAAI,CAAC;IAChD,MAAMa,MAAM,GAAG,IAAI1C,MAAM,CAACyC,CAAC,CAACrC,QAAQ,CAAC;IACrC,IAAI,IAAI,CAACE,SAAS,EAAEoC,MAAM,CAACxD,QAAQ,CAAC,IAAI,CAACoB,SAAS,CAAC;IACnD,IAAI,IAAI,CAACD,QAAQ,EAAEqC,MAAM,CAACC,OAAO,CAAC,IAAI,CAACtC,QAAQ,CAAC;IAChD,OAAOqC,MAAM,CAACE,IAAI,CAACH,CAAC,CAAC,CAACI,QAAQ,CAACJ,CAAC,CAACb,KAAK,EAAEa,CAAC,CAACZ,IAAI,CAAC;EACjD;EAEAiB,cAAcA,CAAA,EAAG;IACf,IAAI,CAAC7B,UAAU,GAAG,IAAIxB,MAAM,CAAC,CAAC;IAC9B,OAAO,IAAI;EACb;;EAEA;EACAsD,wBAAwBA,CAAA,EAAG;IACzB,IACE,CAAC,IAAI,CAACxC,IAAI,IACV,CAAC,IAAI,CAACD,SAAS,IACf,CAAC,IAAI,CAACA,SAAS,CAAC0C,UAAU,CAACC,QAAQ,CAAC,IAAI,CAAC9C,EAAE,CAAC,EAC5C;MACA,IAAI,CAACK,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC0C,MAAM,CAAEC,IAAI,IAAK;QACzC,OAAO,CAACA,IAAI,CAACC,WAAW;MAC1B,CAAC,CAAC;IACJ;EACF;EAEAxB,KAAKA,CAACA,KAAK,EAAE;IACX,OAAO,IAAI,CAACY,OAAO,CAAC,CAAC,EAAEZ,KAAK,CAAC;EAC/B;EAEAxB,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACoB,MAAM,IAAI,IAAI,CAACD,KAAK,GAAG,IAAI,CAACd,SAAS,CAAC,GAAG,IAAI,CAACc,KAAK;EACjE;EAEA8B,MAAMA,CAACf,EAAE,EAAE;IACT,OAAO,IAAI,CAACgB,KAAK,CAAC,IAAI,EAAEhB,EAAE,CAAC;EAC7B;EAEAiB,IAAIA,CAACjB,EAAE,EAAE;IACP,IAAI,CAAC3B,QAAQ,GAAG,IAAIjC,IAAI,CAAC4D,EAAE,CAAC;IAC5B,OAAO,IAAI;EACb;EACA;AACF;AACA;AACA;AACA;AACA;;EAEEK,OAAOA,CAACA,OAAO,EAAE;IACf,IAAIA,OAAO,IAAI,IAAI,EAAE,OAAO,IAAI,CAACtC,QAAQ;IACzC,IAAI,CAACA,QAAQ,GAAGsC,OAAO;IACvBA,OAAO,CAACa,cAAc,CAAC,CAAC;IACxB,OAAO,IAAI;EACb;EAEAC,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI,CAACC,IAAI,CAACC,QAAQ,CAAC;EAC5B;EAEAf,IAAIA,CAACd,KAAK,EAAEC,KAAK,EAAEC,IAAI,EAAE;IACvB;IACA,IAAI,OAAOF,KAAK,KAAK,QAAQ,EAAE;MAC7BC,KAAK,GAAGD,KAAK,CAACC,KAAK;MACnBC,IAAI,GAAGF,KAAK,CAACE,IAAI;MACjBF,KAAK,GAAGA,KAAK,CAACA,KAAK;IACrB;;IAEA;IACA,IAAI,CAACN,MAAM,GAAGM,KAAK,IAAI6B,QAAQ;IAC/B,IAAI,CAACrC,MAAM,GAAGS,KAAK,IAAI,KAAK;IAC5B,IAAI,CAACR,KAAK,GAAGS,IAAI,IAAI,CAAC;;IAEtB;IACA,IAAI,IAAI,CAACR,MAAM,KAAK,IAAI,EAAE;MACxB,IAAI,CAACA,MAAM,GAAGmC,QAAQ;IACxB;IAEA,OAAO,IAAI;EACb;EAEAC,KAAKA,CAACC,CAAC,EAAE;IACP,MAAMC,YAAY,GAAG,IAAI,CAACrD,SAAS,GAAG,IAAI,CAACc,KAAK;IAChD,IAAIsC,CAAC,IAAI,IAAI,EAAE;MACb,MAAME,SAAS,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACnD,KAAK,GAAGgD,YAAY,CAAC;MACvD,MAAMI,YAAY,GAAG,IAAI,CAACpD,KAAK,GAAGiD,SAAS,GAAGD,YAAY;MAC1D,MAAMK,QAAQ,GAAGD,YAAY,GAAG,IAAI,CAACzD,SAAS;MAC9C,OAAOuD,IAAI,CAACI,GAAG,CAACL,SAAS,GAAGI,QAAQ,EAAE,IAAI,CAAC3C,MAAM,CAAC;IACpD;IACA,MAAM6C,KAAK,GAAGL,IAAI,CAACC,KAAK,CAACJ,CAAC,CAAC;IAC3B,MAAMS,OAAO,GAAGT,CAAC,GAAG,CAAC;IACrB,MAAMU,IAAI,GAAGT,YAAY,GAAGO,KAAK,GAAG,IAAI,CAAC5D,SAAS,GAAG6D,OAAO;IAC5D,OAAO,IAAI,CAACC,IAAI,CAACA,IAAI,CAAC;EACxB;EAEAC,OAAOA,CAACC,WAAW,EAAE;IACnB,IAAIA,WAAW,IAAI,IAAI,EAAE,OAAO,IAAI,CAAC/C,QAAQ;IAC7C,IAAI,CAACA,QAAQ,GAAG+C,WAAW;IAC3B,OAAO,IAAI;EACb;EAEAN,QAAQA,CAACN,CAAC,EAAE;IACV;IACA,MAAMa,CAAC,GAAG,IAAI,CAAC5D,KAAK;IACpB,MAAM6D,CAAC,GAAG,IAAI,CAAClE,SAAS;IACxB,MAAMmE,CAAC,GAAG,IAAI,CAACrD,KAAK;IACpB,MAAMsD,CAAC,GAAG,IAAI,CAACrD,MAAM;IACrB,MAAMsD,CAAC,GAAG,IAAI,CAACxD,MAAM;IACrB,MAAMyD,CAAC,GAAG,IAAI,CAAC3D,QAAQ;IACvB,IAAI+C,QAAQ;IAEZ,IAAIN,CAAC,IAAI,IAAI,EAAE;MACb;AACN;AACA;AACA;AACA;AACA;;MAEM;MACA,MAAMmB,CAAC,GAAG,SAAAA,CAAUN,CAAC,EAAE;QACrB,MAAMO,QAAQ,GAAGH,CAAC,GAAGd,IAAI,CAACC,KAAK,CAAES,CAAC,IAAI,CAAC,IAAIE,CAAC,GAAGD,CAAC,CAAC,CAAC,IAAKC,CAAC,GAAGD,CAAC,CAAC,CAAC;QAC9D,MAAMO,SAAS,GAAID,QAAQ,IAAI,CAACF,CAAC,IAAM,CAACE,QAAQ,IAAIF,CAAE;QACtD,MAAMI,QAAQ,GACXnB,IAAI,CAACoB,GAAG,CAAC,CAAC,CAAC,EAAEF,SAAS,CAAC,IAAIR,CAAC,IAAIE,CAAC,GAAGD,CAAC,CAAC,CAAC,GAAIA,CAAC,GAAGO,SAAS;QAC3D,MAAMG,OAAO,GAAGrB,IAAI,CAACsB,GAAG,CAACtB,IAAI,CAACI,GAAG,CAACe,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;QAClD,OAAOE,OAAO;MAChB,CAAC;;MAED;MACA,MAAME,OAAO,GAAGV,CAAC,IAAID,CAAC,GAAGD,CAAC,CAAC,GAAGC,CAAC;MAC/BT,QAAQ,GACNO,CAAC,IAAI,CAAC,GACFV,IAAI,CAACwB,KAAK,CAACR,CAAC,CAAC,IAAI,CAAC,CAAC,GACnBN,CAAC,GAAGa,OAAO,GACTP,CAAC,CAACN,CAAC,CAAC,GACJV,IAAI,CAACwB,KAAK,CAACR,CAAC,CAACO,OAAO,GAAG,IAAI,CAAC,CAAC;MACrC,OAAOpB,QAAQ;IACjB;;IAEA;IACA,MAAMJ,SAAS,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACL,KAAK,CAAC,CAAC,CAAC;IAC1C,MAAM6B,YAAY,GAAGX,CAAC,IAAIf,SAAS,GAAG,CAAC,KAAK,CAAC;IAC7C,MAAM2B,QAAQ,GAAID,YAAY,IAAI,CAACV,CAAC,IAAMA,CAAC,IAAIU,YAAa;IAC5DtB,QAAQ,GAAGJ,SAAS,IAAI2B,QAAQ,GAAG7B,CAAC,GAAG,CAAC,GAAGA,CAAC,CAAC;IAC7C,OAAO,IAAI,CAACD,KAAK,CAACO,QAAQ,CAAC;EAC7B;EAEAwB,QAAQA,CAAC9B,CAAC,EAAE;IACV,IAAIA,CAAC,IAAI,IAAI,EAAE;MACb,OAAOG,IAAI,CAACI,GAAG,CAAC,CAAC,EAAE,IAAI,CAACtD,KAAK,GAAG,IAAI,CAACV,QAAQ,CAAC,CAAC,CAAC;IAClD;IACA,OAAO,IAAI,CAACmE,IAAI,CAACV,CAAC,GAAG,IAAI,CAACzD,QAAQ,CAAC,CAAC,CAAC;EACvC;;EAEA;AACF;AACA;AACA;AACA;EACEkD,KAAKA,CAACsC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE1C,WAAW,EAAE;IAC5C,IAAI,CAAC5C,MAAM,CAACuF,IAAI,CAAC;MACfC,WAAW,EAAEJ,MAAM,IAAI3G,IAAI;MAC3ByD,MAAM,EAAEmD,KAAK,IAAI5G,IAAI;MACrBgH,QAAQ,EAAEH,UAAU;MACpB1C,WAAW,EAAEA,WAAW;MACxB8C,WAAW,EAAE,KAAK;MAClBC,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,MAAMjH,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;IAChCA,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAAC,CAAC,CAACkH,SAAS,CAAC,CAAC;IACvC,OAAO,IAAI;EACb;EAEAC,KAAKA,CAAA,EAAG;IACN,IAAI,IAAI,CAACrF,QAAQ,EAAE,OAAO,IAAI;IAC9B,IAAI,CAACuD,IAAI,CAAC,CAAC,CAAC;IACZ,IAAI,CAACvD,QAAQ,GAAG,IAAI;IACpB,OAAO,IAAI;EACb;EAEAsF,OAAOA,CAACA,OAAO,EAAE;IACf,IAAI,CAAClF,QAAQ,GAAGkF,OAAO,IAAI,IAAI,GAAG,CAAC,IAAI,CAAClF,QAAQ,GAAGkF,OAAO;IAC1D,OAAO,IAAI;EACb;EAEAzD,QAAQA,CAAC3D,QAAQ,EAAE0C,KAAK,EAAEC,IAAI,EAAE;IAC9B;IACA,IAAI,EAAE3C,QAAQ,YAAYa,QAAQ,CAAC,EAAE;MACnC8B,IAAI,GAAGD,KAAK;MACZA,KAAK,GAAG1C,QAAQ;MAChBA,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;IAC5B;;IAEA;IACA,IAAI,CAACA,QAAQ,EAAE;MACb,MAAMqH,KAAK,CAAC,6CAA6C,CAAC;IAC5D;;IAEA;IACArH,QAAQ,CAAC2D,QAAQ,CAAC,IAAI,EAAEjB,KAAK,EAAEC,IAAI,CAAC;IACpC,OAAO,IAAI;EACb;EAEA6B,IAAIA,CAAC8C,EAAE,EAAE;IACP;IACA,IAAI,CAAC,IAAI,CAAC3F,OAAO,EAAE,OAAO,IAAI;;IAE9B;IACA2F,EAAE,GAAGA,EAAE,IAAI,IAAI,GAAG,EAAE,GAAGA,EAAE;IACzB,IAAI,CAAC1F,KAAK,IAAI0F,EAAE;IAChB,MAAMrC,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;;IAEhC;IACA,MAAMsC,OAAO,GAAG,IAAI,CAACC,aAAa,KAAKvC,QAAQ,IAAI,IAAI,CAACrD,KAAK,IAAI,CAAC;IAClE,IAAI,CAAC4F,aAAa,GAAGvC,QAAQ;;IAE7B;IACA,MAAM/D,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;IAChC,MAAMuG,WAAW,GAAG,IAAI,CAAC5F,SAAS,IAAI,CAAC,IAAI,IAAI,CAACD,KAAK,GAAG,CAAC;IACzD,MAAM8F,YAAY,GAAG,IAAI,CAAC7F,SAAS,GAAGX,QAAQ,IAAI,IAAI,CAACU,KAAK,IAAIV,QAAQ;IAExE,IAAI,CAACW,SAAS,GAAG,IAAI,CAACD,KAAK;IAC3B,IAAI6F,WAAW,EAAE;MACf,IAAI,CAACE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC;IAC1B;;IAEA;IACA;IACA;IACA,MAAMC,WAAW,GAAG,IAAI,CAACpG,cAAc;IACvC,IAAI,CAACH,IAAI,GAAG,CAACuG,WAAW,IAAI,CAACF,YAAY,IAAI,IAAI,CAAC9F,KAAK,IAAIV,QAAQ;;IAEnE;IACA,IAAI,CAACY,QAAQ,GAAG,KAAK;IAErB,IAAI+F,SAAS,GAAG,KAAK;IACrB;IACA,IAAIN,OAAO,IAAIK,WAAW,EAAE;MAC1B,IAAI,CAACE,WAAW,CAACP,OAAO,CAAC;;MAEzB;MACA,IAAI,CAACxF,UAAU,GAAG,IAAIxB,MAAM,CAAC,CAAC;MAC9BsH,SAAS,GAAG,IAAI,CAACE,IAAI,CAACH,WAAW,GAAGN,EAAE,GAAGrC,QAAQ,CAAC;MAElD,IAAI,CAAC0C,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;IACzB;IACA;IACA;IACA,IAAI,CAACtG,IAAI,GAAG,IAAI,CAACA,IAAI,IAAKwG,SAAS,IAAID,WAAY;IACnD,IAAIF,YAAY,EAAE;MAChB,IAAI,CAACC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC;IAC7B;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;EACEtC,IAAIA,CAACA,IAAI,EAAE;IACT,IAAIA,IAAI,IAAI,IAAI,EAAE;MAChB,OAAO,IAAI,CAACzD,KAAK;IACnB;IACA,MAAM0F,EAAE,GAAGjC,IAAI,GAAG,IAAI,CAACzD,KAAK;IAC5B,IAAI,CAAC4C,IAAI,CAAC8C,EAAE,CAAC;IACb,OAAO,IAAI;EACb;EAEAtH,QAAQA,CAACA,QAAQ,EAAE;IACjB;IACA,IAAI,OAAOA,QAAQ,KAAK,WAAW,EAAE,OAAO,IAAI,CAACoB,SAAS;IAC1D,IAAI,CAACA,SAAS,GAAGpB,QAAQ;IACzB,OAAO,IAAI;EACb;EAEAgI,UAAUA,CAAA,EAAG;IACX,MAAMhI,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;IAChCA,QAAQ,IAAIA,QAAQ,CAACgI,UAAU,CAAC,IAAI,CAAC;IACrC,OAAO,IAAI;EACb;;EAEA;EACAF,WAAWA,CAACP,OAAO,EAAE;IACnB;IACA,IAAI,CAACA,OAAO,IAAI,CAAC,IAAI,CAAC/F,cAAc,EAAE;;IAEtC;IACA,KAAK,IAAIyG,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAC5G,MAAM,CAAC6G,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAE,EAAED,CAAC,EAAE;MACtD;MACA,MAAMG,OAAO,GAAG,IAAI,CAAC9G,MAAM,CAAC2G,CAAC,CAAC;;MAE9B;MACA,MAAMI,OAAO,GAAG,IAAI,CAAC7G,cAAc,IAAK,CAAC4G,OAAO,CAACpB,WAAW,IAAIO,OAAQ;MACxEA,OAAO,GAAG,CAACa,OAAO,CAACnB,QAAQ;;MAE3B;MACA,IAAIoB,OAAO,IAAId,OAAO,EAAE;QACtBa,OAAO,CAACtB,WAAW,CAACwB,IAAI,CAAC,IAAI,CAAC;QAC9BF,OAAO,CAACpB,WAAW,GAAG,IAAI;MAC5B;IACF;EACF;;EAEA;EACAuB,gBAAgBA,CAACC,MAAM,EAAEC,OAAO,EAAE;IAChC,IAAI,CAAC/G,QAAQ,CAAC8G,MAAM,CAAC,GAAG;MACtBC,OAAO,EAAEA,OAAO;MAChBC,MAAM,EAAE,IAAI,CAACpH,MAAM,CAAC,IAAI,CAACA,MAAM,CAAC6G,MAAM,GAAG,CAAC;IAC5C,CAAC;;IAED;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,CAAC3G,cAAc,EAAE;MACvB,MAAMxB,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;MAChCA,QAAQ,IAAIA,QAAQ,CAAC2I,IAAI,CAAC,CAAC;IAC7B;EACF;;EAEA;EACA;EACAZ,IAAIA,CAACa,YAAY,EAAE;IACjB;IACA,IAAIC,WAAW,GAAG,IAAI;IACtB,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAC5G,MAAM,CAAC6G,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAE,EAAED,CAAC,EAAE;MACtD;MACA,MAAMG,OAAO,GAAG,IAAI,CAAC9G,MAAM,CAAC2G,CAAC,CAAC;;MAE9B;MACA;MACA,MAAMJ,SAAS,GAAGO,OAAO,CAAC5E,MAAM,CAAC8E,IAAI,CAAC,IAAI,EAAEM,YAAY,CAAC;MACzDR,OAAO,CAACnB,QAAQ,GAAGmB,OAAO,CAACnB,QAAQ,IAAIY,SAAS,KAAK,IAAI;MACzDgB,WAAW,GAAGA,WAAW,IAAIT,OAAO,CAACnB,QAAQ;IAC/C;;IAEA;IACA,OAAO4B,WAAW;EACpB;;EAEA;EACAC,YAAYA,CAACN,MAAM,EAAEO,MAAM,EAAEC,KAAK,EAAE;IAClC,IAAI,IAAI,CAACtH,QAAQ,CAAC8G,MAAM,CAAC,EAAE;MACzB;MACA,IAAI,CAAC,IAAI,CAAC9G,QAAQ,CAAC8G,MAAM,CAAC,CAACE,MAAM,CAAC1B,WAAW,EAAE;QAC7C,MAAMiC,KAAK,GAAG,IAAI,CAAC3H,MAAM,CAAC4H,OAAO,CAAC,IAAI,CAACxH,QAAQ,CAAC8G,MAAM,CAAC,CAACE,MAAM,CAAC;QAC/D,IAAI,CAACpH,MAAM,CAAC6H,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;QAC5B,OAAO,KAAK;MACd;;MAEA;MACA;MACA,IAAI,IAAI,CAACvH,QAAQ,CAAC8G,MAAM,CAAC,CAACE,MAAM,CAAC3B,QAAQ,EAAE;QACzC,IAAI,CAACrF,QAAQ,CAAC8G,MAAM,CAAC,CAACE,MAAM,CAAC3B,QAAQ,CAACuB,IAAI,CAAC,IAAI,EAAES,MAAM,EAAEC,KAAK,CAAC;QAC/D;MACF,CAAC,MAAM;QACL,IAAI,CAACtH,QAAQ,CAAC8G,MAAM,CAAC,CAACC,OAAO,CAAC5I,EAAE,CAACkJ,MAAM,CAAC;MAC1C;MAEA,IAAI,CAACrH,QAAQ,CAAC8G,MAAM,CAAC,CAACE,MAAM,CAACzB,QAAQ,GAAG,KAAK;MAC7C,MAAMjH,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;MAChCA,QAAQ,IAAIA,QAAQ,CAAC2I,IAAI,CAAC,CAAC;MAC3B,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;AACF;AAEA7H,MAAM,CAACG,EAAE,GAAG,CAAC;AAEb,OAAO,MAAMmI,UAAU,CAAC;EACtBrI,WAAWA,CAACgB,UAAU,GAAG,IAAIxB,MAAM,CAAC,CAAC,EAAEU,EAAE,GAAG,CAAC,CAAC,EAAEI,IAAI,GAAG,IAAI,EAAE;IAC3D,IAAI,CAACU,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACd,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACI,IAAI,GAAGA,IAAI;EAClB;EAEAwC,wBAAwBA,CAAA,EAAG,CAAC;AAC9B;AAEAnE,MAAM,CAAC,CAACoB,MAAM,EAAEsI,UAAU,CAAC,EAAE;EAC3BC,SAASA,CAAC7F,MAAM,EAAE;IAChB,OAAO,IAAI4F,UAAU,CACnB5F,MAAM,CAACzB,UAAU,CAACuH,SAAS,CAAC,IAAI,CAACvH,UAAU,CAAC,EAC5CyB,MAAM,CAACvC,EACT,CAAC;EACH;AACF,CAAC,CAAC;;AAEF;;AAEA,MAAMqI,SAAS,GAAGA,CAACC,IAAI,EAAEC,IAAI,KAAKD,IAAI,CAACrG,UAAU,CAACsG,IAAI,CAAC;AACvD,MAAMC,kBAAkB,GAAIjG,MAAM,IAAKA,MAAM,CAACzB,UAAU;AAExD,SAAS2H,eAAeA,CAAA,EAAG;EACzB;EACA,MAAMC,OAAO,GAAG,IAAI,CAACC,sBAAsB,CAACD,OAAO;EACnD,MAAME,YAAY,GAAGF,OAAO,CACzBG,GAAG,CAACL,kBAAkB,CAAC,CACvBM,MAAM,CAACT,SAAS,EAAE,IAAI/I,MAAM,CAAC,CAAC,CAAC;EAElC,IAAI,CAAC0C,SAAS,CAAC4G,YAAY,CAAC;EAE5B,IAAI,CAACD,sBAAsB,CAACI,KAAK,CAAC,CAAC;EAEnC,IAAI,IAAI,CAACJ,sBAAsB,CAACzB,MAAM,CAAC,CAAC,KAAK,CAAC,EAAE;IAC9C,IAAI,CAAC5F,QAAQ,GAAG,IAAI;EACtB;AACF;AAEA,OAAO,MAAM0H,WAAW,CAAC;EACvBlJ,WAAWA,CAAA,EAAG;IACZ,IAAI,CAAC4I,OAAO,GAAG,EAAE;IACjB,IAAI,CAACO,GAAG,GAAG,EAAE;EACf;EAEAC,GAAGA,CAAC3G,MAAM,EAAE;IACV,IAAI,IAAI,CAACmG,OAAO,CAAC5F,QAAQ,CAACP,MAAM,CAAC,EAAE;IACnC,MAAMvC,EAAE,GAAGuC,MAAM,CAACvC,EAAE,GAAG,CAAC;IAExB,IAAI,CAAC0I,OAAO,CAAC9C,IAAI,CAACrD,MAAM,CAAC;IACzB,IAAI,CAAC0G,GAAG,CAACrD,IAAI,CAAC5F,EAAE,CAAC;IAEjB,OAAO,IAAI;EACb;EAEAmJ,WAAWA,CAACnJ,EAAE,EAAE;IACd,MAAMoJ,SAAS,GAAG,IAAI,CAACH,GAAG,CAAChB,OAAO,CAACjI,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC;IAC/C,IAAI,CAACiJ,GAAG,CAACf,MAAM,CAAC,CAAC,EAAEkB,SAAS,EAAE,CAAC,CAAC;IAChC,IAAI,CAACV,OAAO,CACTR,MAAM,CAAC,CAAC,EAAEkB,SAAS,EAAE,IAAIjB,UAAU,CAAC,CAAC,CAAC,CACtCkB,OAAO,CAAEzE,CAAC,IAAKA,CAAC,CAAChC,wBAAwB,CAAC,CAAC,CAAC;IAC/C,OAAO,IAAI;EACb;EAEA0G,IAAIA,CAACtJ,EAAE,EAAEuJ,SAAS,EAAE;IAClB,MAAMvB,KAAK,GAAG,IAAI,CAACiB,GAAG,CAAChB,OAAO,CAACjI,EAAE,GAAG,CAAC,CAAC;IACtC,IAAI,CAACiJ,GAAG,CAACf,MAAM,CAACF,KAAK,EAAE,CAAC,EAAEhI,EAAE,GAAG,CAAC,CAAC;IACjC,IAAI,CAAC0I,OAAO,CAACR,MAAM,CAACF,KAAK,EAAE,CAAC,EAAEuB,SAAS,CAAC;IACxC,OAAO,IAAI;EACb;EAEAC,OAAOA,CAACxJ,EAAE,EAAE;IACV,OAAO,IAAI,CAAC0I,OAAO,CAAC,IAAI,CAACO,GAAG,CAAChB,OAAO,CAACjI,EAAE,GAAG,CAAC,CAAC,CAAC;EAC/C;EAEAkH,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI,CAAC+B,GAAG,CAAC/B,MAAM;EACxB;EAEA6B,KAAKA,CAAA,EAAG;IACN,IAAIU,UAAU,GAAG,IAAI;IACrB,KAAK,IAAIzC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC0B,OAAO,CAACxB,MAAM,EAAE,EAAEF,CAAC,EAAE;MAC5C,MAAMzE,MAAM,GAAG,IAAI,CAACmG,OAAO,CAAC1B,CAAC,CAAC;MAE9B,MAAM0C,SAAS,GACbD,UAAU,IACVlH,MAAM,CAACnC,IAAI,IACXqJ,UAAU,CAACrJ,IAAI;MACf;MACC,CAACmC,MAAM,CAACpC,SAAS,IAChB,CAACoC,MAAM,CAACpC,SAAS,CAAC0C,UAAU,CAACC,QAAQ,CAACP,MAAM,CAACvC,EAAE,CAAC,CAAC,KAClD,CAACyJ,UAAU,CAACtJ,SAAS,IACpB,CAACsJ,UAAU,CAACtJ,SAAS,CAAC0C,UAAU,CAACC,QAAQ,CAAC2G,UAAU,CAACzJ,EAAE,CAAC,CAAC;MAE7D,IAAI0J,SAAS,EAAE;QACb;QACA,IAAI,CAACC,MAAM,CAACpH,MAAM,CAACvC,EAAE,CAAC;QACtB,MAAMuJ,SAAS,GAAGhH,MAAM,CAAC6F,SAAS,CAACqB,UAAU,CAAC;QAC9C,IAAI,CAACH,IAAI,CAACG,UAAU,CAACzJ,EAAE,EAAEuJ,SAAS,CAAC;QACnCE,UAAU,GAAGF,SAAS;QACtB,EAAEvC,CAAC;MACL,CAAC,MAAM;QACLyC,UAAU,GAAGlH,MAAM;MACrB;IACF;IAEA,OAAO,IAAI;EACb;EAEAoH,MAAMA,CAAC3J,EAAE,EAAE;IACT,MAAMgI,KAAK,GAAG,IAAI,CAACiB,GAAG,CAAChB,OAAO,CAACjI,EAAE,GAAG,CAAC,CAAC;IACtC,IAAI,CAACiJ,GAAG,CAACf,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;IACzB,IAAI,CAACU,OAAO,CAACR,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;IAC7B,OAAO,IAAI;EACb;AACF;AAEAhJ,eAAe,CAAC;EACd4K,OAAO,EAAE;IACPvH,OAAOA,CAACpC,QAAQ,EAAEwB,KAAK,EAAEC,IAAI,EAAE;MAC7B,MAAMY,CAAC,GAAGzC,MAAM,CAAC2B,QAAQ,CAACvB,QAAQ,EAAEwB,KAAK,EAAEC,IAAI,CAAC;MAChD,MAAM3C,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;MAChC,OAAO,IAAIc,MAAM,CAACyC,CAAC,CAACrC,QAAQ,CAAC,CAC1BwC,IAAI,CAACH,CAAC,CAAC,CACPE,OAAO,CAAC,IAAI,CAAC,CACbzD,QAAQ,CAACA,QAAQ,CAAC2I,IAAI,CAAC,CAAC,CAAC,CACzBhF,QAAQ,CAACJ,CAAC,CAACb,KAAK,EAAEa,CAAC,CAACZ,IAAI,CAAC;IAC9B,CAAC;IAEDD,KAAKA,CAACoI,EAAE,EAAEnI,IAAI,EAAE;MACd,OAAO,IAAI,CAACW,OAAO,CAAC,CAAC,EAAEwH,EAAE,EAAEnI,IAAI,CAAC;IAClC,CAAC;IAED;IACA;IACA;IACA;IACAoI,4BAA4BA,CAACC,aAAa,EAAE;MAC1C,IAAI,CAACpB,sBAAsB,CAACQ,WAAW,CAACY,aAAa,CAAC/J,EAAE,CAAC;IAC3D,CAAC;IAEDgK,iBAAiBA,CAAC7C,OAAO,EAAE;MACzB,OACE,IAAI,CAACwB,sBAAsB,CAACD;MAC1B;MACA;MACA;MAAA,CACC3F,MAAM,CAAER,MAAM,IAAKA,MAAM,CAACvC,EAAE,IAAImH,OAAO,CAACnH,EAAE,CAAC,CAC3C6I,GAAG,CAACL,kBAAkB,CAAC,CACvBM,MAAM,CAACT,SAAS,EAAE,IAAI/I,MAAM,CAAC,CAAC,CAAC;IAEtC,CAAC;IAED2K,UAAUA,CAAC1H,MAAM,EAAE;MACjB,IAAI,CAACoG,sBAAsB,CAACO,GAAG,CAAC3G,MAAM,CAAC;;MAEvC;MACA;MACA;MACApD,QAAQ,CAAC+K,eAAe,CAAC,IAAI,CAAC5I,QAAQ,CAAC;MACvC,IAAI,CAACA,QAAQ,GAAGnC,QAAQ,CAACgL,SAAS,CAAC1B,eAAe,CAAC2B,IAAI,CAAC,IAAI,CAAC,CAAC;IAChE,CAAC;IAED/G,cAAcA,CAAA,EAAG;MACf,IAAI,IAAI,CAAC/B,QAAQ,IAAI,IAAI,EAAE;QACzB,IAAI,CAACqH,sBAAsB,GAAG,IAAIK,WAAW,CAAC,CAAC,CAACE,GAAG,CACjD,IAAIf,UAAU,CAAC,IAAI7I,MAAM,CAAC,IAAI,CAAC,CACjC,CAAC;MACH;IACF;EACF;AACF,CAAC,CAAC;;AAEF;AACA,MAAM+K,UAAU,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACvH,MAAM,CAAEwB,CAAC,IAAK,CAACgG,CAAC,CAACzH,QAAQ,CAACyB,CAAC,CAAC,CAAC;AAE5D9F,MAAM,CAACoB,MAAM,EAAE;EACb2K,IAAIA,CAACF,CAAC,EAAEG,CAAC,EAAE;IACT,OAAO,IAAI,CAACC,SAAS,CAAC,MAAM,EAAEJ,CAAC,EAAEG,CAAC,CAAC;EACrC,CAAC;EAED;EACAE,GAAGA,CAAChG,CAAC,EAAE8F,CAAC,EAAE;IACR,OAAO,IAAI,CAACC,SAAS,CAAC,KAAK,EAAE/F,CAAC,EAAE8F,CAAC,CAAC;EACpC,CAAC;EAEDC,SAASA,CAACE,IAAI,EAAEC,WAAW,EAAEC,GAAG,EAAE;IAChC,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE;MACnC,OAAO,IAAI,CAACH,SAAS,CAACE,IAAI,EAAE;QAAE,CAACC,WAAW,GAAGC;MAAI,CAAC,CAAC;IACrD;IAEA,IAAIC,KAAK,GAAGF,WAAW;IACvB,IAAI,IAAI,CAAChD,YAAY,CAAC+C,IAAI,EAAEG,KAAK,CAAC,EAAE,OAAO,IAAI;IAE/C,IAAIvD,OAAO,GAAG,IAAIjI,SAAS,CAAC,IAAI,CAACiB,QAAQ,CAAC,CAAC5B,EAAE,CAACmM,KAAK,CAAC;IACpD,IAAIC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACD,KAAK,CAAC;IAE7B,IAAI,CAAC5H,KAAK,CACR,YAAY;MACVqE,OAAO,GAAGA,OAAO,CAAC7I,IAAI,CAAC,IAAI,CAAC6D,OAAO,CAAC,CAAC,CAACoI,IAAI,CAAC,CAACI,IAAI,CAAC,CAAC;IACpD,CAAC,EACD,UAAUE,GAAG,EAAE;MACb,IAAI,CAAC1I,OAAO,CAAC,CAAC,CAACoI,IAAI,CAAC,CAACpD,OAAO,CAAC2D,EAAE,CAACD,GAAG,CAAC,CAACE,OAAO,CAAC,CAAC,CAAC;MAC/C,OAAO5D,OAAO,CAACpH,IAAI,CAAC,CAAC;IACvB,CAAC,EACD,UAAUiL,UAAU,EAAE;MACpB;MACA,MAAMC,OAAO,GAAGL,MAAM,CAACD,IAAI,CAACK,UAAU,CAAC;MACvC,MAAME,WAAW,GAAGlB,UAAU,CAACiB,OAAO,EAAEN,IAAI,CAAC;;MAE7C;MACA,IAAIO,WAAW,CAACrE,MAAM,EAAE;QACtB;QACA,MAAMsE,cAAc,GAAG,IAAI,CAAChJ,OAAO,CAAC,CAAC,CAACoI,IAAI,CAAC,CAACW,WAAW,CAAC;;QAExD;QACA,MAAME,YAAY,GAAG,IAAIhM,SAAS,CAAC+H,OAAO,CAAC7I,IAAI,CAAC,CAAC,CAAC,CAACyM,OAAO,CAAC,CAAC;;QAE5D;QACAH,MAAM,CAACS,MAAM,CAACD,YAAY,EAAED,cAAc,CAAC;QAC3ChE,OAAO,CAAC7I,IAAI,CAAC8M,YAAY,CAAC;MAC5B;;MAEA;MACA,MAAME,UAAU,GAAG,IAAIlM,SAAS,CAAC+H,OAAO,CAAC5I,EAAE,CAAC,CAAC,CAAC,CAACwM,OAAO,CAAC,CAAC;;MAExD;MACAH,MAAM,CAACS,MAAM,CAACC,UAAU,EAAEN,UAAU,CAAC;;MAErC;MACA7D,OAAO,CAAC5I,EAAE,CAAC+M,UAAU,CAAC;;MAEtB;MACAX,IAAI,GAAGM,OAAO;MACdP,KAAK,GAAGM,UAAU;IACpB,CACF,CAAC;IAED,IAAI,CAAC/D,gBAAgB,CAACsD,IAAI,EAAEpD,OAAO,CAAC;IACpC,OAAO,IAAI;EACb,CAAC;EAEDoE,IAAIA,CAACC,KAAK,EAAEC,KAAK,EAAE;IACjB,IAAI,IAAI,CAACjE,YAAY,CAAC,MAAM,EAAEgE,KAAK,EAAEC,KAAK,CAAC,EAAE,OAAO,IAAI;IAExD,IAAItE,OAAO,GAAG,IAAIjI,SAAS,CAAC,IAAI,CAACiB,QAAQ,CAAC,CAAC5B,EAAE,CAAC,IAAIe,SAAS,CAACkM,KAAK,CAAC,CAAC;IAEnE,IAAI,CAAC1I,KAAK,CACR,YAAY;MACVqE,OAAO,GAAGA,OAAO,CAAC7I,IAAI,CAAC,IAAI,CAAC6D,OAAO,CAAC,CAAC,CAACoJ,IAAI,CAAC,CAAC,CAAC;IAC/C,CAAC,EACD,UAAUV,GAAG,EAAE;MACb,IAAI,CAAC1I,OAAO,CAAC,CAAC,CAACoJ,IAAI,CAACpE,OAAO,CAAC2D,EAAE,CAACD,GAAG,CAAC,EAAEY,KAAK,CAAC;MAC3C,OAAOtE,OAAO,CAACpH,IAAI,CAAC,CAAC;IACvB,CAAC,EACD,UAAU2L,QAAQ,EAAEC,QAAQ,EAAE;MAC5BF,KAAK,GAAGE,QAAQ;MAChBxE,OAAO,CAAC5I,EAAE,CAACmN,QAAQ,CAAC;IACtB,CACF,CAAC;IAED,IAAI,CAACzE,gBAAgB,CAAC,MAAM,EAAEE,OAAO,CAAC;IACtC,OAAO,IAAI;EACb,CAAC;EAED;AACF;AACA;;EAEE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEAxF,SAASA,CAAClB,UAAU,EAAEmL,QAAQ,EAAEC,MAAM,EAAE;IACtC;IACAD,QAAQ,GAAGnL,UAAU,CAACmL,QAAQ,IAAIA,QAAQ;IAC1C,IACE,IAAI,CAAC1L,cAAc,IACnB,CAAC0L,QAAQ,IACT,IAAI,CAACpE,YAAY,CAAC,WAAW,EAAE/G,UAAU,CAAC,EAC1C;MACA,OAAO,IAAI;IACb;;IAEA;IACA,MAAMqL,QAAQ,GAAG7M,MAAM,CAAC8M,YAAY,CAACtL,UAAU,CAAC;IAChDoL,MAAM,GACJpL,UAAU,CAACoL,MAAM,IAAI,IAAI,GACrBpL,UAAU,CAACoL,MAAM,GACjBA,MAAM,IAAI,IAAI,GACZA,MAAM,GACN,CAACC,QAAQ;;IAEjB;IACA,MAAM3E,OAAO,GAAG,IAAIjI,SAAS,CAAC,IAAI,CAACiB,QAAQ,CAAC,CAACoK,IAAI,CAC/CsB,MAAM,GAAG1M,YAAY,GAAGF,MAC1B,CAAC;IAED,IAAI+M,MAAM;IACV,IAAI7J,OAAO;IACX,IAAI2E,OAAO;IACX,IAAImF,YAAY;IAChB,IAAIC,cAAc;IAElB,SAASC,KAAKA,CAAA,EAAG;MACf;MACAhK,OAAO,GAAGA,OAAO,IAAI,IAAI,CAACA,OAAO,CAAC,CAAC;MACnC6J,MAAM,GAAGA,MAAM,IAAIxN,SAAS,CAACiC,UAAU,EAAE0B,OAAO,CAAC;MAEjD+J,cAAc,GAAG,IAAIjN,MAAM,CAAC2M,QAAQ,GAAGQ,SAAS,GAAGjK,OAAO,CAAC;;MAE3D;MACAA,OAAO,CAACyH,UAAU,CAAC,IAAI,CAAC;;MAExB;MACA,IAAI,CAACgC,QAAQ,EAAE;QACbzJ,OAAO,CAACsH,4BAA4B,CAAC,IAAI,CAAC;MAC5C;IACF;IAEA,SAAS4C,GAAGA,CAACxB,GAAG,EAAE;MAChB;MACA;MACA,IAAI,CAACe,QAAQ,EAAE,IAAI,CAACtJ,cAAc,CAAC,CAAC;MAEpC,MAAM;QAAE4B,CAAC;QAAEoI;MAAE,CAAC,GAAG,IAAIjN,KAAK,CAAC2M,MAAM,CAAC,CAACrK,SAAS,CAC1CQ,OAAO,CAACwH,iBAAiB,CAAC,IAAI,CAChC,CAAC;MAED,IAAIlC,MAAM,GAAG,IAAIxI,MAAM,CAAC;QAAE,GAAGwB,UAAU;QAAEuL,MAAM,EAAE,CAAC9H,CAAC,EAAEoI,CAAC;MAAE,CAAC,CAAC;MAC1D,IAAIC,KAAK,GAAG,IAAI,CAACrM,cAAc,IAAI4G,OAAO,GAAGA,OAAO,GAAGoF,cAAc;MAErE,IAAIL,MAAM,EAAE;QACVpE,MAAM,GAAGA,MAAM,CAAC+E,SAAS,CAACtI,CAAC,EAAEoI,CAAC,CAAC;QAC/BC,KAAK,GAAGA,KAAK,CAACC,SAAS,CAACtI,CAAC,EAAEoI,CAAC,CAAC;;QAE7B;QACA,MAAMG,OAAO,GAAGhF,MAAM,CAACiF,MAAM;QAC7B,MAAMC,QAAQ,GAAGJ,KAAK,CAACG,MAAM;;QAE7B;QACA,MAAME,aAAa,GAAG,CAACH,OAAO,GAAG,GAAG,EAAEA,OAAO,EAAEA,OAAO,GAAG,GAAG,CAAC;QAC7D,MAAMI,SAAS,GAAGD,aAAa,CAACpE,GAAG,CAAEyB,CAAC,IAAKzG,IAAI,CAACsJ,GAAG,CAAC7C,CAAC,GAAG0C,QAAQ,CAAC,CAAC;QAClE,MAAMI,QAAQ,GAAGvJ,IAAI,CAACI,GAAG,CAAC,GAAGiJ,SAAS,CAAC;QACvC,MAAMlF,KAAK,GAAGkF,SAAS,CAACjF,OAAO,CAACmF,QAAQ,CAAC;QACzCtF,MAAM,CAACiF,MAAM,GAAGE,aAAa,CAACjF,KAAK,CAAC;MACtC;MAEA,IAAIiE,QAAQ,EAAE;QACZ;QACA;QACA,IAAI,CAACE,QAAQ,EAAE;UACbrE,MAAM,CAACiF,MAAM,GAAGjM,UAAU,CAACiM,MAAM,IAAI,CAAC;QACxC;QACA,IAAI,IAAI,CAACxM,cAAc,IAAI+L,YAAY,EAAE;UACvCM,KAAK,CAACG,MAAM,GAAGT,YAAY;QAC7B;MACF;MAEA9E,OAAO,CAAC7I,IAAI,CAACiO,KAAK,CAAC;MACnBpF,OAAO,CAAC5I,EAAE,CAACkJ,MAAM,CAAC;MAElB,MAAMuF,gBAAgB,GAAG7F,OAAO,CAAC2D,EAAE,CAACD,GAAG,CAAC;MACxCoB,YAAY,GAAGe,gBAAgB,CAACN,MAAM;MACtC5F,OAAO,GAAG,IAAI7H,MAAM,CAAC+N,gBAAgB,CAAC;MAEtC,IAAI,CAACtL,YAAY,CAACoF,OAAO,CAAC;MAC1B3E,OAAO,CAACyH,UAAU,CAAC,IAAI,CAAC;MACxB,OAAOzC,OAAO,CAACpH,IAAI,CAAC,CAAC;IACvB;IAEA,SAAS0F,QAAQA,CAACwH,aAAa,EAAE;MAC/B;MACA,IACE,CAACA,aAAa,CAACjB,MAAM,IAAI,QAAQ,EAAEkB,QAAQ,CAAC,CAAC,KAC7C,CAACzM,UAAU,CAACuL,MAAM,IAAI,QAAQ,EAAEkB,QAAQ,CAAC,CAAC,EAC1C;QACAlB,MAAM,GAAGxN,SAAS,CAACyO,aAAa,EAAE9K,OAAO,CAAC;MAC5C;;MAEA;MACA1B,UAAU,GAAG;QAAE,GAAGwM,aAAa;QAAEjB;MAAO,CAAC;IAC3C;IAEA,IAAI,CAAClJ,KAAK,CAACqJ,KAAK,EAAEE,GAAG,EAAE5G,QAAQ,EAAE,IAAI,CAAC;IACtC,IAAI,CAACvF,cAAc,IAAI,IAAI,CAAC+G,gBAAgB,CAAC,WAAW,EAAEE,OAAO,CAAC;IAClE,OAAO,IAAI;EACb,CAAC;EAED;EACAjD,CAACA,CAACA,CAAC,EAAE;IACH,OAAO,IAAI,CAACiJ,YAAY,CAAC,GAAG,EAAEjJ,CAAC,CAAC;EAClC,CAAC;EAED;EACAoI,CAACA,CAACA,CAAC,EAAE;IACH,OAAO,IAAI,CAACa,YAAY,CAAC,GAAG,EAAEb,CAAC,CAAC;EAClC,CAAC;EAEDc,EAAEA,CAAClJ,CAAC,EAAE;IACJ,OAAO,IAAI,CAACiJ,YAAY,CAAC,IAAI,EAAEjJ,CAAC,CAAC;EACnC,CAAC;EAEDmJ,EAAEA,CAACf,CAAC,EAAE;IACJ,OAAO,IAAI,CAACa,YAAY,CAAC,IAAI,EAAEb,CAAC,CAAC;EACnC,CAAC;EAEDgB,EAAEA,CAACpJ,CAAC,GAAG,CAAC,EAAE;IACR,OAAO,IAAI,CAACqJ,iBAAiB,CAAC,GAAG,EAAErJ,CAAC,CAAC;EACvC,CAAC;EAEDsJ,EAAEA,CAAClB,CAAC,GAAG,CAAC,EAAE;IACR,OAAO,IAAI,CAACiB,iBAAiB,CAAC,GAAG,EAAEjB,CAAC,CAAC;EACvC,CAAC;EAEDmB,KAAKA,CAACvJ,CAAC,EAAEoI,CAAC,EAAE;IACV,OAAO,IAAI,CAACgB,EAAE,CAACpJ,CAAC,CAAC,CAACsJ,EAAE,CAAClB,CAAC,CAAC;EACzB,CAAC;EAEDiB,iBAAiBA,CAACrG,MAAM,EAAE3I,EAAE,EAAE;IAC5BA,EAAE,GAAG,IAAIe,SAAS,CAACf,EAAE,CAAC;;IAEtB;IACA,IAAI,IAAI,CAACiJ,YAAY,CAACN,MAAM,EAAE3I,EAAE,CAAC,EAAE,OAAO,IAAI;;IAE9C;IACA,MAAM4I,OAAO,GAAG,IAAIjI,SAAS,CAAC,IAAI,CAACiB,QAAQ,CAAC,CAAC5B,EAAE,CAACA,EAAE,CAAC;IACnD,IAAID,IAAI,GAAG,IAAI;IACf,IAAI,CAACwE,KAAK,CACR,YAAY;MACVxE,IAAI,GAAG,IAAI,CAAC6D,OAAO,CAAC,CAAC,CAAC+E,MAAM,CAAC,CAAC,CAAC;MAC/BC,OAAO,CAAC7I,IAAI,CAACA,IAAI,CAAC;MAClB6I,OAAO,CAAC5I,EAAE,CAACD,IAAI,GAAGC,EAAE,CAAC;IACvB,CAAC,EACD,UAAUsM,GAAG,EAAE;MACb,IAAI,CAAC1I,OAAO,CAAC,CAAC,CAAC+E,MAAM,CAAC,CAACC,OAAO,CAAC2D,EAAE,CAACD,GAAG,CAAC,CAAC;MACvC,OAAO1D,OAAO,CAACpH,IAAI,CAAC,CAAC;IACvB,CAAC,EACD,UAAU2N,KAAK,EAAE;MACfvG,OAAO,CAAC5I,EAAE,CAACD,IAAI,GAAG,IAAIgB,SAAS,CAACoO,KAAK,CAAC,CAAC;IACzC,CACF,CAAC;;IAED;IACA,IAAI,CAACzG,gBAAgB,CAACC,MAAM,EAAEC,OAAO,CAAC;IACtC,OAAO,IAAI;EACb,CAAC;EAEDwG,YAAYA,CAACzG,MAAM,EAAE3I,EAAE,EAAE;IACvB;IACA,IAAI,IAAI,CAACiJ,YAAY,CAACN,MAAM,EAAE3I,EAAE,CAAC,EAAE,OAAO,IAAI;;IAE9C;IACA,MAAM4I,OAAO,GAAG,IAAIjI,SAAS,CAAC,IAAI,CAACiB,QAAQ,CAAC,CAAC5B,EAAE,CAACA,EAAE,CAAC;IACnD,IAAI,CAACuE,KAAK,CACR,YAAY;MACVqE,OAAO,CAAC7I,IAAI,CAAC,IAAI,CAAC6D,OAAO,CAAC,CAAC,CAAC+E,MAAM,CAAC,CAAC,CAAC,CAAC;IACxC,CAAC,EACD,UAAU2D,GAAG,EAAE;MACb,IAAI,CAAC1I,OAAO,CAAC,CAAC,CAAC+E,MAAM,CAAC,CAACC,OAAO,CAAC2D,EAAE,CAACD,GAAG,CAAC,CAAC;MACvC,OAAO1D,OAAO,CAACpH,IAAI,CAAC,CAAC;IACvB,CACF,CAAC;;IAED;IACA,IAAI,CAACkH,gBAAgB,CAACC,MAAM,EAAEC,OAAO,CAAC;IACtC,OAAO,IAAI;EACb,CAAC;EAEDgG,YAAYA,CAACjG,MAAM,EAAE0G,KAAK,EAAE;IAC1B,OAAO,IAAI,CAACD,YAAY,CAACzG,MAAM,EAAE,IAAI5H,SAAS,CAACsO,KAAK,CAAC,CAAC;EACxD,CAAC;EAED;EACAC,EAAEA,CAAC3J,CAAC,EAAE;IACJ,OAAO,IAAI,CAACiJ,YAAY,CAAC,IAAI,EAAEjJ,CAAC,CAAC;EACnC,CAAC;EAED;EACA4J,EAAEA,CAACxB,CAAC,EAAE;IACJ,OAAO,IAAI,CAACa,YAAY,CAAC,IAAI,EAAEb,CAAC,CAAC;EACnC,CAAC;EAED;EACAyB,IAAIA,CAAC7J,CAAC,EAAEoI,CAAC,EAAE;IACT,OAAO,IAAI,CAACpI,CAAC,CAACA,CAAC,CAAC,CAACoI,CAAC,CAACA,CAAC,CAAC;EACvB,CAAC;EAED0B,KAAKA,CAAC9J,CAAC,EAAEoI,CAAC,EAAE;IACV,OAAO,IAAI,CAACc,EAAE,CAAClJ,CAAC,CAAC,CAACmJ,EAAE,CAACf,CAAC,CAAC;EACzB,CAAC;EAED;EACA2B,MAAMA,CAAC/J,CAAC,EAAEoI,CAAC,EAAE;IACX,OAAO,IAAI,CAACuB,EAAE,CAAC3J,CAAC,CAAC,CAAC4J,EAAE,CAACxB,CAAC,CAAC;EACzB,CAAC;EAED;EACA4B,IAAIA,CAACC,KAAK,EAAEC,MAAM,EAAE;IAClB;IACA,IAAIC,GAAG;IAEP,IAAI,CAACF,KAAK,IAAI,CAACC,MAAM,EAAE;MACrBC,GAAG,GAAG,IAAI,CAACxO,QAAQ,CAACyO,IAAI,CAAC,CAAC;IAC5B;IAEA,IAAI,CAACH,KAAK,EAAE;MACVA,KAAK,GAAIE,GAAG,CAACF,KAAK,GAAGE,GAAG,CAACD,MAAM,GAAIA,MAAM;IAC3C;IAEA,IAAI,CAACA,MAAM,EAAE;MACXA,MAAM,GAAIC,GAAG,CAACD,MAAM,GAAGC,GAAG,CAACF,KAAK,GAAIA,KAAK;IAC3C;IAEA,OAAO,IAAI,CAACA,KAAK,CAACA,KAAK,CAAC,CAACC,MAAM,CAACA,MAAM,CAAC;EACzC,CAAC;EAED;EACAD,KAAKA,CAACA,KAAK,EAAE;IACX,OAAO,IAAI,CAAChB,YAAY,CAAC,OAAO,EAAEgB,KAAK,CAAC;EAC1C,CAAC;EAED;EACAC,MAAMA,CAACA,MAAM,EAAE;IACb,OAAO,IAAI,CAACjB,YAAY,CAAC,QAAQ,EAAEiB,MAAM,CAAC;EAC5C,CAAC;EAED;EACAG,IAAIA,CAACtE,CAAC,EAAEC,CAAC,EAAEsE,CAAC,EAAErK,CAAC,EAAE;IACf;IACA,IAAIsK,SAAS,CAAC5H,MAAM,KAAK,CAAC,EAAE;MAC1B,OAAO,IAAI,CAAC0H,IAAI,CAAC,CAACtE,CAAC,EAAEC,CAAC,EAAEsE,CAAC,EAAErK,CAAC,CAAC,CAAC;IAChC;IAEA,IAAI,IAAI,CAACqD,YAAY,CAAC,MAAM,EAAEyC,CAAC,CAAC,EAAE,OAAO,IAAI;IAE7C,MAAM9C,OAAO,GAAG,IAAIjI,SAAS,CAAC,IAAI,CAACiB,QAAQ,CAAC,CACzCoK,IAAI,CAAC,IAAI,CAAC1K,QAAQ,CAAC6O,UAAU,CAAC,CAC9BnQ,EAAE,CAAC0L,CAAC,CAAC;IAER,IAAI,CAACnH,KAAK,CACR,YAAY;MACVqE,OAAO,CAAC7I,IAAI,CAAC,IAAI,CAACuB,QAAQ,CAAC8O,KAAK,CAAC,CAAC,CAAC;IACrC,CAAC,EACD,UAAU9D,GAAG,EAAE;MACb,IAAI,CAAChL,QAAQ,CAAC0O,IAAI,CAACpH,OAAO,CAAC2D,EAAE,CAACD,GAAG,CAAC,CAAC;MACnC,OAAO1D,OAAO,CAACpH,IAAI,CAAC,CAAC;IACvB,CACF,CAAC;IAED,IAAI,CAACkH,gBAAgB,CAAC,MAAM,EAAEE,OAAO,CAAC;IACtC,OAAO,IAAI;EACb,CAAC;EAED;EACAyH,OAAOA,CAAChB,KAAK,EAAE;IACb,OAAO,IAAI,CAACT,YAAY,CAAC,SAAS,EAAES,KAAK,CAAC;EAC5C,CAAC;EAED;EACAiB,OAAOA,CAAC3K,CAAC,EAAEoI,CAAC,EAAE6B,KAAK,EAAEC,MAAM,EAAE;IAC3B,OAAO,IAAI,CAACT,YAAY,CAAC,SAAS,EAAE,IAAI5O,GAAG,CAACmF,CAAC,EAAEoI,CAAC,EAAE6B,KAAK,EAAEC,MAAM,CAAC,CAAC;EACnE,CAAC;EAEDU,MAAMA,CAAC7M,CAAC,EAAE;IACR,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;MACzB,OAAO,IAAI,CAAC6M,MAAM,CAAC;QACjBC,MAAM,EAAEN,SAAS,CAAC,CAAC,CAAC;QACpBO,KAAK,EAAEP,SAAS,CAAC,CAAC,CAAC;QACnBQ,OAAO,EAAER,SAAS,CAAC,CAAC;MACtB,CAAC,CAAC;IACJ;IAEA,IAAIxM,CAAC,CAACgN,OAAO,IAAI,IAAI,EAAE,IAAI,CAAC9E,IAAI,CAAC,cAAc,EAAElI,CAAC,CAACgN,OAAO,CAAC;IAC3D,IAAIhN,CAAC,CAAC+M,KAAK,IAAI,IAAI,EAAE,IAAI,CAAC7E,IAAI,CAAC,YAAY,EAAElI,CAAC,CAAC+M,KAAK,CAAC;IACrD,IAAI/M,CAAC,CAAC8M,MAAM,IAAI,IAAI,EAAE,IAAI,CAAC5E,IAAI,CAAC,QAAQ,EAAElI,CAAC,CAAC8M,MAAM,CAAC;IAEnD,OAAO,IAAI;EACb;AACF,CAAC,CAAC;AAEF3Q,MAAM,CAACoB,MAAM,EAAE;EAAEZ,EAAE;EAAEC,EAAE;EAAEP,IAAI;EAAEC;AAAG,CAAC,CAAC;AACpCF,QAAQ,CAACmB,MAAM,EAAE,QAAQ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}