{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport { isPathLetter } from '../modules/core/regex.js';\nimport Point from '../types/Point.js';\nconst segmentParameters = {\n  M: 2,\n  L: 2,\n  H: 1,\n  V: 1,\n  C: 6,\n  S: 4,\n  Q: 4,\n  T: 2,\n  A: 7,\n  Z: 0\n};\nconst pathHandlers = {\n  M: function (c, p, p0) {\n    p.x = p0.x = c[0];\n    p.y = p0.y = c[1];\n    return ['M', p.x, p.y];\n  },\n  L: function (c, p) {\n    p.x = c[0];\n    p.y = c[1];\n    return ['L', c[0], c[1]];\n  },\n  H: function (c, p) {\n    p.x = c[0];\n    return ['H', c[0]];\n  },\n  V: function (c, p) {\n    p.y = c[0];\n    return ['V', c[0]];\n  },\n  C: function (c, p) {\n    p.x = c[4];\n    p.y = c[5];\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];\n  },\n  S: function (c, p) {\n    p.x = c[2];\n    p.y = c[3];\n    return ['S', c[0], c[1], c[2], c[3]];\n  },\n  Q: function (c, p) {\n    p.x = c[2];\n    p.y = c[3];\n    return ['Q', c[0], c[1], c[2], c[3]];\n  },\n  T: function (c, p) {\n    p.x = c[0];\n    p.y = c[1];\n    return ['T', c[0], c[1]];\n  },\n  Z: function (c, p, p0) {\n    p.x = p0.x;\n    p.y = p0.y;\n    return ['Z'];\n  },\n  A: function (c, p) {\n    p.x = c[5];\n    p.y = c[6];\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];\n  }\n};\nconst mlhvqtcsaz = 'mlhvqtcsaz'.split('');\nfor (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {\n  pathHandlers[mlhvqtcsaz[i]] = function (i) {\n    return function (c, p, p0) {\n      if (i === 'H') c[0] = c[0] + p.x;else if (i === 'V') c[0] = c[0] + p.y;else if (i === 'A') {\n        c[5] = c[5] + p.x;\n        c[6] = c[6] + p.y;\n      } else {\n        for (let j = 0, jl = c.length; j < jl; ++j) {\n          c[j] = c[j] + (j % 2 ? p.y : p.x);\n        }\n      }\n      return pathHandlers[i](c, p, p0);\n    };\n  }(mlhvqtcsaz[i].toUpperCase());\n}\nfunction makeAbsolut(parser) {\n  const command = parser.segment[0];\n  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0);\n}\nfunction segmentComplete(parser) {\n  return parser.segment.length && parser.segment.length - 1 === segmentParameters[parser.segment[0].toUpperCase()];\n}\nfunction startNewSegment(parser, token) {\n  parser.inNumber && finalizeNumber(parser, false);\n  const pathLetter = isPathLetter.test(token);\n  if (pathLetter) {\n    parser.segment = [token];\n  } else {\n    const lastCommand = parser.lastCommand;\n    const small = lastCommand.toLowerCase();\n    const isSmall = lastCommand === small;\n    parser.segment = [small === 'm' ? isSmall ? 'l' : 'L' : lastCommand];\n  }\n  parser.inSegment = true;\n  parser.lastCommand = parser.segment[0];\n  return pathLetter;\n}\nfunction finalizeNumber(parser, inNumber) {\n  if (!parser.inNumber) throw new Error('Parser Error');\n  parser.number && parser.segment.push(parseFloat(parser.number));\n  parser.inNumber = inNumber;\n  parser.number = '';\n  parser.pointSeen = false;\n  parser.hasExponent = false;\n  if (segmentComplete(parser)) {\n    finalizeSegment(parser);\n  }\n}\nfunction finalizeSegment(parser) {\n  parser.inSegment = false;\n  if (parser.absolute) {\n    parser.segment = makeAbsolut(parser);\n  }\n  parser.segments.push(parser.segment);\n}\nfunction isArcFlag(parser) {\n  if (!parser.segment.length) return false;\n  const isArc = parser.segment[0].toUpperCase() === 'A';\n  const length = parser.segment.length;\n  return isArc && (length === 4 || length === 5);\n}\nfunction isExponential(parser) {\n  return parser.lastToken.toUpperCase() === 'E';\n}\nconst pathDelimiters = new Set([' ', ',', '\\t', '\\n', '\\r', '\\f']);\nexport function pathParser(d, toAbsolute = true) {\n  let index = 0;\n  let token = '';\n  const parser = {\n    segment: [],\n    inNumber: false,\n    number: '',\n    lastToken: '',\n    inSegment: false,\n    segments: [],\n    pointSeen: false,\n    hasExponent: false,\n    absolute: toAbsolute,\n    p0: new Point(),\n    p: new Point()\n  };\n  while (parser.lastToken = token, token = d.charAt(index++)) {\n    if (!parser.inSegment) {\n      if (startNewSegment(parser, token)) {\n        continue;\n      }\n    }\n    if (token === '.') {\n      if (parser.pointSeen || parser.hasExponent) {\n        finalizeNumber(parser, false);\n        --index;\n        continue;\n      }\n      parser.inNumber = true;\n      parser.pointSeen = true;\n      parser.number += token;\n      continue;\n    }\n    if (!isNaN(parseInt(token))) {\n      if (parser.number === '0' || isArcFlag(parser)) {\n        parser.inNumber = true;\n        parser.number = token;\n        finalizeNumber(parser, true);\n        continue;\n      }\n      parser.inNumber = true;\n      parser.number += token;\n      continue;\n    }\n    if (pathDelimiters.has(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false);\n      }\n      continue;\n    }\n    if (token === '-' || token === '+') {\n      if (parser.inNumber && !isExponential(parser)) {\n        finalizeNumber(parser, false);\n        --index;\n        continue;\n      }\n      parser.number += token;\n      parser.inNumber = true;\n      continue;\n    }\n    if (token.toUpperCase() === 'E') {\n      parser.number += token;\n      parser.hasExponent = true;\n      continue;\n    }\n    if (isPathLetter.test(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false);\n      } else if (!segmentComplete(parser)) {\n        throw new Error('parser Error');\n      } else {\n        finalizeSegment(parser);\n      }\n      --index;\n    }\n  }\n  if (parser.inNumber) {\n    finalizeNumber(parser, false);\n  }\n  if (parser.inSegment && segmentComplete(parser)) {\n    finalizeSegment(parser);\n  }\n  return parser.segments;\n}","map":{"version":3,"names":["isPathLetter","Point","segmentParameters","M","L","H","V","C","S","Q","T","A","Z","pathHandlers","c","p","p0","x","y","mlhvqtcsaz","split","i","il","length","j","jl","toUpperCase","makeAbsolut","parser","command","segment","slice","segmentComplete","startNewSegment","token","inNumber","finalizeNumber","pathLetter","test","lastCommand","small","toLowerCase","isSmall","inSegment","Error","number","push","parseFloat","pointSeen","hasExponent","finalizeSegment","absolute","segments","isArcFlag","isArc","isExponential","lastToken","pathDelimiters","Set","pathParser","d","toAbsolute","index","charAt","isNaN","parseInt","has"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/@svgdotjs/svg.js/src/utils/pathParser.js"],"sourcesContent":["import { isPathLetter } from '../modules/core/regex.js'\nimport Point from '../types/Point.js'\n\nconst segmentParameters = {\n  M: 2,\n  L: 2,\n  H: 1,\n  V: 1,\n  C: 6,\n  S: 4,\n  Q: 4,\n  T: 2,\n  A: 7,\n  Z: 0\n}\n\nconst pathHandlers = {\n  M: function (c, p, p0) {\n    p.x = p0.x = c[0]\n    p.y = p0.y = c[1]\n\n    return ['M', p.x, p.y]\n  },\n  L: function (c, p) {\n    p.x = c[0]\n    p.y = c[1]\n    return ['L', c[0], c[1]]\n  },\n  H: function (c, p) {\n    p.x = c[0]\n    return ['H', c[0]]\n  },\n  V: function (c, p) {\n    p.y = c[0]\n    return ['V', c[0]]\n  },\n  C: function (c, p) {\n    p.x = c[4]\n    p.y = c[5]\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]\n  },\n  S: function (c, p) {\n    p.x = c[2]\n    p.y = c[3]\n    return ['S', c[0], c[1], c[2], c[3]]\n  },\n  Q: function (c, p) {\n    p.x = c[2]\n    p.y = c[3]\n    return ['Q', c[0], c[1], c[2], c[3]]\n  },\n  T: function (c, p) {\n    p.x = c[0]\n    p.y = c[1]\n    return ['T', c[0], c[1]]\n  },\n  Z: function (c, p, p0) {\n    p.x = p0.x\n    p.y = p0.y\n    return ['Z']\n  },\n  A: function (c, p) {\n    p.x = c[5]\n    p.y = c[6]\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]\n  }\n}\n\nconst mlhvqtcsaz = 'mlhvqtcsaz'.split('')\n\nfor (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {\n  pathHandlers[mlhvqtcsaz[i]] = (function (i) {\n    return function (c, p, p0) {\n      if (i === 'H') c[0] = c[0] + p.x\n      else if (i === 'V') c[0] = c[0] + p.y\n      else if (i === 'A') {\n        c[5] = c[5] + p.x\n        c[6] = c[6] + p.y\n      } else {\n        for (let j = 0, jl = c.length; j < jl; ++j) {\n          c[j] = c[j] + (j % 2 ? p.y : p.x)\n        }\n      }\n\n      return pathHandlers[i](c, p, p0)\n    }\n  })(mlhvqtcsaz[i].toUpperCase())\n}\n\nfunction makeAbsolut(parser) {\n  const command = parser.segment[0]\n  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0)\n}\n\nfunction segmentComplete(parser) {\n  return (\n    parser.segment.length &&\n    parser.segment.length - 1 ===\n      segmentParameters[parser.segment[0].toUpperCase()]\n  )\n}\n\nfunction startNewSegment(parser, token) {\n  parser.inNumber && finalizeNumber(parser, false)\n  const pathLetter = isPathLetter.test(token)\n\n  if (pathLetter) {\n    parser.segment = [token]\n  } else {\n    const lastCommand = parser.lastCommand\n    const small = lastCommand.toLowerCase()\n    const isSmall = lastCommand === small\n    parser.segment = [small === 'm' ? (isSmall ? 'l' : 'L') : lastCommand]\n  }\n\n  parser.inSegment = true\n  parser.lastCommand = parser.segment[0]\n\n  return pathLetter\n}\n\nfunction finalizeNumber(parser, inNumber) {\n  if (!parser.inNumber) throw new Error('Parser Error')\n  parser.number && parser.segment.push(parseFloat(parser.number))\n  parser.inNumber = inNumber\n  parser.number = ''\n  parser.pointSeen = false\n  parser.hasExponent = false\n\n  if (segmentComplete(parser)) {\n    finalizeSegment(parser)\n  }\n}\n\nfunction finalizeSegment(parser) {\n  parser.inSegment = false\n  if (parser.absolute) {\n    parser.segment = makeAbsolut(parser)\n  }\n  parser.segments.push(parser.segment)\n}\n\nfunction isArcFlag(parser) {\n  if (!parser.segment.length) return false\n  const isArc = parser.segment[0].toUpperCase() === 'A'\n  const length = parser.segment.length\n\n  return isArc && (length === 4 || length === 5)\n}\n\nfunction isExponential(parser) {\n  return parser.lastToken.toUpperCase() === 'E'\n}\n\nconst pathDelimiters = new Set([' ', ',', '\\t', '\\n', '\\r', '\\f'])\nexport function pathParser(d, toAbsolute = true) {\n  let index = 0\n  let token = ''\n  const parser = {\n    segment: [],\n    inNumber: false,\n    number: '',\n    lastToken: '',\n    inSegment: false,\n    segments: [],\n    pointSeen: false,\n    hasExponent: false,\n    absolute: toAbsolute,\n    p0: new Point(),\n    p: new Point()\n  }\n\n  while (((parser.lastToken = token), (token = d.charAt(index++)))) {\n    if (!parser.inSegment) {\n      if (startNewSegment(parser, token)) {\n        continue\n      }\n    }\n\n    if (token === '.') {\n      if (parser.pointSeen || parser.hasExponent) {\n        finalizeNumber(parser, false)\n        --index\n        continue\n      }\n      parser.inNumber = true\n      parser.pointSeen = true\n      parser.number += token\n      continue\n    }\n\n    if (!isNaN(parseInt(token))) {\n      if (parser.number === '0' || isArcFlag(parser)) {\n        parser.inNumber = true\n        parser.number = token\n        finalizeNumber(parser, true)\n        continue\n      }\n\n      parser.inNumber = true\n      parser.number += token\n      continue\n    }\n\n    if (pathDelimiters.has(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false)\n      }\n      continue\n    }\n\n    if (token === '-' || token === '+') {\n      if (parser.inNumber && !isExponential(parser)) {\n        finalizeNumber(parser, false)\n        --index\n        continue\n      }\n      parser.number += token\n      parser.inNumber = true\n      continue\n    }\n\n    if (token.toUpperCase() === 'E') {\n      parser.number += token\n      parser.hasExponent = true\n      continue\n    }\n\n    if (isPathLetter.test(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false)\n      } else if (!segmentComplete(parser)) {\n        throw new Error('parser Error')\n      } else {\n        finalizeSegment(parser)\n      }\n      --index\n    }\n  }\n\n  if (parser.inNumber) {\n    finalizeNumber(parser, false)\n  }\n\n  if (parser.inSegment && segmentComplete(parser)) {\n    finalizeSegment(parser)\n  }\n\n  return parser.segments\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}