{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { globals } from '../utils/window.js';\nimport Queue from './Queue.js';\nconst Animator = {\n  nextDraw: null,\n  frames: new Queue(),\n  timeouts: new Queue(),\n  immediates: new Queue(),\n  timer: () => globals.window.performance || globals.window.Date,\n  transforms: [],\n  frame(fn) {\n    // Store the node\n    const node = Animator.frames.push({\n      run: fn\n    });\n\n    // Request an animation frame if we don't have one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n\n    // Return the node so we can remove it easily\n    return node;\n  },\n  timeout(fn, delay) {\n    delay = delay || 0;\n\n    // Work out when the event should fire\n    const time = Animator.timer().now() + delay;\n\n    // Add the timeout to the end of the queue\n    const node = Animator.timeouts.push({\n      run: fn,\n      time: time\n    });\n\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n    return node;\n  },\n  immediate(fn) {\n    // Add the immediate fn to the end of the queue\n    const node = Animator.immediates.push(fn);\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n    return node;\n  },\n  cancelFrame(node) {\n    node != null && Animator.frames.remove(node);\n  },\n  clearTimeout(node) {\n    node != null && Animator.timeouts.remove(node);\n  },\n  cancelImmediate(node) {\n    node != null && Animator.immediates.remove(node);\n  },\n  _draw(now) {\n    // Run all the timeouts we can run, if they are not ready yet, add them\n    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])\n    let nextTimeout = null;\n    const lastTimeout = Animator.timeouts.last();\n    while (nextTimeout = Animator.timeouts.shift()) {\n      // Run the timeout if its time, or push it to the end\n      if (now >= nextTimeout.time) {\n        nextTimeout.run();\n      } else {\n        Animator.timeouts.push(nextTimeout);\n      }\n\n      // If we hit the last item, we should stop shifting out more items\n      if (nextTimeout === lastTimeout) break;\n    }\n\n    // Run all of the animation frames\n    let nextFrame = null;\n    const lastFrame = Animator.frames.last();\n    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {\n      nextFrame.run(now);\n    }\n    let nextImmediate = null;\n    while (nextImmediate = Animator.immediates.shift()) {\n      nextImmediate();\n    }\n\n    // If we have remaining timeouts or frames, draw until we don't anymore\n    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;\n  }\n};\nexport default Animator;","map":{"version":3,"names":["globals","Queue","Animator","nextDraw","frames","timeouts","immediates","timer","window","performance","Date","transforms","frame","fn","node","push","run","requestAnimationFrame","_draw","timeout","delay","time","now","immediate","cancelFrame","remove","clearTimeout","cancelImmediate","nextTimeout","lastTimeout","last","shift","nextFrame","lastFrame","nextImmediate","first"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/@svgdotjs/svg.js/src/animation/Animator.js"],"sourcesContent":["import { globals } from '../utils/window.js'\nimport Queue from './Queue.js'\n\nconst Animator = {\n  nextDraw: null,\n  frames: new Queue(),\n  timeouts: new Queue(),\n  immediates: new Queue(),\n  timer: () => globals.window.performance || globals.window.Date,\n  transforms: [],\n\n  frame(fn) {\n    // Store the node\n    const node = Animator.frames.push({ run: fn })\n\n    // Request an animation frame if we don't have one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw)\n    }\n\n    // Return the node so we can remove it easily\n    return node\n  },\n\n  timeout(fn, delay) {\n    delay = delay || 0\n\n    // Work out when the event should fire\n    const time = Animator.timer().now() + delay\n\n    // Add the timeout to the end of the queue\n    const node = Animator.timeouts.push({ run: fn, time: time })\n\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw)\n    }\n\n    return node\n  },\n\n  immediate(fn) {\n    // Add the immediate fn to the end of the queue\n    const node = Animator.immediates.push(fn)\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw)\n    }\n\n    return node\n  },\n\n  cancelFrame(node) {\n    node != null && Animator.frames.remove(node)\n  },\n\n  clearTimeout(node) {\n    node != null && Animator.timeouts.remove(node)\n  },\n\n  cancelImmediate(node) {\n    node != null && Animator.immediates.remove(node)\n  },\n\n  _draw(now) {\n    // Run all the timeouts we can run, if they are not ready yet, add them\n    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])\n    let nextTimeout = null\n    const lastTimeout = Animator.timeouts.last()\n    while ((nextTimeout = Animator.timeouts.shift())) {\n      // Run the timeout if its time, or push it to the end\n      if (now >= nextTimeout.time) {\n        nextTimeout.run()\n      } else {\n        Animator.timeouts.push(nextTimeout)\n      }\n\n      // If we hit the last item, we should stop shifting out more items\n      if (nextTimeout === lastTimeout) break\n    }\n\n    // Run all of the animation frames\n    let nextFrame = null\n    const lastFrame = Animator.frames.last()\n    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {\n      nextFrame.run(now)\n    }\n\n    let nextImmediate = null\n    while ((nextImmediate = Animator.immediates.shift())) {\n      nextImmediate()\n    }\n\n    // If we have remaining timeouts or frames, draw until we don't anymore\n    Animator.nextDraw =\n      Animator.timeouts.first() || Animator.frames.first()\n        ? globals.window.requestAnimationFrame(Animator._draw)\n        : null\n  }\n}\n\nexport default Animator\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}