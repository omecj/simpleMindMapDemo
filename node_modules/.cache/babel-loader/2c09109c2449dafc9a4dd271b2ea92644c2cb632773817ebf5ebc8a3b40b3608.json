{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { globals } from '../utils/window.js';\nimport { registerMethods } from '../utils/methods.js';\nimport Animator from './Animator.js';\nimport EventTarget from '../types/EventTarget.js';\nconst makeSchedule = function (runnerInfo) {\n  const start = runnerInfo.start;\n  const duration = runnerInfo.runner.duration();\n  const end = start + duration;\n  return {\n    start: start,\n    duration: duration,\n    end: end,\n    runner: runnerInfo.runner\n  };\n};\nconst defaultSource = function () {\n  const w = globals.window;\n  return (w.performance || w.Date).now();\n};\nexport default class Timeline extends EventTarget {\n  // Construct a new timeline on the given element\n  constructor(timeSource = defaultSource) {\n    super();\n    this._timeSource = timeSource;\n\n    // terminate resets all variables to their initial state\n    this.terminate();\n  }\n  active() {\n    return !!this._nextFrame;\n  }\n  finish() {\n    // Go to end and pause\n    this.time(this.getEndTimeOfTimeline() + 1);\n    return this.pause();\n  }\n\n  // Calculates the end of the timeline\n  getEndTime() {\n    const lastRunnerInfo = this.getLastRunnerInfo();\n    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;\n    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;\n    return lastStartTime + lastDuration;\n  }\n  getEndTimeOfTimeline() {\n    const endTimes = this._runners.map(i => i.start + i.runner.duration());\n    return Math.max(0, ...endTimes);\n  }\n  getLastRunnerInfo() {\n    return this.getRunnerInfoById(this._lastRunnerId);\n  }\n  getRunnerInfoById(id) {\n    return this._runners[this._runnerIds.indexOf(id)] || null;\n  }\n  pause() {\n    this._paused = true;\n    return this._continue();\n  }\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist;\n    this._persist = dtOrForever;\n    return this;\n  }\n  play() {\n    // Now make sure we are not paused and continue the animation\n    this._paused = false;\n    return this.updateTime()._continue();\n  }\n  reverse(yes) {\n    const currentSpeed = this.speed();\n    if (yes == null) return this.speed(-currentSpeed);\n    const positive = Math.abs(currentSpeed);\n    return this.speed(yes ? -positive : positive);\n  }\n\n  // schedules a runner on the timeline\n  schedule(runner, delay, when) {\n    if (runner == null) {\n      return this._runners.map(makeSchedule);\n    }\n\n    // The start time for the next animation can either be given explicitly,\n    // derived from the current timeline time or it can be relative to the\n    // last start time to chain animations directly\n\n    let absoluteStartTime = 0;\n    const endTime = this.getEndTime();\n    delay = delay || 0;\n\n    // Work out when to start the animation\n    if (when == null || when === 'last' || when === 'after') {\n      // Take the last time and increment\n      absoluteStartTime = endTime;\n    } else if (when === 'absolute' || when === 'start') {\n      absoluteStartTime = delay;\n      delay = 0;\n    } else if (when === 'now') {\n      absoluteStartTime = this._time;\n    } else if (when === 'relative') {\n      const runnerInfo = this.getRunnerInfoById(runner.id);\n      if (runnerInfo) {\n        absoluteStartTime = runnerInfo.start + delay;\n        delay = 0;\n      }\n    } else if (when === 'with-last') {\n      const lastRunnerInfo = this.getLastRunnerInfo();\n      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;\n      absoluteStartTime = lastStartTime;\n    } else {\n      throw new Error('Invalid value for the \"when\" parameter');\n    }\n\n    // Manage runner\n    runner.unschedule();\n    runner.timeline(this);\n    const persist = runner.persist();\n    const runnerInfo = {\n      persist: persist === null ? this._persist : persist,\n      start: absoluteStartTime + delay,\n      runner\n    };\n    this._lastRunnerId = runner.id;\n    this._runners.push(runnerInfo);\n    this._runners.sort((a, b) => a.start - b.start);\n    this._runnerIds = this._runners.map(info => info.runner.id);\n    this.updateTime()._continue();\n    return this;\n  }\n  seek(dt) {\n    return this.time(this._time + dt);\n  }\n  source(fn) {\n    if (fn == null) return this._timeSource;\n    this._timeSource = fn;\n    return this;\n  }\n  speed(speed) {\n    if (speed == null) return this._speed;\n    this._speed = speed;\n    return this;\n  }\n  stop() {\n    // Go to start and pause\n    this.time(0);\n    return this.pause();\n  }\n  time(time) {\n    if (time == null) return this._time;\n    this._time = time;\n    return this._continue(true);\n  }\n\n  // Remove the runner from this timeline\n  unschedule(runner) {\n    const index = this._runnerIds.indexOf(runner.id);\n    if (index < 0) return this;\n    this._runners.splice(index, 1);\n    this._runnerIds.splice(index, 1);\n    runner.timeline(null);\n    return this;\n  }\n\n  // Makes sure, that after pausing the time doesn't jump\n  updateTime() {\n    if (!this.active()) {\n      this._lastSourceTime = this._timeSource();\n    }\n    return this;\n  }\n\n  // Checks if we are running and continues the animation\n  _continue(immediateStep = false) {\n    Animator.cancelFrame(this._nextFrame);\n    this._nextFrame = null;\n    if (immediateStep) return this._stepImmediate();\n    if (this._paused) return this;\n    this._nextFrame = Animator.frame(this._step);\n    return this;\n  }\n  _stepFn(immediateStep = false) {\n    // Get the time delta from the last time and update the time\n    const time = this._timeSource();\n    let dtSource = time - this._lastSourceTime;\n    if (immediateStep) dtSource = 0;\n    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime);\n    this._lastSourceTime = time;\n\n    // Only update the time if we use the timeSource.\n    // Otherwise use the current time\n    if (!immediateStep) {\n      // Update the time\n      this._time += dtTime;\n      this._time = this._time < 0 ? 0 : this._time;\n    }\n    this._lastStepTime = this._time;\n    this.fire('time', this._time);\n\n    // This is for the case that the timeline was seeked so that the time\n    // is now before the startTime of the runner. That is why we need to set\n    // the runner to position 0\n\n    // FIXME:\n    // However, resetting in insertion order leads to bugs. Considering the case,\n    // where 2 runners change the same attribute but in different times,\n    // resetting both of them will lead to the case where the later defined\n    // runner always wins the reset even if the other runner started earlier\n    // and therefore should win the attribute battle\n    // this can be solved by resetting them backwards\n    for (let k = this._runners.length; k--;) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[k];\n      const runner = runnerInfo.runner;\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start;\n\n      // Dont run runner if not started yet\n      // and try to reset it\n      if (dtToStart <= 0) {\n        runner.reset();\n      }\n    }\n\n    // Run all of the runners directly\n    let runnersLeft = false;\n    for (let i = 0, len = this._runners.length; i < len; i++) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[i];\n      const runner = runnerInfo.runner;\n      let dt = dtTime;\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start;\n\n      // Dont run runner if not started yet\n      if (dtToStart <= 0) {\n        runnersLeft = true;\n        continue;\n      } else if (dtToStart < dt) {\n        // Adjust dt to make sure that animation is on point\n        dt = dtToStart;\n      }\n      if (!runner.active()) continue;\n\n      // If this runner is still going, signal that we need another animation\n      // frame, otherwise, remove the completed runner\n      const finished = runner.step(dt).done;\n      if (!finished) {\n        runnersLeft = true;\n        // continue\n      } else if (runnerInfo.persist !== true) {\n        // runner is finished. And runner might get removed\n        const endTime = runner.duration() - runner.time() + this._time;\n        if (endTime + runnerInfo.persist < this._time) {\n          // Delete runner and correct index\n          runner.unschedule();\n          --i;\n          --len;\n        }\n      }\n    }\n\n    // Basically: we continue when there are runners right from us in time\n    // when -->, and when runners are left from us when <--\n    if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {\n      this._continue();\n    } else {\n      this.pause();\n      this.fire('finished');\n    }\n    return this;\n  }\n  terminate() {\n    // cleanup memory\n\n    // Store the timing variables\n    this._startTime = 0;\n    this._speed = 1.0;\n\n    // Determines how long a runner is hold in memory. Can be a dt or true/false\n    this._persist = 0;\n\n    // Keep track of the running animations and their starting parameters\n    this._nextFrame = null;\n    this._paused = true;\n    this._runners = [];\n    this._runnerIds = [];\n    this._lastRunnerId = -1;\n    this._time = 0;\n    this._lastSourceTime = 0;\n    this._lastStepTime = 0;\n\n    // Make sure that step is always called in class context\n    this._step = this._stepFn.bind(this, false);\n    this._stepImmediate = this._stepFn.bind(this, true);\n  }\n}\nregisterMethods({\n  Element: {\n    timeline: function (timeline) {\n      if (timeline == null) {\n        this._timeline = this._timeline || new Timeline();\n        return this._timeline;\n      } else {\n        this._timeline = timeline;\n        return this;\n      }\n    }\n  }\n});","map":{"version":3,"names":["globals","registerMethods","Animator","EventTarget","makeSchedule","runnerInfo","start","duration","runner","end","defaultSource","w","window","performance","Date","now","Timeline","constructor","timeSource","_timeSource","terminate","active","_nextFrame","finish","time","getEndTimeOfTimeline","pause","getEndTime","lastRunnerInfo","getLastRunnerInfo","lastDuration","lastStartTime","_time","endTimes","_runners","map","i","Math","max","getRunnerInfoById","_lastRunnerId","id","_runnerIds","indexOf","_paused","_continue","persist","dtOrForever","_persist","play","updateTime","reverse","yes","currentSpeed","speed","positive","abs","schedule","delay","when","absoluteStartTime","endTime","Error","unschedule","timeline","push","sort","a","b","info","seek","dt","source","fn","_speed","stop","index","splice","_lastSourceTime","immediateStep","cancelFrame","_stepImmediate","frame","_step","_stepFn","dtSource","dtTime","_lastStepTime","fire","k","length","dtToStart","reset","runnersLeft","len","finished","step","done","_startTime","bind","Element","_timeline"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/@svgdotjs/svg.js/src/animation/Timeline.js"],"sourcesContent":["import { globals } from '../utils/window.js'\nimport { registerMethods } from '../utils/methods.js'\nimport Animator from './Animator.js'\nimport EventTarget from '../types/EventTarget.js'\n\nconst makeSchedule = function (runnerInfo) {\n  const start = runnerInfo.start\n  const duration = runnerInfo.runner.duration()\n  const end = start + duration\n  return {\n    start: start,\n    duration: duration,\n    end: end,\n    runner: runnerInfo.runner\n  }\n}\n\nconst defaultSource = function () {\n  const w = globals.window\n  return (w.performance || w.Date).now()\n}\n\nexport default class Timeline extends EventTarget {\n  // Construct a new timeline on the given element\n  constructor(timeSource = defaultSource) {\n    super()\n\n    this._timeSource = timeSource\n\n    // terminate resets all variables to their initial state\n    this.terminate()\n  }\n\n  active() {\n    return !!this._nextFrame\n  }\n\n  finish() {\n    // Go to end and pause\n    this.time(this.getEndTimeOfTimeline() + 1)\n    return this.pause()\n  }\n\n  // Calculates the end of the timeline\n  getEndTime() {\n    const lastRunnerInfo = this.getLastRunnerInfo()\n    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0\n    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time\n    return lastStartTime + lastDuration\n  }\n\n  getEndTimeOfTimeline() {\n    const endTimes = this._runners.map((i) => i.start + i.runner.duration())\n    return Math.max(0, ...endTimes)\n  }\n\n  getLastRunnerInfo() {\n    return this.getRunnerInfoById(this._lastRunnerId)\n  }\n\n  getRunnerInfoById(id) {\n    return this._runners[this._runnerIds.indexOf(id)] || null\n  }\n\n  pause() {\n    this._paused = true\n    return this._continue()\n  }\n\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist\n    this._persist = dtOrForever\n    return this\n  }\n\n  play() {\n    // Now make sure we are not paused and continue the animation\n    this._paused = false\n    return this.updateTime()._continue()\n  }\n\n  reverse(yes) {\n    const currentSpeed = this.speed()\n    if (yes == null) return this.speed(-currentSpeed)\n\n    const positive = Math.abs(currentSpeed)\n    return this.speed(yes ? -positive : positive)\n  }\n\n  // schedules a runner on the timeline\n  schedule(runner, delay, when) {\n    if (runner == null) {\n      return this._runners.map(makeSchedule)\n    }\n\n    // The start time for the next animation can either be given explicitly,\n    // derived from the current timeline time or it can be relative to the\n    // last start time to chain animations directly\n\n    let absoluteStartTime = 0\n    const endTime = this.getEndTime()\n    delay = delay || 0\n\n    // Work out when to start the animation\n    if (when == null || when === 'last' || when === 'after') {\n      // Take the last time and increment\n      absoluteStartTime = endTime\n    } else if (when === 'absolute' || when === 'start') {\n      absoluteStartTime = delay\n      delay = 0\n    } else if (when === 'now') {\n      absoluteStartTime = this._time\n    } else if (when === 'relative') {\n      const runnerInfo = this.getRunnerInfoById(runner.id)\n      if (runnerInfo) {\n        absoluteStartTime = runnerInfo.start + delay\n        delay = 0\n      }\n    } else if (when === 'with-last') {\n      const lastRunnerInfo = this.getLastRunnerInfo()\n      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time\n      absoluteStartTime = lastStartTime\n    } else {\n      throw new Error('Invalid value for the \"when\" parameter')\n    }\n\n    // Manage runner\n    runner.unschedule()\n    runner.timeline(this)\n\n    const persist = runner.persist()\n    const runnerInfo = {\n      persist: persist === null ? this._persist : persist,\n      start: absoluteStartTime + delay,\n      runner\n    }\n\n    this._lastRunnerId = runner.id\n\n    this._runners.push(runnerInfo)\n    this._runners.sort((a, b) => a.start - b.start)\n    this._runnerIds = this._runners.map((info) => info.runner.id)\n\n    this.updateTime()._continue()\n    return this\n  }\n\n  seek(dt) {\n    return this.time(this._time + dt)\n  }\n\n  source(fn) {\n    if (fn == null) return this._timeSource\n    this._timeSource = fn\n    return this\n  }\n\n  speed(speed) {\n    if (speed == null) return this._speed\n    this._speed = speed\n    return this\n  }\n\n  stop() {\n    // Go to start and pause\n    this.time(0)\n    return this.pause()\n  }\n\n  time(time) {\n    if (time == null) return this._time\n    this._time = time\n    return this._continue(true)\n  }\n\n  // Remove the runner from this timeline\n  unschedule(runner) {\n    const index = this._runnerIds.indexOf(runner.id)\n    if (index < 0) return this\n\n    this._runners.splice(index, 1)\n    this._runnerIds.splice(index, 1)\n\n    runner.timeline(null)\n    return this\n  }\n\n  // Makes sure, that after pausing the time doesn't jump\n  updateTime() {\n    if (!this.active()) {\n      this._lastSourceTime = this._timeSource()\n    }\n    return this\n  }\n\n  // Checks if we are running and continues the animation\n  _continue(immediateStep = false) {\n    Animator.cancelFrame(this._nextFrame)\n    this._nextFrame = null\n\n    if (immediateStep) return this._stepImmediate()\n    if (this._paused) return this\n\n    this._nextFrame = Animator.frame(this._step)\n    return this\n  }\n\n  _stepFn(immediateStep = false) {\n    // Get the time delta from the last time and update the time\n    const time = this._timeSource()\n    let dtSource = time - this._lastSourceTime\n\n    if (immediateStep) dtSource = 0\n\n    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime)\n    this._lastSourceTime = time\n\n    // Only update the time if we use the timeSource.\n    // Otherwise use the current time\n    if (!immediateStep) {\n      // Update the time\n      this._time += dtTime\n      this._time = this._time < 0 ? 0 : this._time\n    }\n    this._lastStepTime = this._time\n    this.fire('time', this._time)\n\n    // This is for the case that the timeline was seeked so that the time\n    // is now before the startTime of the runner. That is why we need to set\n    // the runner to position 0\n\n    // FIXME:\n    // However, resetting in insertion order leads to bugs. Considering the case,\n    // where 2 runners change the same attribute but in different times,\n    // resetting both of them will lead to the case where the later defined\n    // runner always wins the reset even if the other runner started earlier\n    // and therefore should win the attribute battle\n    // this can be solved by resetting them backwards\n    for (let k = this._runners.length; k--; ) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[k]\n      const runner = runnerInfo.runner\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start\n\n      // Dont run runner if not started yet\n      // and try to reset it\n      if (dtToStart <= 0) {\n        runner.reset()\n      }\n    }\n\n    // Run all of the runners directly\n    let runnersLeft = false\n    for (let i = 0, len = this._runners.length; i < len; i++) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[i]\n      const runner = runnerInfo.runner\n      let dt = dtTime\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start\n\n      // Dont run runner if not started yet\n      if (dtToStart <= 0) {\n        runnersLeft = true\n        continue\n      } else if (dtToStart < dt) {\n        // Adjust dt to make sure that animation is on point\n        dt = dtToStart\n      }\n\n      if (!runner.active()) continue\n\n      // If this runner is still going, signal that we need another animation\n      // frame, otherwise, remove the completed runner\n      const finished = runner.step(dt).done\n      if (!finished) {\n        runnersLeft = true\n        // continue\n      } else if (runnerInfo.persist !== true) {\n        // runner is finished. And runner might get removed\n        const endTime = runner.duration() - runner.time() + this._time\n\n        if (endTime + runnerInfo.persist < this._time) {\n          // Delete runner and correct index\n          runner.unschedule()\n          --i\n          --len\n        }\n      }\n    }\n\n    // Basically: we continue when there are runners right from us in time\n    // when -->, and when runners are left from us when <--\n    if (\n      (runnersLeft && !(this._speed < 0 && this._time === 0)) ||\n      (this._runnerIds.length && this._speed < 0 && this._time > 0)\n    ) {\n      this._continue()\n    } else {\n      this.pause()\n      this.fire('finished')\n    }\n\n    return this\n  }\n\n  terminate() {\n    // cleanup memory\n\n    // Store the timing variables\n    this._startTime = 0\n    this._speed = 1.0\n\n    // Determines how long a runner is hold in memory. Can be a dt or true/false\n    this._persist = 0\n\n    // Keep track of the running animations and their starting parameters\n    this._nextFrame = null\n    this._paused = true\n    this._runners = []\n    this._runnerIds = []\n    this._lastRunnerId = -1\n    this._time = 0\n    this._lastSourceTime = 0\n    this._lastStepTime = 0\n\n    // Make sure that step is always called in class context\n    this._step = this._stepFn.bind(this, false)\n    this._stepImmediate = this._stepFn.bind(this, true)\n  }\n}\n\nregisterMethods({\n  Element: {\n    timeline: function (timeline) {\n      if (timeline == null) {\n        this._timeline = this._timeline || new Timeline()\n        return this._timeline\n      } else {\n        this._timeline = timeline\n        return this\n      }\n    }\n  }\n})\n"],"mappings":";AAAA,SAASA,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,eAAe,QAAQ,qBAAqB;AACrD,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,WAAW,MAAM,yBAAyB;AAEjD,MAAMC,YAAY,GAAG,SAAAA,CAAUC,UAAU,EAAE;EACzC,MAAMC,KAAK,GAAGD,UAAU,CAACC,KAAK;EAC9B,MAAMC,QAAQ,GAAGF,UAAU,CAACG,MAAM,CAACD,QAAQ,CAAC,CAAC;EAC7C,MAAME,GAAG,GAAGH,KAAK,GAAGC,QAAQ;EAC5B,OAAO;IACLD,KAAK,EAAEA,KAAK;IACZC,QAAQ,EAAEA,QAAQ;IAClBE,GAAG,EAAEA,GAAG;IACRD,MAAM,EAAEH,UAAU,CAACG;EACrB,CAAC;AACH,CAAC;AAED,MAAME,aAAa,GAAG,SAAAA,CAAA,EAAY;EAChC,MAAMC,CAAC,GAAGX,OAAO,CAACY,MAAM;EACxB,OAAO,CAACD,CAAC,CAACE,WAAW,IAAIF,CAAC,CAACG,IAAI,EAAEC,GAAG,CAAC,CAAC;AACxC,CAAC;AAED,eAAe,MAAMC,QAAQ,SAASb,WAAW,CAAC;EAChD;EACAc,WAAWA,CAACC,UAAU,GAAGR,aAAa,EAAE;IACtC,KAAK,CAAC,CAAC;IAEP,IAAI,CAACS,WAAW,GAAGD,UAAU;;IAE7B;IACA,IAAI,CAACE,SAAS,CAAC,CAAC;EAClB;EAEAC,MAAMA,CAAA,EAAG;IACP,OAAO,CAAC,CAAC,IAAI,CAACC,UAAU;EAC1B;EAEAC,MAAMA,CAAA,EAAG;IACP;IACA,IAAI,CAACC,IAAI,CAAC,IAAI,CAACC,oBAAoB,CAAC,CAAC,GAAG,CAAC,CAAC;IAC1C,OAAO,IAAI,CAACC,KAAK,CAAC,CAAC;EACrB;;EAEA;EACAC,UAAUA,CAAA,EAAG;IACX,MAAMC,cAAc,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;IAC/C,MAAMC,YAAY,GAAGF,cAAc,GAAGA,cAAc,CAACpB,MAAM,CAACD,QAAQ,CAAC,CAAC,GAAG,CAAC;IAC1E,MAAMwB,aAAa,GAAGH,cAAc,GAAGA,cAAc,CAACtB,KAAK,GAAG,IAAI,CAAC0B,KAAK;IACxE,OAAOD,aAAa,GAAGD,YAAY;EACrC;EAEAL,oBAAoBA,CAAA,EAAG;IACrB,MAAMQ,QAAQ,GAAG,IAAI,CAACC,QAAQ,CAACC,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAAC9B,KAAK,GAAG8B,CAAC,CAAC5B,MAAM,CAACD,QAAQ,CAAC,CAAC,CAAC;IACxE,OAAO8B,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,GAAGL,QAAQ,CAAC;EACjC;EAEAJ,iBAAiBA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACU,iBAAiB,CAAC,IAAI,CAACC,aAAa,CAAC;EACnD;EAEAD,iBAAiBA,CAACE,EAAE,EAAE;IACpB,OAAO,IAAI,CAACP,QAAQ,CAAC,IAAI,CAACQ,UAAU,CAACC,OAAO,CAACF,EAAE,CAAC,CAAC,IAAI,IAAI;EAC3D;EAEAf,KAAKA,CAAA,EAAG;IACN,IAAI,CAACkB,OAAO,GAAG,IAAI;IACnB,OAAO,IAAI,CAACC,SAAS,CAAC,CAAC;EACzB;EAEAC,OAAOA,CAACC,WAAW,EAAE;IACnB,IAAIA,WAAW,IAAI,IAAI,EAAE,OAAO,IAAI,CAACC,QAAQ;IAC7C,IAAI,CAACA,QAAQ,GAAGD,WAAW;IAC3B,OAAO,IAAI;EACb;EAEAE,IAAIA,CAAA,EAAG;IACL;IACA,IAAI,CAACL,OAAO,GAAG,KAAK;IACpB,OAAO,IAAI,CAACM,UAAU,CAAC,CAAC,CAACL,SAAS,CAAC,CAAC;EACtC;EAEAM,OAAOA,CAACC,GAAG,EAAE;IACX,MAAMC,YAAY,GAAG,IAAI,CAACC,KAAK,CAAC,CAAC;IACjC,IAAIF,GAAG,IAAI,IAAI,EAAE,OAAO,IAAI,CAACE,KAAK,CAAC,CAACD,YAAY,CAAC;IAEjD,MAAME,QAAQ,GAAGlB,IAAI,CAACmB,GAAG,CAACH,YAAY,CAAC;IACvC,OAAO,IAAI,CAACC,KAAK,CAACF,GAAG,GAAG,CAACG,QAAQ,GAAGA,QAAQ,CAAC;EAC/C;;EAEA;EACAE,QAAQA,CAACjD,MAAM,EAAEkD,KAAK,EAAEC,IAAI,EAAE;IAC5B,IAAInD,MAAM,IAAI,IAAI,EAAE;MAClB,OAAO,IAAI,CAAC0B,QAAQ,CAACC,GAAG,CAAC/B,YAAY,CAAC;IACxC;;IAEA;IACA;IACA;;IAEA,IAAIwD,iBAAiB,GAAG,CAAC;IACzB,MAAMC,OAAO,GAAG,IAAI,CAAClC,UAAU,CAAC,CAAC;IACjC+B,KAAK,GAAGA,KAAK,IAAI,CAAC;;IAElB;IACA,IAAIC,IAAI,IAAI,IAAI,IAAIA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,OAAO,EAAE;MACvD;MACAC,iBAAiB,GAAGC,OAAO;IAC7B,CAAC,MAAM,IAAIF,IAAI,KAAK,UAAU,IAAIA,IAAI,KAAK,OAAO,EAAE;MAClDC,iBAAiB,GAAGF,KAAK;MACzBA,KAAK,GAAG,CAAC;IACX,CAAC,MAAM,IAAIC,IAAI,KAAK,KAAK,EAAE;MACzBC,iBAAiB,GAAG,IAAI,CAAC5B,KAAK;IAChC,CAAC,MAAM,IAAI2B,IAAI,KAAK,UAAU,EAAE;MAC9B,MAAMtD,UAAU,GAAG,IAAI,CAACkC,iBAAiB,CAAC/B,MAAM,CAACiC,EAAE,CAAC;MACpD,IAAIpC,UAAU,EAAE;QACduD,iBAAiB,GAAGvD,UAAU,CAACC,KAAK,GAAGoD,KAAK;QAC5CA,KAAK,GAAG,CAAC;MACX;IACF,CAAC,MAAM,IAAIC,IAAI,KAAK,WAAW,EAAE;MAC/B,MAAM/B,cAAc,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;MAC/C,MAAME,aAAa,GAAGH,cAAc,GAAGA,cAAc,CAACtB,KAAK,GAAG,IAAI,CAAC0B,KAAK;MACxE4B,iBAAiB,GAAG7B,aAAa;IACnC,CAAC,MAAM;MACL,MAAM,IAAI+B,KAAK,CAAC,wCAAwC,CAAC;IAC3D;;IAEA;IACAtD,MAAM,CAACuD,UAAU,CAAC,CAAC;IACnBvD,MAAM,CAACwD,QAAQ,CAAC,IAAI,CAAC;IAErB,MAAMlB,OAAO,GAAGtC,MAAM,CAACsC,OAAO,CAAC,CAAC;IAChC,MAAMzC,UAAU,GAAG;MACjByC,OAAO,EAAEA,OAAO,KAAK,IAAI,GAAG,IAAI,CAACE,QAAQ,GAAGF,OAAO;MACnDxC,KAAK,EAAEsD,iBAAiB,GAAGF,KAAK;MAChClD;IACF,CAAC;IAED,IAAI,CAACgC,aAAa,GAAGhC,MAAM,CAACiC,EAAE;IAE9B,IAAI,CAACP,QAAQ,CAAC+B,IAAI,CAAC5D,UAAU,CAAC;IAC9B,IAAI,CAAC6B,QAAQ,CAACgC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAC7D,KAAK,GAAG8D,CAAC,CAAC9D,KAAK,CAAC;IAC/C,IAAI,CAACoC,UAAU,GAAG,IAAI,CAACR,QAAQ,CAACC,GAAG,CAAEkC,IAAI,IAAKA,IAAI,CAAC7D,MAAM,CAACiC,EAAE,CAAC;IAE7D,IAAI,CAACS,UAAU,CAAC,CAAC,CAACL,SAAS,CAAC,CAAC;IAC7B,OAAO,IAAI;EACb;EAEAyB,IAAIA,CAACC,EAAE,EAAE;IACP,OAAO,IAAI,CAAC/C,IAAI,CAAC,IAAI,CAACQ,KAAK,GAAGuC,EAAE,CAAC;EACnC;EAEAC,MAAMA,CAACC,EAAE,EAAE;IACT,IAAIA,EAAE,IAAI,IAAI,EAAE,OAAO,IAAI,CAACtD,WAAW;IACvC,IAAI,CAACA,WAAW,GAAGsD,EAAE;IACrB,OAAO,IAAI;EACb;EAEAnB,KAAKA,CAACA,KAAK,EAAE;IACX,IAAIA,KAAK,IAAI,IAAI,EAAE,OAAO,IAAI,CAACoB,MAAM;IACrC,IAAI,CAACA,MAAM,GAAGpB,KAAK;IACnB,OAAO,IAAI;EACb;EAEAqB,IAAIA,CAAA,EAAG;IACL;IACA,IAAI,CAACnD,IAAI,CAAC,CAAC,CAAC;IACZ,OAAO,IAAI,CAACE,KAAK,CAAC,CAAC;EACrB;EAEAF,IAAIA,CAACA,IAAI,EAAE;IACT,IAAIA,IAAI,IAAI,IAAI,EAAE,OAAO,IAAI,CAACQ,KAAK;IACnC,IAAI,CAACA,KAAK,GAAGR,IAAI;IACjB,OAAO,IAAI,CAACqB,SAAS,CAAC,IAAI,CAAC;EAC7B;;EAEA;EACAkB,UAAUA,CAACvD,MAAM,EAAE;IACjB,MAAMoE,KAAK,GAAG,IAAI,CAAClC,UAAU,CAACC,OAAO,CAACnC,MAAM,CAACiC,EAAE,CAAC;IAChD,IAAImC,KAAK,GAAG,CAAC,EAAE,OAAO,IAAI;IAE1B,IAAI,CAAC1C,QAAQ,CAAC2C,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;IAC9B,IAAI,CAAClC,UAAU,CAACmC,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;IAEhCpE,MAAM,CAACwD,QAAQ,CAAC,IAAI,CAAC;IACrB,OAAO,IAAI;EACb;;EAEA;EACAd,UAAUA,CAAA,EAAG;IACX,IAAI,CAAC,IAAI,CAAC7B,MAAM,CAAC,CAAC,EAAE;MAClB,IAAI,CAACyD,eAAe,GAAG,IAAI,CAAC3D,WAAW,CAAC,CAAC;IAC3C;IACA,OAAO,IAAI;EACb;;EAEA;EACA0B,SAASA,CAACkC,aAAa,GAAG,KAAK,EAAE;IAC/B7E,QAAQ,CAAC8E,WAAW,CAAC,IAAI,CAAC1D,UAAU,CAAC;IACrC,IAAI,CAACA,UAAU,GAAG,IAAI;IAEtB,IAAIyD,aAAa,EAAE,OAAO,IAAI,CAACE,cAAc,CAAC,CAAC;IAC/C,IAAI,IAAI,CAACrC,OAAO,EAAE,OAAO,IAAI;IAE7B,IAAI,CAACtB,UAAU,GAAGpB,QAAQ,CAACgF,KAAK,CAAC,IAAI,CAACC,KAAK,CAAC;IAC5C,OAAO,IAAI;EACb;EAEAC,OAAOA,CAACL,aAAa,GAAG,KAAK,EAAE;IAC7B;IACA,MAAMvD,IAAI,GAAG,IAAI,CAACL,WAAW,CAAC,CAAC;IAC/B,IAAIkE,QAAQ,GAAG7D,IAAI,GAAG,IAAI,CAACsD,eAAe;IAE1C,IAAIC,aAAa,EAAEM,QAAQ,GAAG,CAAC;IAE/B,MAAMC,MAAM,GAAG,IAAI,CAACZ,MAAM,GAAGW,QAAQ,IAAI,IAAI,CAACrD,KAAK,GAAG,IAAI,CAACuD,aAAa,CAAC;IACzE,IAAI,CAACT,eAAe,GAAGtD,IAAI;;IAE3B;IACA;IACA,IAAI,CAACuD,aAAa,EAAE;MAClB;MACA,IAAI,CAAC/C,KAAK,IAAIsD,MAAM;MACpB,IAAI,CAACtD,KAAK,GAAG,IAAI,CAACA,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAACA,KAAK;IAC9C;IACA,IAAI,CAACuD,aAAa,GAAG,IAAI,CAACvD,KAAK;IAC/B,IAAI,CAACwD,IAAI,CAAC,MAAM,EAAE,IAAI,CAACxD,KAAK,CAAC;;IAE7B;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,IAAIyD,CAAC,GAAG,IAAI,CAACvD,QAAQ,CAACwD,MAAM,EAAED,CAAC,EAAE,GAAI;MACxC;MACA,MAAMpF,UAAU,GAAG,IAAI,CAAC6B,QAAQ,CAACuD,CAAC,CAAC;MACnC,MAAMjF,MAAM,GAAGH,UAAU,CAACG,MAAM;;MAEhC;MACA;MACA,MAAMmF,SAAS,GAAG,IAAI,CAAC3D,KAAK,GAAG3B,UAAU,CAACC,KAAK;;MAE/C;MACA;MACA,IAAIqF,SAAS,IAAI,CAAC,EAAE;QAClBnF,MAAM,CAACoF,KAAK,CAAC,CAAC;MAChB;IACF;;IAEA;IACA,IAAIC,WAAW,GAAG,KAAK;IACvB,KAAK,IAAIzD,CAAC,GAAG,CAAC,EAAE0D,GAAG,GAAG,IAAI,CAAC5D,QAAQ,CAACwD,MAAM,EAAEtD,CAAC,GAAG0D,GAAG,EAAE1D,CAAC,EAAE,EAAE;MACxD;MACA,MAAM/B,UAAU,GAAG,IAAI,CAAC6B,QAAQ,CAACE,CAAC,CAAC;MACnC,MAAM5B,MAAM,GAAGH,UAAU,CAACG,MAAM;MAChC,IAAI+D,EAAE,GAAGe,MAAM;;MAEf;MACA;MACA,MAAMK,SAAS,GAAG,IAAI,CAAC3D,KAAK,GAAG3B,UAAU,CAACC,KAAK;;MAE/C;MACA,IAAIqF,SAAS,IAAI,CAAC,EAAE;QAClBE,WAAW,GAAG,IAAI;QAClB;MACF,CAAC,MAAM,IAAIF,SAAS,GAAGpB,EAAE,EAAE;QACzB;QACAA,EAAE,GAAGoB,SAAS;MAChB;MAEA,IAAI,CAACnF,MAAM,CAACa,MAAM,CAAC,CAAC,EAAE;;MAEtB;MACA;MACA,MAAM0E,QAAQ,GAAGvF,MAAM,CAACwF,IAAI,CAACzB,EAAE,CAAC,CAAC0B,IAAI;MACrC,IAAI,CAACF,QAAQ,EAAE;QACbF,WAAW,GAAG,IAAI;QAClB;MACF,CAAC,MAAM,IAAIxF,UAAU,CAACyC,OAAO,KAAK,IAAI,EAAE;QACtC;QACA,MAAMe,OAAO,GAAGrD,MAAM,CAACD,QAAQ,CAAC,CAAC,GAAGC,MAAM,CAACgB,IAAI,CAAC,CAAC,GAAG,IAAI,CAACQ,KAAK;QAE9D,IAAI6B,OAAO,GAAGxD,UAAU,CAACyC,OAAO,GAAG,IAAI,CAACd,KAAK,EAAE;UAC7C;UACAxB,MAAM,CAACuD,UAAU,CAAC,CAAC;UACnB,EAAE3B,CAAC;UACH,EAAE0D,GAAG;QACP;MACF;IACF;;IAEA;IACA;IACA,IACGD,WAAW,IAAI,EAAE,IAAI,CAACnB,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC1C,KAAK,KAAK,CAAC,CAAC,IACrD,IAAI,CAACU,UAAU,CAACgD,MAAM,IAAI,IAAI,CAAChB,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC1C,KAAK,GAAG,CAAE,EAC7D;MACA,IAAI,CAACa,SAAS,CAAC,CAAC;IAClB,CAAC,MAAM;MACL,IAAI,CAACnB,KAAK,CAAC,CAAC;MACZ,IAAI,CAAC8D,IAAI,CAAC,UAAU,CAAC;IACvB;IAEA,OAAO,IAAI;EACb;EAEApE,SAASA,CAAA,EAAG;IACV;;IAEA;IACA,IAAI,CAAC8E,UAAU,GAAG,CAAC;IACnB,IAAI,CAACxB,MAAM,GAAG,GAAG;;IAEjB;IACA,IAAI,CAAC1B,QAAQ,GAAG,CAAC;;IAEjB;IACA,IAAI,CAAC1B,UAAU,GAAG,IAAI;IACtB,IAAI,CAACsB,OAAO,GAAG,IAAI;IACnB,IAAI,CAACV,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACQ,UAAU,GAAG,EAAE;IACpB,IAAI,CAACF,aAAa,GAAG,CAAC,CAAC;IACvB,IAAI,CAACR,KAAK,GAAG,CAAC;IACd,IAAI,CAAC8C,eAAe,GAAG,CAAC;IACxB,IAAI,CAACS,aAAa,GAAG,CAAC;;IAEtB;IACA,IAAI,CAACJ,KAAK,GAAG,IAAI,CAACC,OAAO,CAACe,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC;IAC3C,IAAI,CAAClB,cAAc,GAAG,IAAI,CAACG,OAAO,CAACe,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;EACrD;AACF;AAEAlG,eAAe,CAAC;EACdmG,OAAO,EAAE;IACPpC,QAAQ,EAAE,SAAAA,CAAUA,QAAQ,EAAE;MAC5B,IAAIA,QAAQ,IAAI,IAAI,EAAE;QACpB,IAAI,CAACqC,SAAS,GAAG,IAAI,CAACA,SAAS,IAAI,IAAIrF,QAAQ,CAAC,CAAC;QACjD,OAAO,IAAI,CAACqF,SAAS;MACvB,CAAC,MAAM;QACL,IAAI,CAACA,SAAS,GAAGrC,QAAQ;QACzB,OAAO,IAAI;MACb;IACF;EACF;AACF,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}