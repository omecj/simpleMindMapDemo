{"ast":null,"code":"import Base from './Base';\nimport { walk, asyncRun, getNodeIndexInNodeList } from '../utils';\nimport { CONSTANTS } from '../constants/constant';\n\n//  思维导图\nclass MindMap extends Base {\n  //  构造函数\n  // 在逻辑结构图的基础上增加一个变量来记录生长方向，向左还是向右，同时在计算left的时候根据方向来计算、调整top时只考虑同方向的节点即可\n  constructor(opt = {}) {\n    super(opt);\n  }\n\n  //  布局\n  doLayout(callback) {\n    let task = [() => {\n      this.computedBaseValue();\n    }, () => {\n      this.computedTopValue();\n    }, () => {\n      this.adjustTopValue();\n    }, () => {\n      callback(this.root);\n    }];\n    asyncRun(task);\n  }\n\n  //  遍历数据计算节点的left、width、height\n  computedBaseValue() {\n    walk(this.renderer.renderTree, null, (cur, parent, isRoot, layerIndex, index) => {\n      let newNode = this.createNode(cur, parent, isRoot, layerIndex);\n      // 根节点定位在画布中心位置\n      if (isRoot) {\n        this.setNodeCenter(newNode);\n      } else {\n        // 非根节点\n        // 三级及以下节点以上级为准\n        if (parent._node.dir) {\n          newNode.dir = parent._node.dir;\n        } else {\n          // 节点生长方向\n          newNode.dir = index % 2 === 0 ? CONSTANTS.LAYOUT_GROW_DIR.RIGHT : CONSTANTS.LAYOUT_GROW_DIR.LEFT;\n        }\n        // 根据生长方向定位到父节点的左侧或右侧\n        newNode.left = newNode.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT ? parent._node.left + parent._node.width + this.getMarginX(layerIndex) : parent._node.left - this.getMarginX(layerIndex) - newNode.width;\n      }\n      if (!cur.data.expand) {\n        return true;\n      }\n    }, (cur, parent, isRoot, layerIndex) => {\n      // 返回时计算节点的leftChildrenAreaHeight和rightChildrenAreaHeight，也就是左侧和右侧子节点所占的高度之和，包括外边距\n      if (!cur.data.expand) {\n        cur._node.leftChildrenAreaHeight = 0;\n        cur._node.rightChildrenAreaHeight = 0;\n        return;\n      }\n      // 理论上只有根节点是存在两个方向的子节点的，其他节点的子节点一定全都是同方向，但是为了逻辑统一，就不按特殊处理的方式来写了\n      let leftLen = 0;\n      let rightLen = 0;\n      let leftChildrenAreaHeight = 0;\n      let rightChildrenAreaHeight = 0;\n      cur._node.children.forEach(item => {\n        if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\n          leftLen++;\n          leftChildrenAreaHeight += item.height;\n        } else {\n          rightLen++;\n          rightChildrenAreaHeight += item.height;\n        }\n      });\n      cur._node.leftChildrenAreaHeight = leftChildrenAreaHeight + (leftLen + 1) * this.getMarginY(layerIndex + 1);\n      cur._node.rightChildrenAreaHeight = rightChildrenAreaHeight + (rightLen + 1) * this.getMarginY(layerIndex + 1);\n\n      // 如果存在概要，则和概要的高度取最大值\n      let generalizationNodeHeight = cur._node.checkHasGeneralization() ? cur._node._generalizationNodeHeight + this.getMarginY(layerIndex + 1) : 0;\n      cur._node.leftChildrenAreaHeight2 = Math.max(cur._node.leftChildrenAreaHeight, generalizationNodeHeight);\n      cur._node.rightChildrenAreaHeight2 = Math.max(cur._node.rightChildrenAreaHeight, generalizationNodeHeight);\n    }, true, 0);\n  }\n\n  //  遍历节点树计算节点的top\n  computedTopValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (node.getData('expand') && node.children && node.children.length) {\n        let marginY = this.getMarginY(layerIndex + 1);\n        let baseTop = node.top + node.height / 2 + marginY;\n        // 第一个子节点的top值 = 该节点中心的top值 - 子节点的高度之和的一半\n        let leftTotalTop = baseTop - node.leftChildrenAreaHeight / 2;\n        let rightTotalTop = baseTop - node.rightChildrenAreaHeight / 2;\n        node.children.forEach(cur => {\n          if (cur.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\n            cur.top = leftTotalTop;\n            leftTotalTop += cur.height + marginY;\n          } else {\n            cur.top = rightTotalTop;\n            rightTotalTop += cur.height + marginY;\n          }\n        });\n      }\n    }, null, true);\n  }\n\n  //  调整节点top\n  adjustTopValue() {\n    walk(this.root, null, (node, parent, isRoot, layerIndex) => {\n      if (!node.getData('expand')) {\n        return;\n      }\n      // 判断子节点所占的高度之和是否大于该节点自身，大于则需要调整位置\n      let base = this.getMarginY(layerIndex + 1) * 2 + node.height;\n      let leftDifference = node.leftChildrenAreaHeight2 - base;\n      let rightDifference = node.rightChildrenAreaHeight2 - base;\n      if (leftDifference > 0 || rightDifference > 0) {\n        this.updateBrothers(node, leftDifference / 2, rightDifference / 2);\n      }\n    }, null, true);\n  }\n\n  //  更新兄弟节点的top\n  updateBrothers(node, leftAddHeight, rightAddHeight) {\n    if (node.parent) {\n      // 过滤出和自己同方向的节点\n      let childrenList = node.parent.children.filter(item => {\n        return item.dir === node.dir;\n      });\n      let index = getNodeIndexInNodeList(node, childrenList);\n      childrenList.forEach((item, _index) => {\n        if (item.hasCustomPosition()) {\n          // 适配自定义位置\n          return;\n        }\n        let _offset = 0;\n        let addHeight = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? leftAddHeight : rightAddHeight;\n        // 上面的节点往上移\n        if (_index < index) {\n          _offset = -addHeight;\n        } else if (_index > index) {\n          // 下面的节点往下移\n          _offset = addHeight;\n        }\n        item.top += _offset;\n        // 同步更新子节点的位置\n        if (item.children && item.children.length) {\n          this.updateChildren(item.children, 'top', _offset);\n        }\n      });\n      // 更新父节点的位置\n      this.updateBrothers(node.parent, leftAddHeight, rightAddHeight);\n    }\n  }\n\n  //  绘制连线，连接该节点到其子节点\n  renderLine(node, lines, style, lineStyle) {\n    if (lineStyle === 'curve') {\n      this.renderLineCurve(node, lines, style);\n    } else if (lineStyle === 'direct') {\n      this.renderLineDirect(node, lines, style);\n    } else {\n      this.renderLineStraight(node, lines, style);\n    }\n  }\n\n  //  直线风格连线\n  renderLineStraight(node, lines, style) {\n    if (node.children.length <= 0) {\n      return [];\n    }\n    let {\n      left,\n      top,\n      width,\n      height,\n      expandBtnSize\n    } = node;\n    if (!this.mindMap.opt.alwaysShowExpandBtn) {\n      expandBtnSize = 0;\n    }\n    let marginX = this.getMarginX(node.layerIndex + 1);\n    let s1 = (marginX - expandBtnSize) * 0.6;\n    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle;\n    node.children.forEach((item, index) => {\n      let x1 = 0;\n      let _s = 0;\n      // 节点使用横线风格，需要额外渲染横线\n      let nodeUseLineStyleOffset = nodeUseLineStyle ? item.width : 0;\n      if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\n        _s = -s1;\n        x1 = node.layerIndex === 0 ? left : left - expandBtnSize;\n        nodeUseLineStyleOffset = -nodeUseLineStyleOffset;\n      } else {\n        _s = s1;\n        x1 = node.layerIndex === 0 ? left + width : left + width + expandBtnSize;\n      }\n      let y1 = top + height / 2;\n      let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;\n      let y2 = item.top + item.height / 2;\n      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1;\n      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2;\n      let path = this.createFoldLine([[x1, y1], [x1 + _s, y1], [x1 + _s, y2], [x2 + nodeUseLineStyleOffset, y2]]);\n      this.setLineStyle(style, lines[index], path, item);\n    });\n  }\n\n  //  直连风格\n  renderLineDirect(node, lines, style) {\n    if (node.children.length <= 0) {\n      return [];\n    }\n    let {\n      left,\n      top,\n      width,\n      height,\n      expandBtnSize\n    } = node;\n    if (!this.mindMap.opt.alwaysShowExpandBtn) {\n      expandBtnSize = 0;\n    }\n    const {\n      nodeUseLineStyle\n    } = this.mindMap.themeConfig;\n    node.children.forEach((item, index) => {\n      if (node.layerIndex === 0) {\n        expandBtnSize = 0;\n      }\n      let x1 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width + expandBtnSize;\n      let y1 = top + height / 2;\n      let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;\n      let y2 = item.top + item.height / 2;\n      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1;\n      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2;\n      // 节点使用横线风格，需要额外渲染横线\n      let nodeUseLineStylePath = '';\n      if (nodeUseLineStyle) {\n        if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\n          nodeUseLineStylePath = ` L ${item.left},${y2}`;\n        } else {\n          nodeUseLineStylePath = ` L ${item.left + item.width},${y2}`;\n        }\n      }\n      let path = `M ${x1},${y1} L ${x2},${y2}` + nodeUseLineStylePath;\n      this.setLineStyle(style, lines[index], path, item);\n    });\n  }\n\n  //  曲线风格连线\n  renderLineCurve(node, lines, style) {\n    if (node.children.length <= 0) {\n      return [];\n    }\n    let {\n      left,\n      top,\n      width,\n      height,\n      expandBtnSize\n    } = node;\n    if (!this.mindMap.opt.alwaysShowExpandBtn) {\n      expandBtnSize = 0;\n    }\n    const {\n      nodeUseLineStyle,\n      rootLineKeepSameInCurve,\n      rootLineStartPositionKeepSameInCurve\n    } = this.mindMap.themeConfig;\n    node.children.forEach((item, index) => {\n      if (node.layerIndex === 0) {\n        expandBtnSize = 0;\n      }\n      let x1 = node.layerIndex === 0 && !rootLineStartPositionKeepSameInCurve ? left + width / 2 : item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? left - expandBtnSize : left + width + expandBtnSize;\n      let y1 = top + height / 2;\n      let x2 = item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? item.left + item.width : item.left;\n      let y2 = item.top + item.height / 2;\n      let path = '';\n      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1;\n      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2;\n      // 节点使用横线风格，需要额外渲染横线\n      let nodeUseLineStylePath = '';\n      if (nodeUseLineStyle) {\n        if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\n          nodeUseLineStylePath = ` L ${item.left},${y2}`;\n        } else {\n          nodeUseLineStylePath = ` L ${item.left + item.width},${y2}`;\n        }\n      }\n      if (node.isRoot && !rootLineKeepSameInCurve) {\n        path = this.quadraticCurvePath(x1, y1, x2, y2) + nodeUseLineStylePath;\n      } else {\n        path = this.cubicBezierPath(x1, y1, x2, y2) + nodeUseLineStylePath;\n      }\n      this.setLineStyle(style, lines[index], path, item);\n    });\n  }\n\n  //  渲染按钮\n  renderExpandBtn(node, btn) {\n    let {\n      width,\n      height,\n      expandBtnSize\n    } = node;\n    let {\n      translateX,\n      translateY\n    } = btn.transform();\n    // 节点使用横线风格，需要调整展开收起按钮位置\n    let nodeUseLineStyleOffset = this.mindMap.themeConfig.nodeUseLineStyle ? height / 2 : 0;\n    // 位置没有变化则返回\n    let _x = node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? 0 - expandBtnSize : width;\n    let _y = height / 2 + nodeUseLineStyleOffset;\n    if (_x === translateX && _y === translateY) {\n      return;\n    }\n    let x = _x - translateX;\n    let y = _y - translateY;\n    btn.translate(x, y);\n  }\n\n  //  创建概要节点\n  renderGeneralization(list) {\n    list.forEach(item => {\n      let isLeft = item.node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT;\n      let {\n        top,\n        bottom,\n        left,\n        right,\n        generalizationLineMargin,\n        generalizationNodeMargin\n      } = this.getNodeGeneralizationRenderBoundaries(item, 'h');\n      let x = isLeft ? left - generalizationLineMargin : right + generalizationLineMargin;\n      let x1 = x;\n      let y1 = top;\n      let x2 = x;\n      let y2 = bottom;\n      let cx = x1 + (isLeft ? -20 : 20);\n      let cy = y1 + (y2 - y1) / 2;\n      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`;\n      item.generalizationLine.plot(path);\n      item.generalizationNode.left = x + (isLeft ? -generalizationNodeMargin : generalizationNodeMargin) - (isLeft ? item.generalizationNode.width : 0);\n      item.generalizationNode.top = top + (bottom - top - item.generalizationNode.height) / 2;\n    });\n  }\n\n  // 渲染展开收起按钮的隐藏占位元素\n  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {\n    if (node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\n      rect.size(expandBtnSize, height).x(-expandBtnSize).y(0);\n    } else {\n      rect.size(expandBtnSize, height).x(width).y(0);\n    }\n  }\n}\nexport default MindMap;","map":{"version":3,"names":["Base","walk","asyncRun","getNodeIndexInNodeList","CONSTANTS","MindMap","constructor","opt","doLayout","callback","task","computedBaseValue","computedTopValue","adjustTopValue","root","renderer","renderTree","cur","parent","isRoot","layerIndex","index","newNode","createNode","setNodeCenter","_node","dir","LAYOUT_GROW_DIR","RIGHT","LEFT","left","width","getMarginX","data","expand","leftChildrenAreaHeight","rightChildrenAreaHeight","leftLen","rightLen","children","forEach","item","height","getMarginY","generalizationNodeHeight","checkHasGeneralization","_generalizationNodeHeight","leftChildrenAreaHeight2","Math","max","rightChildrenAreaHeight2","node","getData","length","marginY","baseTop","top","leftTotalTop","rightTotalTop","base","leftDifference","rightDifference","updateBrothers","leftAddHeight","rightAddHeight","childrenList","filter","_index","hasCustomPosition","_offset","addHeight","updateChildren","renderLine","lines","style","lineStyle","renderLineCurve","renderLineDirect","renderLineStraight","expandBtnSize","mindMap","alwaysShowExpandBtn","marginX","s1","nodeUseLineStyle","themeConfig","x1","_s","nodeUseLineStyleOffset","y1","x2","y2","path","createFoldLine","setLineStyle","nodeUseLineStylePath","rootLineKeepSameInCurve","rootLineStartPositionKeepSameInCurve","quadraticCurvePath","cubicBezierPath","renderExpandBtn","btn","translateX","translateY","transform","_x","_y","x","y","translate","renderGeneralization","list","isLeft","bottom","right","generalizationLineMargin","generalizationNodeMargin","getNodeGeneralizationRenderBoundaries","cx","cy","generalizationLine","plot","generalizationNode","renderExpandBtnRect","rect","size"],"sources":["C:/Users/otff/Desktop/mindmap_demo/mind_demo/node_modules/simple-mind-map/src/layouts/MindMap.js"],"sourcesContent":["import Base from './Base'\r\nimport { walk, asyncRun, getNodeIndexInNodeList } from '../utils'\r\nimport { CONSTANTS } from '../constants/constant'\r\n\r\n//  思维导图\r\nclass MindMap extends Base {\r\n  //  构造函数\r\n  // 在逻辑结构图的基础上增加一个变量来记录生长方向，向左还是向右，同时在计算left的时候根据方向来计算、调整top时只考虑同方向的节点即可\r\n  constructor(opt = {}) {\r\n    super(opt)\r\n  }\r\n\r\n  //  布局\r\n  doLayout(callback) {\r\n    let task = [\r\n      () => {\r\n        this.computedBaseValue()\r\n      },\r\n      () => {\r\n        this.computedTopValue()\r\n      },\r\n      () => {\r\n        this.adjustTopValue()\r\n      },\r\n      () => {\r\n        callback(this.root)\r\n      }\r\n    ]\r\n    asyncRun(task)\r\n  }\r\n\r\n  //  遍历数据计算节点的left、width、height\r\n  computedBaseValue() {\r\n    walk(\r\n      this.renderer.renderTree,\r\n      null,\r\n      (cur, parent, isRoot, layerIndex, index) => {\r\n        let newNode = this.createNode(cur, parent, isRoot, layerIndex)\r\n        // 根节点定位在画布中心位置\r\n        if (isRoot) {\r\n          this.setNodeCenter(newNode)\r\n        } else {\r\n          // 非根节点\r\n          // 三级及以下节点以上级为准\r\n          if (parent._node.dir) {\r\n            newNode.dir = parent._node.dir\r\n          } else {\r\n            // 节点生长方向\r\n            newNode.dir =\r\n              index % 2 === 0\r\n                ? CONSTANTS.LAYOUT_GROW_DIR.RIGHT\r\n                : CONSTANTS.LAYOUT_GROW_DIR.LEFT\r\n          }\r\n          // 根据生长方向定位到父节点的左侧或右侧\r\n          newNode.left =\r\n            newNode.dir === CONSTANTS.LAYOUT_GROW_DIR.RIGHT\r\n              ? parent._node.left +\r\n                parent._node.width +\r\n                this.getMarginX(layerIndex)\r\n              : parent._node.left - this.getMarginX(layerIndex) - newNode.width\r\n        }\r\n        if (!cur.data.expand) {\r\n          return true\r\n        }\r\n      },\r\n      (cur, parent, isRoot, layerIndex) => {\r\n        // 返回时计算节点的leftChildrenAreaHeight和rightChildrenAreaHeight，也就是左侧和右侧子节点所占的高度之和，包括外边距\r\n        if (!cur.data.expand) {\r\n          cur._node.leftChildrenAreaHeight = 0\r\n          cur._node.rightChildrenAreaHeight = 0\r\n          return\r\n        }\r\n        // 理论上只有根节点是存在两个方向的子节点的，其他节点的子节点一定全都是同方向，但是为了逻辑统一，就不按特殊处理的方式来写了\r\n        let leftLen = 0\r\n        let rightLen = 0\r\n        let leftChildrenAreaHeight = 0\r\n        let rightChildrenAreaHeight = 0\r\n        cur._node.children.forEach(item => {\r\n          if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\r\n            leftLen++\r\n            leftChildrenAreaHeight += item.height\r\n          } else {\r\n            rightLen++\r\n            rightChildrenAreaHeight += item.height\r\n          }\r\n        })\r\n        cur._node.leftChildrenAreaHeight =\r\n          leftChildrenAreaHeight +\r\n          (leftLen + 1) * this.getMarginY(layerIndex + 1)\r\n        cur._node.rightChildrenAreaHeight =\r\n          rightChildrenAreaHeight +\r\n          (rightLen + 1) * this.getMarginY(layerIndex + 1)\r\n\r\n        // 如果存在概要，则和概要的高度取最大值\r\n        let generalizationNodeHeight = cur._node.checkHasGeneralization()\r\n          ? cur._node._generalizationNodeHeight +\r\n            this.getMarginY(layerIndex + 1)\r\n          : 0\r\n        cur._node.leftChildrenAreaHeight2 = Math.max(\r\n          cur._node.leftChildrenAreaHeight,\r\n          generalizationNodeHeight\r\n        )\r\n        cur._node.rightChildrenAreaHeight2 = Math.max(\r\n          cur._node.rightChildrenAreaHeight,\r\n          generalizationNodeHeight\r\n        )\r\n      },\r\n      true,\r\n      0\r\n    )\r\n  }\r\n\r\n  //  遍历节点树计算节点的top\r\n  computedTopValue() {\r\n    walk(\r\n      this.root,\r\n      null,\r\n      (node, parent, isRoot, layerIndex) => {\r\n        if (node.getData('expand') && node.children && node.children.length) {\r\n          let marginY = this.getMarginY(layerIndex + 1)\r\n          let baseTop = node.top + node.height / 2 + marginY\r\n          // 第一个子节点的top值 = 该节点中心的top值 - 子节点的高度之和的一半\r\n          let leftTotalTop = baseTop - node.leftChildrenAreaHeight / 2\r\n          let rightTotalTop = baseTop - node.rightChildrenAreaHeight / 2\r\n          node.children.forEach(cur => {\r\n            if (cur.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\r\n              cur.top = leftTotalTop\r\n              leftTotalTop += cur.height + marginY\r\n            } else {\r\n              cur.top = rightTotalTop\r\n              rightTotalTop += cur.height + marginY\r\n            }\r\n          })\r\n        }\r\n      },\r\n      null,\r\n      true\r\n    )\r\n  }\r\n\r\n  //  调整节点top\r\n  adjustTopValue() {\r\n    walk(\r\n      this.root,\r\n      null,\r\n      (node, parent, isRoot, layerIndex) => {\r\n        if (!node.getData('expand')) {\r\n          return\r\n        }\r\n        // 判断子节点所占的高度之和是否大于该节点自身，大于则需要调整位置\r\n        let base = this.getMarginY(layerIndex + 1) * 2 + node.height\r\n        let leftDifference = node.leftChildrenAreaHeight2 - base\r\n        let rightDifference = node.rightChildrenAreaHeight2 - base\r\n        if (leftDifference > 0 || rightDifference > 0) {\r\n          this.updateBrothers(node, leftDifference / 2, rightDifference / 2)\r\n        }\r\n      },\r\n      null,\r\n      true\r\n    )\r\n  }\r\n\r\n  //  更新兄弟节点的top\r\n  updateBrothers(node, leftAddHeight, rightAddHeight) {\r\n    if (node.parent) {\r\n      // 过滤出和自己同方向的节点\r\n      let childrenList = node.parent.children.filter(item => {\r\n        return item.dir === node.dir\r\n      })\r\n      let index = getNodeIndexInNodeList(node, childrenList)\r\n      childrenList.forEach((item, _index) => {\r\n        if (item.hasCustomPosition()) {\r\n          // 适配自定义位置\r\n          return\r\n        }\r\n        let _offset = 0\r\n        let addHeight =\r\n          item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT\r\n            ? leftAddHeight\r\n            : rightAddHeight\r\n        // 上面的节点往上移\r\n        if (_index < index) {\r\n          _offset = -addHeight\r\n        } else if (_index > index) {\r\n          // 下面的节点往下移\r\n          _offset = addHeight\r\n        }\r\n        item.top += _offset\r\n        // 同步更新子节点的位置\r\n        if (item.children && item.children.length) {\r\n          this.updateChildren(item.children, 'top', _offset)\r\n        }\r\n      })\r\n      // 更新父节点的位置\r\n      this.updateBrothers(node.parent, leftAddHeight, rightAddHeight)\r\n    }\r\n  }\r\n\r\n  //  绘制连线，连接该节点到其子节点\r\n  renderLine(node, lines, style, lineStyle) {\r\n    if (lineStyle === 'curve') {\r\n      this.renderLineCurve(node, lines, style)\r\n    } else if (lineStyle === 'direct') {\r\n      this.renderLineDirect(node, lines, style)\r\n    } else {\r\n      this.renderLineStraight(node, lines, style)\r\n    }\r\n  }\r\n\r\n  //  直线风格连线\r\n  renderLineStraight(node, lines, style) {\r\n    if (node.children.length <= 0) {\r\n      return []\r\n    }\r\n    let { left, top, width, height, expandBtnSize } = node\r\n    if (!this.mindMap.opt.alwaysShowExpandBtn) {\r\n      expandBtnSize = 0\r\n    }\r\n    let marginX = this.getMarginX(node.layerIndex + 1)\r\n    let s1 = (marginX - expandBtnSize) * 0.6\r\n    let nodeUseLineStyle = this.mindMap.themeConfig.nodeUseLineStyle\r\n    node.children.forEach((item, index) => {\r\n      let x1 = 0\r\n      let _s = 0\r\n      // 节点使用横线风格，需要额外渲染横线\r\n      let nodeUseLineStyleOffset = nodeUseLineStyle ? item.width : 0\r\n      if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\r\n        _s = -s1\r\n        x1 = node.layerIndex === 0 ? left : left - expandBtnSize\r\n        nodeUseLineStyleOffset = -nodeUseLineStyleOffset\r\n      } else {\r\n        _s = s1\r\n        x1 = node.layerIndex === 0 ? left + width : left + width + expandBtnSize\r\n      }\r\n      let y1 = top + height / 2\r\n      let x2 =\r\n        item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT\r\n          ? item.left + item.width\r\n          : item.left\r\n      let y2 = item.top + item.height / 2\r\n      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1\r\n      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2\r\n      let path = this.createFoldLine([\r\n        [x1, y1],\r\n        [x1 + _s, y1],\r\n        [x1 + _s, y2],\r\n        [x2 + nodeUseLineStyleOffset, y2]\r\n      ])\r\n      this.setLineStyle(style, lines[index], path, item)\r\n    })\r\n  }\r\n\r\n  //  直连风格\r\n  renderLineDirect(node, lines, style) {\r\n    if (node.children.length <= 0) {\r\n      return []\r\n    }\r\n    let { left, top, width, height, expandBtnSize } = node\r\n    if (!this.mindMap.opt.alwaysShowExpandBtn) {\r\n      expandBtnSize = 0\r\n    }\r\n    const { nodeUseLineStyle } = this.mindMap.themeConfig\r\n    node.children.forEach((item, index) => {\r\n      if (node.layerIndex === 0) {\r\n        expandBtnSize = 0\r\n      }\r\n      let x1 =\r\n        item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT\r\n          ? left - expandBtnSize\r\n          : left + width + expandBtnSize\r\n      let y1 = top + height / 2\r\n      let x2 =\r\n        item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT\r\n          ? item.left + item.width\r\n          : item.left\r\n      let y2 = item.top + item.height / 2\r\n      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1\r\n      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2\r\n      // 节点使用横线风格，需要额外渲染横线\r\n      let nodeUseLineStylePath = ''\r\n      if (nodeUseLineStyle) {\r\n        if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\r\n          nodeUseLineStylePath = ` L ${item.left},${y2}`\r\n        } else {\r\n          nodeUseLineStylePath = ` L ${item.left + item.width},${y2}`\r\n        }\r\n      }\r\n      let path = `M ${x1},${y1} L ${x2},${y2}` + nodeUseLineStylePath\r\n      this.setLineStyle(style, lines[index], path, item)\r\n    })\r\n  }\r\n\r\n  //  曲线风格连线\r\n  renderLineCurve(node, lines, style) {\r\n    if (node.children.length <= 0) {\r\n      return []\r\n    }\r\n    let { left, top, width, height, expandBtnSize } = node\r\n    if (!this.mindMap.opt.alwaysShowExpandBtn) {\r\n      expandBtnSize = 0\r\n    }\r\n    const {\r\n      nodeUseLineStyle,\r\n      rootLineKeepSameInCurve,\r\n      rootLineStartPositionKeepSameInCurve\r\n    } = this.mindMap.themeConfig\r\n    node.children.forEach((item, index) => {\r\n      if (node.layerIndex === 0) {\r\n        expandBtnSize = 0\r\n      }\r\n      let x1 =\r\n        node.layerIndex === 0 && !rootLineStartPositionKeepSameInCurve\r\n          ? left + width / 2\r\n          : item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT\r\n          ? left - expandBtnSize\r\n          : left + width + expandBtnSize\r\n      let y1 = top + height / 2\r\n      let x2 =\r\n        item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT\r\n          ? item.left + item.width\r\n          : item.left\r\n      let y2 = item.top + item.height / 2\r\n      let path = ''\r\n      y1 = nodeUseLineStyle && !node.isRoot ? y1 + height / 2 : y1\r\n      y2 = nodeUseLineStyle ? y2 + item.height / 2 : y2\r\n      // 节点使用横线风格，需要额外渲染横线\r\n      let nodeUseLineStylePath = ''\r\n      if (nodeUseLineStyle) {\r\n        if (item.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\r\n          nodeUseLineStylePath = ` L ${item.left},${y2}`\r\n        } else {\r\n          nodeUseLineStylePath = ` L ${item.left + item.width},${y2}`\r\n        }\r\n      }\r\n      if (node.isRoot && !rootLineKeepSameInCurve) {\r\n        path = this.quadraticCurvePath(x1, y1, x2, y2) + nodeUseLineStylePath\r\n      } else {\r\n        path = this.cubicBezierPath(x1, y1, x2, y2) + nodeUseLineStylePath\r\n      }\r\n      this.setLineStyle(style, lines[index], path, item)\r\n    })\r\n  }\r\n\r\n  //  渲染按钮\r\n  renderExpandBtn(node, btn) {\r\n    let { width, height, expandBtnSize } = node\r\n    let { translateX, translateY } = btn.transform()\r\n    // 节点使用横线风格，需要调整展开收起按钮位置\r\n    let nodeUseLineStyleOffset = this.mindMap.themeConfig.nodeUseLineStyle\r\n      ? height / 2\r\n      : 0\r\n    // 位置没有变化则返回\r\n    let _x =\r\n      node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT ? 0 - expandBtnSize : width\r\n    let _y = height / 2 + nodeUseLineStyleOffset\r\n    if (_x === translateX && _y === translateY) {\r\n      return\r\n    }\r\n    let x = _x - translateX\r\n    let y = _y - translateY\r\n    btn.translate(x, y)\r\n  }\r\n\r\n  //  创建概要节点\r\n  renderGeneralization(list) {\r\n    list.forEach(item => {\r\n      let isLeft = item.node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT\r\n      let {\r\n        top,\r\n        bottom,\r\n        left,\r\n        right,\r\n        generalizationLineMargin,\r\n        generalizationNodeMargin\r\n      } = this.getNodeGeneralizationRenderBoundaries(item, 'h')\r\n      let x = isLeft\r\n        ? left - generalizationLineMargin\r\n        : right + generalizationLineMargin\r\n      let x1 = x\r\n      let y1 = top\r\n      let x2 = x\r\n      let y2 = bottom\r\n      let cx = x1 + (isLeft ? -20 : 20)\r\n      let cy = y1 + (y2 - y1) / 2\r\n      let path = `M ${x1},${y1} Q ${cx},${cy} ${x2},${y2}`\r\n      item.generalizationLine.plot(path)\r\n      item.generalizationNode.left =\r\n        x +\r\n        (isLeft ? -generalizationNodeMargin : generalizationNodeMargin) -\r\n        (isLeft ? item.generalizationNode.width : 0)\r\n      item.generalizationNode.top =\r\n        top + (bottom - top - item.generalizationNode.height) / 2\r\n    })\r\n  }\r\n\r\n  // 渲染展开收起按钮的隐藏占位元素\r\n  renderExpandBtnRect(rect, expandBtnSize, width, height, node) {\r\n    if (node.dir === CONSTANTS.LAYOUT_GROW_DIR.LEFT) {\r\n      rect.size(expandBtnSize, height).x(-expandBtnSize).y(0)\r\n    } else {\r\n      rect.size(expandBtnSize, height).x(width).y(0)\r\n    }\r\n  }\r\n}\r\n\r\nexport default MindMap\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}